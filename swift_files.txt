// ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

@MainActor
class QuestionSettingsViewModel: ObservableObject {
    
    @Published var selectedSubject: any SubjectType {
        didSet {
            if let defaultSubject = selectedSubject as? DefaultSubject {
                UserDefaults.standard.set(defaultSubject.rawValue, forKey: "lastSelectedSubject")
            } else if let customSubject = selectedSubject as? CustomSubject {
                UserDefaults.standard.set("custom_" + customSubject.id, forKey: "lastSelectedSubject")
            }
        }
    }
    
    @Published var useTextExtraction: Bool = true {
        didSet {
            UserDefaults.standard.set(useTextExtraction, forKey: "useTextExtraction")
        }
    }
    
    @Published var selectedLanguage: Language = .auto {
        didSet {
            UserDefaults.standard.set(selectedLanguage.rawValue, forKey: "selectedLanguage")
        }
    }
    
    // TextExtraction 관련 상태들
    @Published var extractedTexts: [String: String] = [:]
    @Published var isLoadingTexts: [String: Bool] = [:]
    @Published var extractionStatus: [String: Bool] = [:]
    @Published private(set) var isCameraAuthorized = false
    @Published private(set) var isGalleryAuthorized = false
    @Published var availableSubjects: [SubjectType] = []
    
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private var openAIService: OpenAIService?
    private let totalMaximumQuestions = 10
    private var studyViewModel: StudyViewModel?
    
    // MARK: - UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    private func loadAvailableSubjects() {
        // DefaultSubject를 직접 추가
        var subjects: [any SubjectType] = DefaultSubject.allCases
        
        // 활성화된 사용자 정의 과목 추가
        let activeUserSubjects = SubjectManager.shared.customSubjects
            .filter { $0.isActive }
        subjects.append(contentsOf: activeUserSubjects)
        
        availableSubjects = subjects
        
        // 현재 선택된 과목이 없거나 비활성화된 경우 기본 과목으로 설정
        if !subjects.contains(where: { $0.id == selectedSubject.id }) {
            selectedSubject = DefaultSubject.math  // 기본값으로 math 설정
        }
    }

    private var imageIds: [UIImage: String] = [:]
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView: Bool = false
    @Published var isGeneratingQuestions: Bool = false
    @Published var problemSetName: String = ""
    @Published var isLoading: Bool = false
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool = true
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool = false
    @Published var alertTitle: String = ""
    @Published var alertMessage: String = ""
    
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         }
     }
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
         }
     }
     
    let subject: DefaultSubject
    
     
     // MARK: - Initialization
    init(subject: any SubjectType, homeViewModel: HomeViewModel) {  // selectedTab 매개변수 제거
        self.selectedSubject = subject
        self.subject = subject as? DefaultSubject ?? .math  // 기본값 설정
        self.homeViewModel = homeViewModel
        self.studyViewModel = homeViewModel.studyViewModel
        
        // 저장된 Subject 불러오기
        if let savedSubjectID = UserDefaults.standard.string(forKey: "lastSelectedSubject") {
            if savedSubjectID.starts(with: "custom_") {
                let customID = String(savedSubjectID.dropFirst(7))
                self.selectedSubject = SubjectManager.shared.customSubjects.first { $0.id == customID } ?? subject
            } else {
                self.selectedSubject = DefaultSubject(rawValue: savedSubjectID) ?? subject
            }
        } else {
            self.selectedSubject = subject
        }
        
        // UserDefaults에서 마지막 설정값을 불러오거나, 선택된 subject 사용
        let lastSubjectRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastSubject)
        let lastEducationLevelRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel)
        
        // educationLevel 초기화
        self.educationLevel = EducationLevel(rawValue: lastEducationLevelRaw ?? "") ?? .elementary
        
        // 카운트 초기화
        self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
        self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Initialize network monitoring
         self.isNetworkAvailable = networkMonitor.isReachable
         
         // 기본값 설정
         UserDefaults.standard.register(defaults: ["useTextExtraction": true])
         // 저장된 값 로드
         self.useTextExtraction = UserDefaults.standard.bool(forKey: "useTextExtraction")
         print("📱 Initial useTextExtraction value loaded: \(useTextExtraction)")
         
         // 저장된 언어 설정 불러오기
         if let savedLanguage = UserDefaults.standard.string(forKey: "selectedLanguage"),
            let language = Language(rawValue: savedLanguage) {
             self.selectedLanguage = language
         }
         
         
         // Initialize OpenAI service
         do {
             self.openAIService = try OpenAIService()
         } catch {
             self.error = error
             print("Failed to initialize OpenAI service:", error)
         }
     }
    
    // Add permission check methods
    func checkCameraPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .camera)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
    
    func checkGalleryPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .gallery)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
     
     // MARK: - Image Management
     private func generateImageId() -> String {
         return UUID().uuidString
     }
     
    func getImageId(for image: UIImage) -> String {
        if let existingId = imageIds[image] {
            return existingId
        }
        let newId = generateImageId()
        imageIds[image] = newId
        return newId
    }

    // 새로운 함수 추가
    private func sendExtractedTextToOpenAI(_ text: String) async throws {
        print("📤 Preparing to send extracted text to OpenAI")
        guard let openAIService = openAIService else {
            print("❌ OpenAI service not initialized")
            return
        }
        
        do {
            let response = try await openAIService.sendTextExtractionResult(text)
            print("✅ OpenAI processing completed for extracted text")
            print("📥 OpenAI Response: \(response)")
        } catch {
            print("❌ Failed to process extracted text with OpenAI: \(error)")
            throw error
        }
    }

    private func sendImageToOpenAI(_ imageData: Data) async throws {
        print("📤 Preparing to send image to OpenAI")
        guard let openAIService = openAIService else {
            print("❌ OpenAI service not initialized")
            return
        }
        
        do {
            try await openAIService.sendImageDataToOpenAI(imageData)
            print("✅ Image successfully sent to OpenAI")
        } catch {
            print("❌ Failed to send image to OpenAI: \(error)")
            throw error
        }
    }

    
    func removeImage(at index: Int) {
        guard index < selectedImages.count else { return }
        
        let imageToRemove = selectedImages[index]
        if let imageId = imageIds[imageToRemove] {
            // Remove extracted text for this image
            extractedTexts.removeValue(forKey: imageId)
            imageIds.removeValue(forKey: imageToRemove)
            print("🗑️ Removed text for image: \(imageId)")
        }
        
        selectedImages.remove(at: index)
        
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false
            hasSelectedGallery = false
        }
    }
    
    
    func saveProblemSetName() {
        if problemSetName.isEmpty {
            problemSetName = generateDefaultName()
        }
        
        // 이름이 저장되었음을 알리는 피드백 제공
        HapticManager.shared.impact(style: .medium)
        print("Problem Set name saved: \(problemSetName)")
        
        // 질문 생성이 완료되었고 이름이 저장되었을 때만 StudyView로 이동
        if !isGeneratingQuestions {
            shouldShowStudyView = true
        }
    }
    
    // 기본 이름 생성 메서드
    func generateDefaultName() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMdd_HHmm"
        let dateString = dateFormatter.string(from: Date())
        let totalQuestions = multipleChoiceCount + trueFalseCount
        
        return "\(selectedSubject.displayName)_\(totalQuestions)Q_\(dateString)"
    }
     
     // 기존 resetCounts 메서드 수정
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults 완전 초기화가 필요한 경우를 위한 새로운 메서드
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         resetCounts()
     }
    
    // questionText가 비어있지 않으면 이미지 옵션을 숨기기 위한 계산 속성
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // 텍스트 입력을 리셋하는 메서드
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // 실제 선택된 이미지가 없을 때만 체크
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // 다음 상태 변경을 위해 리셋
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // 상태 리셋
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }

    @MainActor
    func addImage(_ image: UIImage) async {
       print("📸 Starting addImage processing...")
       do {
           let compressedData = try await Task {
               try ImageService.shared.compressForAPI(image)
           }.value

           if let compressedImage = UIImage(data: compressedData) {
               selectedImages.append(compressedImage)
               let imageId = getImageId(for: compressedImage)

               if useTextExtraction {
                   print("🔍 Text extraction enabled for image: \(imageId)")
                   isLoadingTexts[imageId] = true
                   
                   // FileProvider 에러와 상관없이 Vision API 사용
                   do {
                       // VisionService를 통한 텍스트 추출
                       print("📝 Starting Vision API text extraction...")
                       let extractedText = try await VisionService.shared.extractText(from: compressedImage)
                       
                       if !extractedText.isEmpty {
                           print("✅ Text extracted successfully: \(extractedText)")
                           await MainActor.run {
                               extractedTexts[imageId] = extractedText
                               extractionStatus[imageId] = true
                               isLoadingTexts[imageId] = false
                           }
                       } else {
                           print("⚠️ No text extracted from image")
                           await MainActor.run {
                               extractionStatus[imageId] = false
                               isLoadingTexts[imageId] = false
                           }
                       }
                   } catch {
                       print("❌ Text extraction failed: \(error.localizedDescription)")
                       await MainActor.run {
                           extractionStatus[imageId] = false
                           isLoadingTexts[imageId] = false
                       }
                   }
               } else {
                   print("ℹ️ Text extraction disabled - using image directly")
               }
           }
       } catch {
           print("❌ Error in image processing: \(error.localizedDescription)")
           self.error = error
           showError(error)
       }
    }
    
    
    @MainActor
    func sendAllImages() async {
       print("🚀 Starting sendAllImages process...")
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("❌ No content to generate questions from")
           return
       }
       
       isLoading = true
       studyViewModel?.isGeneratingQuestions = true
       
       do {
           var allExtractedText = ""
           var imagesForDirectProcessing: [UIImage] = []
           
           // 이미지 처리
           for image in selectedImages {
               let imageId = getImageId(for: image)
               print("📸 Processing image: \(imageId)")
               
               if useTextExtraction {
                   print("🔍 Text extraction enabled - attempting to extract text...")
                   do {
                       let extractedText = try await VisionService.shared.extractText(from: image)
                       if !extractedText.isEmpty {
                           print("✅ Successfully extracted text: \(extractedText)")
                           allExtractedText += extractedText + "\n"
                       } else {
                           print("⚠️ No text extracted, adding to direct processing queue")
                           imagesForDirectProcessing.append(image)
                       }
                   } catch {
                       print("❌ Error extracting text from image: \(error)")
                       imagesForDirectProcessing.append(image)
                   }
               } else {
                   print("ℹ️ Text extraction disabled - adding to direct processing queue")
                   imagesForDirectProcessing.append(image)
               }
           }

           // 텍스트 입력 처리
           if !questionText.isEmpty {
               let textInput = OpenAIService.QuestionInput(
                   content: questionText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("📝 Processing text input")
               await generateQuestions(from: textInput, parameters: createParameters())
           }
           
           // 추출된 텍스트 처리
           if !allExtractedText.isEmpty {
               let input = OpenAIService.QuestionInput(
                   content: allExtractedText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("📤 Sending extracted text to OpenAI")
               await generateQuestions(from: input, parameters: createParameters())
           }
           
           // 직접 이미지 처리가 필요한 경우 처리
           if !imagesForDirectProcessing.isEmpty {
               print("📸 Processing \(imagesForDirectProcessing.count) images directly")
               for image in imagesForDirectProcessing {
                   print("🖼️ Direct processing image")
                   try await processImageDirectly(image)
               }
           }
           
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           showSuccess()
           shouldShowStudyView = true
           
       } catch {
           print("❌ Error in sendAllImages: \(error.localizedDescription)")
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           self.error = error
           showError(error)
       }
    }
    // generateQuestions(from:parameters:) 보조 함수
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
       print("🔄 Starting question generation from input")
       guard let openAIService = self.openAIService else {
           print("❌ OpenAI service not initialized")
           return
       }
       
       do {
           let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
           print("✅ Successfully generated \(questions.count) questions")
           
           let name = problemSetName.isEmpty ? generateDefaultName() : problemSetName
           await processGeneratedQuestions(questions, name: name)
       } catch {
           print("❌ Error generating questions: \(error)")
           await MainActor.run {
               self.error = error
               showError(error)
           }
       }
    }

    // 직접 이미지 처리를 위한 함수도 수정
    private func processImageDirectly(_ image: UIImage) async throws {
        print("🖼️ Processing image directly...")
        guard let openAIService = self.openAIService else {
            throw NetworkError.apiError("OpenAI service not initialized")
        }
        
        let compressedData = try await imageService.compressForAPI(image)
        let input = OpenAIService.QuestionInput(
            content: compressedData,
            isImage: true
        )
        print("📤 Sending image to OpenAI")
        let questions = try await openAIService.generateQuestions(from: input, parameters: createParameters())
        await processGeneratedQuestions(questions, name: problemSetName)
    }

    private func createParameters() -> OpenAIService.QuestionParameters {
        let subjectToUse = (selectedSubject as? DefaultSubject) ?? .math  // DefaultSubject로 변환
        
        return OpenAIService.QuestionParameters(
            subject: subjectToUse,
            educationLevel: educationLevel,
            questionTypes: [
                QuestionType.multipleChoice: multipleChoiceCount,
                QuestionType.trueFalse: trueFalseCount
            ],
            language: selectedLanguage
        )
    }
    
    // Update image handling methods
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("📸 Processing camera image...")
        guard let image = image else {
            print("❌ No image captured")
            return
        }

        Task {
            do {
                let orientedImage = image.fixedOrientation()
                await addImage(orientedImage)
                hasCameraImage = true
                hasSelectedCamera = true
                hasSelectedGallery = false
                print("✅ Camera image added successfully")
            } catch {
                print("❌ Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }

    @MainActor
    func selectFromGallery() async {
        do {
            let hasPermission = try await imageService.requestPermission(for: .gallery)
            if hasPermission {
                hasSelectedCamera = false  // Reset camera selection
                hasSelectedGallery = true
                showImagePicker = true
                hasGalleryImages = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func takePhoto() async {
        print("📸 Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                hasSelectedGallery = false  // Reset gallery selection
                hasSelectedCamera = true
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func processGeneratedQuestions(_ questions: [Question], name: String) async {
        print("\n🔄 Processing Generated Questions for subject: \(selectedSubject.displayName)")
        
        // 1. Subject 정보 준비
        var subjectType = "default"
        var subjectId = ""
        var subjectName = ""
        var defaultSubject = DefaultSubject.generalKnowledge
        
        if let customSubject = selectedSubject as? CustomSubject {
            subjectType = "custom"
            subjectId = customSubject.id
            subjectName = customSubject.displayName
            defaultSubject = .generalKnowledge
            
            print("""
            📝 Preparing Custom Subject:
            • Name: \(customSubject.displayName)
            • ID: \(customSubject.id)
            • Type: \(subjectType)
            """)
        } else if let defaultSubject = selectedSubject as? DefaultSubject {
            subjectType = "default"
            subjectId = defaultSubject.rawValue
            subjectName = defaultSubject.displayName
            
            print("""
            📝 Preparing Default Subject:
            • Name: \(defaultSubject.displayName)
            • ID: \(defaultSubject.rawValue)
            • Type: \(subjectType)
            """)
        }
        
        // 2. 질문 업데이트
        let updatedQuestions = questions.map { question in
            var updatedQuestion = question
            if let customSubject = selectedSubject as? CustomSubject {
                // CustomSubject인 경우 generalKnowledge로 설정
                updatedQuestion = Question(
                    id: question.id,
                    type: question.type,
                    subject: .generalKnowledge,
                    question: question.question,
                    options: question.options,
                    correctAnswer: question.correctAnswer,
                    explanation: question.explanation,
                    hint: question.hint,
                    isSaved: question.isSaved,
                    createdAt: question.createdAt
                )
            }
            return updatedQuestion
        }
        
        // 3. ProblemSet 생성
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            subject: defaultSubject,
            subjectType: subjectType,
            subjectId: subjectId,
            subjectName: subjectName,
            questions: updatedQuestions,
            createdAt: Date(),
            educationLevel: self.educationLevel,
            name: name
        )
        
        print("""
        📦 Created ProblemSet:
        • ID: \(problemSet.id)
        • Subject Type: \(problemSet.subjectType)
        • Subject ID: \(problemSet.subjectId)
        • Subject Name: \(problemSet.subjectName)
        • Questions Count: \(problemSet.questions.count)
        • Education Level: \(problemSet.educationLevel.rawValue)
        """)
        
        // 4. ProblemSet 저장 및 선택
        await homeViewModel.saveProblemSet(problemSet)
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // 5. 알림 발송
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
        
        print("✅ Problem Set processing completed")
    }

    @MainActor
    private func showSuccess() {
       alertTitle = "Success"
       alertMessage = "Questions have been successfully generated."
       showAlert = true
    }
    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


// ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    @Published var streak: Int = 0
    @Published var correctAnswers: Int = 0 {
        didSet {
            // 점수가 변경될 때마다 출력되는 디버그 로그
            print("📊 StatViewModel score updated: \(correctAnswers * 10) points")
        }
    }
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var isLoading = false
    
    private weak var studyViewModel: StudyViewModel?
    private weak var homeViewModel: HomeViewModel?

    
    @Published var totalPoints: Int = 0      // 현재 세션의 점수
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    

    
    init(context: NSManagedObjectContext,
         homeViewModel: HomeViewModel? = nil,
         studyViewModel: StudyViewModel? = nil) {
        self.context = context
        self.homeViewModel = homeViewModel
        self.studyViewModel = studyViewModel
        
        // Move the loadStats() call to the end of the init method
        loadStats()
    }
    
    var currentSessionScore: Int {
        return correctAnswers * 10  // 계산 속성으로 변경
    }
    
    // StudyViewModel 설정 메서드
    func setStudyViewModel(_ viewModel: StudyViewModel?) {
        self.studyViewModel = viewModel
        print("📱 StudyViewModel connected to StatViewModel")
    }

    
    func updateScore() {
        if let studyVM = studyViewModel {
            // correctAnswers 값을 업데이트
            self.correctAnswers = studyVM.correctAnswers
            self.totalQuestions = studyVM.totalQuestions
            // 디버그를 위한 로그
            print("📊 Score Updated - Correct: \(correctAnswers), Total: \(totalQuestions), Score: \(currentSessionScore)")
        }
    }
    
    func updateStats(correctAnswers: Int, totalQuestions: Int) {
        self.correctAnswers = correctAnswers
        self.completedQuestions = totalQuestions
        self.accuracyRate = totalQuestions > 0 ?
            (Double(correctAnswers) / Double(totalQuestions)) * 100 : 0
            
        print("""
        📊 Stats Updated:
        • Correct Answers: \(correctAnswers)
        • Total Score: \(correctAnswers * 10)
        • Accuracy Rate: \(accuracyRate)%
        """)
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("🔄 Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("🔄 Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    func loadStats() {
        isLoading = true
        let request: NSFetchRequest<CDStudySession> = CDStudySession.fetchRequest()
        
        do {
            let sessions = try context.fetch(request)
            calculateStats(from: sessions)
        } catch {
            print("Failed to fetch study sessions:", error)
        }
        
        isLoading = false
    }

    private func calculateStats(from sessions: [CDStudySession]) {
        totalQuestions = sessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrect = sessions.reduce(0) { total, session in
            total + (session.questions?.filter { ($0 as? CDQuestion)?.isCorrect == true }.count ?? 0)
        }
        
        averageScore = totalQuestions > 0 ? (Double(totalCorrect) / Double(totalQuestions)) * 100 : 0
        correctAnswers = totalCorrect
        completedQuestions = totalQuestions
        totalPoints = completedQuestions * 10
        accuracyRate = completedQuestions > 0 ? (Double(correctAnswers) / Double(completedQuestions)) * 100 : 0
        streak = calculateStreak(from: sessions)
    }

    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
            print("🔄 Starting resetProgress...")
            correctAnswers = 0
            completedQuestions = 0
            accuracyRate = 0
            totalPoints = 0  // 점수 초기화
            
            // HomeViewModel을 통해 StudyViewModel에 접근
            guard let homeVM = homeViewModel else {
                print("❌ homeViewModel is nil in resetProgress")
                return
            }
            
            guard let studyVM = homeVM.studyViewModel else {
                print("❌ studyViewModel is nil in resetProgress")
                return
            }
            
            guard let currentProblemSet = homeVM.selectedProblemSet else {
                print("❌ No selected problem set found")
                return
            }
            guard let homeVM = homeViewModel,
                  let studyVM = homeVM.studyViewModel,
                  let currentProblemSet = homeVM.selectedProblemSet else {
                print("❌ Required view models not found")
                return
                }

                Task {
                    print("🔄 Resetting study state...")
                    await studyVM.resetState()
                    
                    await MainActor.run {
                        print("🔄 Loading questions...")
                        studyVM.loadQuestions(currentProblemSet.questions)
                        
                        print("""
                        ✅ Reset complete:

                        • Total Questions: \(currentProblemSet.questions.count)
                        """)
                    }
                }
            }
        }


// ./AISnapStudy/ViewModels/HomeViewModel.swift

// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    
    @Published var studyViewModel: StudyViewModel?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var selectedProblemSet: ProblemSet?
//    @Published var correctAnswers: Int = 0
    @Published var totalQuestions: Int = 0

    
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()

    
    init() {
        Task {
            await loadInitialData()
        }
    }
    // 현재 세션의 점수 관련 속성 추가
    var currentSessionScore: Int {
        return studyViewModel?.correctAnswers ?? 0
    }
    
    var currentSessionTotalQuestions: Int {
        return selectedProblemSet?.questions.count ?? 0
    }
    
    func setStudyViewModel(_ viewModel: StudyViewModel) {
        print("📱 Setting StudyViewModel in HomeViewModel")
        self.studyViewModel = viewModel
    }
    
    @MainActor
    func resetAndSetProblemSet(_ problemSet: ProblemSet) async {
        print("🔄 Starting complete ProblemSet reset")
        
        // 새로운 ProblemSet 설정
        self.selectedProblemSet = problemSet
        
        // StudyViewModel이 nil이 아닌지 확인
        guard let studyVM = studyViewModel else {
            print("❌ StudyViewModel is nil")
            return
        }
        
        // 상태 리셋 및 문제 다시 로드
        await studyVM.resetState()
        studyVM.loadQuestions(problemSet.questions)
        
        print("""
        ✅ ProblemSet reset complete:
        • ID: \(problemSet.id)
        • Questions: \(problemSet.questions.count)
        • Index reset to 0
        • Current Question: \(studyVM.currentQuestion?.question ?? "none")
        """)
    }
    
    // MARK: - Data Loading
    @MainActor
    private func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("🔵 HomeViewModel - Initial data loading")
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            hasLoadedData = true
            print("✅ Initial data loaded successfully")
        } catch {
            print("❌ Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("🔵 HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // 최근 ProblemSet을 selectedProblemSet으로 설정
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            print("✅ Loaded problem sets: \(problemSets.count)")
            print("✅ Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("❌ Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            print("💾 Saving ProblemSet with \(problemSet.questions.count) questions")
            try await coreDataService.saveProblemSet(problemSet)
            
            // 데이터 리로드 대신 문제 세트 직접 추가
            problemSets.insert(problemSet, at: 0)
            setSelectedProblemSet(problemSet)
            
            print("✅ Saved ProblemSet: \(problemSet.questions.count) questions")
        } catch {
            self.error = error
            print("❌ Failed to save ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("🔵 HomeViewModel - Setting selected problem set")
        
        // 상태 변경을 메인 스레드에서 한번에 처리
        DispatchQueue.main.async {
            self.selectedProblemSet = problemSet
            
            if let problemSet = problemSet {
                print("""
                ✅ ProblemSet set successfully:
                • ID: \(problemSet.id)
                • Questions: \(problemSet.questions.count)
                """)
            }
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("❌ Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("❌ Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                📝 Stored ProblemSets:
                • Count: \(storedSets.count)
                • Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("❌ Failed to verify storage: \(error)")
            }
        }
    }
}

extension HomeViewModel {
    @MainActor
    func renameProblemSet(_ problemSet: ProblemSet, newName: String) async {
        do {
            // Create a new ProblemSet with updated name
            var updatedProblemSet = problemSet
            updatedProblemSet.name = newName
            
            // Update in CoreData
            try await Task {
                try coreDataService.updateProblemSet(problemSet, newName: newName)
            }.value
        
            
            if let index = problemSets.firstIndex(where: { $0.id == problemSet.id }) {
                problemSets[index] = problemSets[index].copy(withName: newName)
                
                // Update selected problem set if needed
                if selectedProblemSet?.id == problemSet.id {
                    selectedProblemSet = problemSets[index]
                }
            }
            
            // Notify all observers
            objectWillChange.send()
            
            print("""
            ✅ Problem Set renamed and updated:
            • ID: \(problemSet.id)
            • New Name: \(newName)
            • In Memory Update: Success
            """)
        } catch {
            print("❌ Failed to rename problem set: \(error)")
        }
    }
    
    @MainActor
    func deleteProblemSet(_ problemSet: ProblemSet) async {
        do {
            try await coreDataService.deleteProblemSet(problemSet)
            problemSets.removeAll { $0.id == problemSet.id }
            
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = nil
            }
            
            print("""
            ✅ Problem Set deleted:
            • ID: \(problemSet.id)
            • Name: \(problemSet.name)
            """)
        } catch {
            self.error = error
            print("❌ Failed to delete problem set: \(error)")
        }
    }
}


// ./AISnapStudy/ViewModels/ReviewViewModel.swift


import Foundation

@MainActor
class ReviewViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            📚 Review Data Loaded:
            • Study Sessions: \(studySessions.count)
            • Problem Sets: \(problemSets.count)
            • Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("❌ Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("✅ Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("❌ Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("📱 HomeViewModel reference set in ReviewViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


// ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
    // OpenAIService 타입 참조 추가
    typealias QuestionInput = OpenAIService.QuestionInput
    typealias QuestionParameters = OpenAIService.QuestionParameters
    private weak var statViewModel: StatViewModel?

    @Published private(set) var loadedQuestions: [Question] = []
    @Published private(set) var loadingProgress = 0

    private let openAIService: OpenAIService

    @Published private(set) var currentQuestion: Question?
    @Published var selectedAnswer: String?
    @Published var showExplanation = false
    private var questions: [Question] = []
    private var cancellables = Set<AnyCancellable>()
    @Published private(set) var currentIndex = 0
    @Published var correctAnswers: Int = 0

    // 질문 생성 관련 프로퍼티 추가
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    
    func setStatViewModel(_ viewModel: StatViewModel) {
        self.statViewModel = viewModel
    }

    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }

    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }

    var totalQuestions: Int {
        questions.count
    }

    private let context: NSManagedObjectContext
    private var currentSession: CDStudySession?
    private let homeViewModel: HomeViewModel

    private var hasInitialized = false

    init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
        self.context = context
        self.homeViewModel = homeViewModel

        // OpenAIService 초기화
        do {
            self.openAIService = try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAI service: \(error)")
        }

        Task { @MainActor in
            homeViewModel.$selectedProblemSet
                .compactMap { $0 }
                .removeDuplicates(by: { $0.id == $1.id })
                .receive(on: RunLoop.main)
                .sink { [weak self] problemSet in
                    guard let self = self else { return }
                    // async 메서드를 Task 내에서 호출하도록 수정
                    Task {
                        await self.resetState()
                        await MainActor.run {
                            self.loadQuestions(problemSet.questions)
                        }
                    }
                }
                .store(in: &self.cancellables)
        }

        setupCurrentSession()
    }


    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []

        // 예상되는 총 질문 수 계산
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)

        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            await MainActor.run {
                questions.forEach { question in
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }

        await MainActor.run {
            isGeneratingQuestions = false
            loadedQuestions = generatedQuestions
            loadingProgress = 100
            isLoadingQuestions = false
        }
    }
   
    @MainActor
    func resetState() async {
        print("🔄 Performing complete state reset")
        currentIndex = 0
        selectedAnswer = nil
        showExplanation = false
        correctAnswers = 0
        
        await MainActor.run {
            questions.removeAll()
            
            if let problemSet = homeViewModel.selectedProblemSet {
                questions = problemSet.questions
                currentQuestion = questions.first
            }
        }
        
        print("""
        ✅ State reset complete:
        • Questions count: \(questions.count)
        • Current index: \(currentIndex)
        • Current question: \(currentQuestion?.question ?? "No question loaded")
        """)
    }
   
    @MainActor
    func loadQuestions(_ newQuestions: [Question]) {
        guard questions != newQuestions else {
            print("⚠️ Same questions already loaded, skipping")
            return
        }
        
        print("📝 Loading fresh set of \(newQuestions.count) questions")
        questions = newQuestions
        currentIndex = 0
        currentQuestion = questions.isEmpty ? nil : questions[0]
        
        print("✅ Questions loaded: \(currentQuestion?.question ?? "No question loaded")")
    }
   
   private func setupCurrentSession() {
       let session = CDStudySession(context: context)
       session.startTime = Date()
       currentSession = session
       saveContext()
   }
   
    func submitAnswer() {
        guard let currentQuestion = currentQuestion else { return }
        
        print("Debug True/False Detailed:")
        print("Selected Answer (raw): \(selectedAnswer ?? "nil")")
        print("Selected Answer (lowercased): \(selectedAnswer?.lowercased() ?? "nil")")
        print("Correct Answer (raw): \(currentQuestion.correctAnswer)")
        print("Correct Answer (lowercased): \(currentQuestion.correctAnswer.lowercased())")
        print("Are they equal? \(currentQuestion.correctAnswer.lowercased() == selectedAnswer?.lowercased())")
        print("Length of selected answer: \(selectedAnswer?.count ?? 0)")
        print("Length of correct answer: \(currentQuestion.correctAnswer.count)")
        
        // Trim whitespace and convert to lowercase for comparison
        let trimmedSelected = selectedAnswer?.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedCorrect = currentQuestion.correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        
        let isCorrect = trimmedSelected == trimmedCorrect
        
        if isCorrect {
            correctAnswers += 1
            // Update score in StatViewModel
            DispatchQueue.main.async {
                self.statViewModel?.correctAnswers = self.correctAnswers
                // Debug log for score update
                print("✅ Correct answer! Total correct: \(self.correctAnswers)")
            }
        }

        print("Trimmed Selected: '\(trimmedSelected ?? "nil")'")
        print("Trimmed Correct: '\(trimmedCorrect)'")
        print("Final comparison result: \(isCorrect)")
        

        if let session = currentSession {
            let question = CDQuestion(context: context)
            question.isCorrect = isCorrect
            question.question = currentQuestion.question
            question.session = session
            saveContext()
        }
        
        showExplanation = true
    }

   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
   private func saveContext() {
       do {
           try context.save()
       } catch {
           print("Failed to save context: \(error)")
       }
   }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("✅ Question save state toggled successfully")
       } catch {
           print("❌ Failed to toggle question save state: \(error)")
       }
   }
}


// ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
        setupMetal()
    }

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
        }
    }
    
    private func setupMetal() {
        // Metal 디바이스 체크
        guard MTLCreateSystemDefaultDevice() != nil else {
            print("Metal is not supported on this device")
            return
        }
        
        // MetalTools 프레임워크 초기화 지연
        DispatchQueue.main.async {
            // MetalTools 관련 작업
        }
    }
    
    private func setupAppearance() {
        // 네비게이션 바 스타일 설정
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        
        // 탭 바 스타일 설정
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        return true
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        📊 CoreData Configuration:
        • Store Descriptions: \(container.persistentStoreDescriptions.count)
        • View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("❌ No store URL found")
            return
        }
        
        print("• Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("✅ Created CoreData directory")
        } catch {
            print("❌ Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData 옵션 설정
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // 성능 최적화 설정
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


// ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


// ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


// ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


// ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



// ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


// ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


// ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    let day: String          // "Mon", "Tue", etc.
    let questionsCompleted: Int
    let correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.day = date.formatted(.dateTime.weekday(.abbreviated))
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


// ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // 추가: Structured Outputs의 refusal 처리를 위해
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


// ./AISnapStudy/Models/Language.swift




// ./AISnapStudy/Models/ProblemSet.swift

import Foundation

public struct ProblemSet: Identifiable, Codable, Hashable {
    // Core properties
    public let id: String
    public let subject: SubjectType  // 필수 프로퍼티로 유지
    public let subjectType: String
    public let subjectId: String
    public let subjectName: String
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?
    public var isFavorite: Bool

    public var questionCount: Int {
        questions.count
    }

    public var resolvedSubject: SubjectType {
        if subjectType == "default" {
            return DefaultSubject(rawValue: subjectId) ?? .generalKnowledge
        } else {
            return SubjectManager.shared.customSubjects.first(where: { $0.id == subjectId }) ?? DefaultSubject.generalKnowledge
        }
    }

    // CustomSubject를 위한 생성자
    public init(
        id: String = UUID().uuidString,
        subject: SubjectType,
        subjectType: String,
        subjectId: String,
        subjectName: String,
        questions: [Question],
        createdAt: Date = Date(),
        educationLevel: EducationLevel,
        name: String
    ) {
        self.id = id
        self.subject = subject
        self.subjectType = subjectType
        self.subjectId = subjectId
        self.subjectName = subjectName
        self.questions = questions
        self.createdAt = createdAt
        self.educationLevel = educationLevel
        self.name = name
        self.tags = []
        self.problemSetDescription = nil
        self.isFavorite = false
    }

    private enum CodingKeys: String, CodingKey {
        case id, subject, subjectType, subjectId, subjectName
        case questions, createdAt, lastAttempted
        case educationLevel, name, tags
        case problemSetDescription, isFavorite
    }

    public init(from decoder: Decoder) throws {
        
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        
        // Properly decode subject based on subjectType
        subjectType = try container.decode(String.self, forKey: .subjectType)
        subjectId = try container.decode(String.self, forKey: .subjectId)
        subjectName = try container.decode(String.self, forKey: .subjectName)
        
        if subjectType == "custom" {
            subject = CustomSubject(id: subjectId, name: subjectName, icon: "book.fill")
        } else {
            subject = try container.decode(DefaultSubject.self, forKey: .subject)
        }
        
        // Decode remaining properties
        questions = try container.decode([Question].self, forKey: .questions)
        createdAt = try container.decode(Date.self, forKey: .createdAt)
        lastAttempted = try container.decodeIfPresent(Date.self, forKey: .lastAttempted)
        educationLevel = try container.decode(EducationLevel.self, forKey: .educationLevel)
        name = try container.decode(String.self, forKey: .name)
        tags = try container.decode([String].self, forKey: .tags)
        problemSetDescription = try container.decodeIfPresent(String.self, forKey: .problemSetDescription)
        isFavorite = try container.decode(Bool.self, forKey: .isFavorite)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(subject, forKey: .subject)
        try container.encode(subjectType, forKey: .subjectType)
        try container.encode(subjectId, forKey: .subjectId)
        try container.encode(subjectName, forKey: .subjectName)
        try container.encode(questions, forKey: .questions)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(lastAttempted, forKey: .lastAttempted)
        try container.encode(educationLevel, forKey: .educationLevel)
        try container.encode(name, forKey: .name)
        try container.encode(tags, forKey: .tags)
        try container.encodeIfPresent(problemSetDescription, forKey: .problemSetDescription)
        try container.encode(isFavorite, forKey: .isFavorite)
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/ReviewFilter.swift


import Foundation

enum ReviewFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



// ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
   case multipleChoice = "multiple_choice"
   case trueFalse = "true_false"
}

public struct Question: Identifiable, Codable, Hashable {
   public let id: String
   public let type: QuestionType
   public let subject: DefaultSubject  // Subject를 DefaultSubject로 변경
   public let question: String
   public let options: [String]
   public let correctAnswer: String
   public let explanation: String
   public let hint: String?
   public var isSaved: Bool
   public let createdAt: Date
   
   private enum CodingKeys: String, CodingKey {
       case id, type, subject, question, options
       case correctAnswer, explanation, hint
       case isSaved, createdAt
   }
   
   public init(
       id: String,
       type: QuestionType,
       subject: DefaultSubject,  // Subject를 DefaultSubject로 변경
       question: String,
       options: [String] = [],
       correctAnswer: String,
       explanation: String,
       hint: String? = nil,
       isSaved: Bool = false,
       createdAt: Date = Date()
   ) {
       self.id = id
       self.type = type
       self.subject = subject
       self.question = question
       self.options = options
       self.correctAnswer = correctAnswer
       self.explanation = explanation
       self.hint = hint
       self.isSaved = isSaved
       self.createdAt = createdAt
   }
   
   // Decodable 구현
   public init(from decoder: Decoder) throws {
       let container = try decoder.container(keyedBy: CodingKeys.self)
       
       id = try container.decode(String.self, forKey: .id)
       type = try container.decode(QuestionType.self, forKey: .type)
       subject = try container.decode(DefaultSubject.self, forKey: .subject)
       question = try container.decode(String.self, forKey: .question)
       options = try container.decode([String].self, forKey: .options)
       correctAnswer = try container.decode(String.self, forKey: .correctAnswer)
       explanation = try container.decode(String.self, forKey: .explanation)
       hint = try container.decodeIfPresent(String.self, forKey: .hint)
       isSaved = try container.decode(Bool.self, forKey: .isSaved)
       createdAt = try container.decode(Date.self, forKey: .createdAt)
   }
    // Hashable 프로토콜 요구사항을 여기에 직접 구현
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
   
   // Encodable 구현
   public func encode(to encoder: Encoder) throws {
       var container = encoder.container(keyedBy: CodingKeys.self)
       
       try container.encode(id, forKey: .id)
       try container.encode(type, forKey: .type)
       try container.encode(subject, forKey: .subject)
       try container.encode(question, forKey: .question)
       try container.encode(options, forKey: .options)
       try container.encode(correctAnswer, forKey: .correctAnswer)
       try container.encode(explanation, forKey: .explanation)
       try container.encodeIfPresent(hint, forKey: .hint)
       try container.encode(isSaved, forKey: .isSaved)
       try container.encode(createdAt, forKey: .createdAt)
   }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
   public static var supportsSecureCoding: Bool {
       return true
   }
   
   let question: Question
   
   init(question: Question) {
       self.question = question
       super.init()
   }
   
   public func encode(with coder: NSCoder) {
       coder.encode(question.id, forKey: "id")
       coder.encode(question.type.rawValue, forKey: "type")
       coder.encode(question.subject.rawValue, forKey: "subject")
       coder.encode(question.question, forKey: "question")
       coder.encode(question.options, forKey: "options")
       coder.encode(question.correctAnswer, forKey: "correctAnswer")
       coder.encode(question.explanation, forKey: "explanation")
       coder.encode(question.hint, forKey: "hint")
       coder.encode(question.isSaved, forKey: "isSaved")
       coder.encode(question.createdAt, forKey: "createdAt")
   }
   
   public required init?(coder: NSCoder) {
       guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
             let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
             let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
             let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
             let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
             let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
             let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
           return nil
       }
       
       let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
       let isSaved = coder.decodeBool(forKey: "isSaved")
       let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
       
       let question = Question(
           id: id,
           type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
           subject: DefaultSubject(rawValue: subjectRaw) ?? .math,  // Subject를 DefaultSubject로 변경
           question: questionText,
           options: options,
           correctAnswer: correctAnswer,
           explanation: explanation,
           hint: hint,
           isSaved: isSaved,
           createdAt: createdAt
       )
       
       self.question = question
       super.init()
   }
}

extension Question {
    var processedCorrectAnswer: String {
        switch type {
        case .trueFalse:
            return correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        case .multipleChoice:
            return correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines)
        }
    }
}


// ./AISnapStudy/Models/Subject.swift


import SwiftUI

// MARK: - Basic Subject Protocol
public protocol SubjectType: Codable {
   var id: String { get }
   var displayName: String { get }
   var color: Color { get }
   var icon: String { get }
   var rawValue: String { get }  // 추가
}



// MARK: - Default System Subjects
public enum DefaultSubject: String, Codable, CaseIterable, SubjectType {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    
    public var id: String {
        self.rawValue
    }
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        }
    }
    
    // 기존의 displayName을 baseDisplayName으로 변경
    private var baseDisplayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        }
    }
}

// CustomSubject 구조체 추가
public struct CustomSubject: SubjectType, Codable, Identifiable {
    public let id: String
    public var name: String  // let을 var로 변경
    public let icon: String
    public var isActive: Bool
    
    // SubjectType 프로토콜 요구사항
    public var displayName: String { name }
    public var color: Color { .green }  // 계산 프로퍼티로 변경
    public var rawValue: String { id }  // 추가: id를 rawValue로 사용
    
    // 기본 초기화자
    public init(id: String = UUID().uuidString,
                name: String,
                icon: String,
                isActive: Bool = true) {
        self.id = id
        self.name = name
        self.icon = icon
        self.isActive = isActive
    }
    
    // Codable 구현
    enum CodingKeys: String, CodingKey {
        case id, name, icon, isActive
        // color는 제외 - 항상 .green을 사용할 것이므로
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        icon = try container.decode(String.self, forKey: .icon)
        isActive = try container.decode(Bool.self, forKey: .isActive)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(icon, forKey: .icon)
        try container.encode(isActive, forKey: .isActive)
    }
}



// MARK: - Custom User Subject
public struct UserSubject: Identifiable, Codable, Hashable, SubjectType {
   public let id: String
   public var name: String
   public var colorHex: String
   public var iconName: String
   public var createdAt: Date
   public var isActive: Bool
   
   public var displayName: String {
       name
   }
   
   public var color: Color {
       Color(hex: colorHex) ?? .gray
   }
   
   public var icon: String {
       iconName
   }
    
    public var rawValue: String { id }  // 추가: id를 rawValue로 사용
}

// MARK: - Education Level
public enum EducationLevel: String, Codable, CaseIterable {
   case elementary = "elementary"
   case middle = "middle"
   case high = "high"
   case college = "college"
   
   public var displayName: String {
       switch self {
       case .elementary:
           return "Elementary"
       case .middle:
           return "Middle"
       case .high:
           return "High"
       case .college:
           return "College"
       }
   }
   
   public var color: Color {
       switch self {
       case .elementary:
           return .green
       case .middle:
           return .green
       case .high:
           return .green
       case .college:
           return .green
       }
   }
}

public class SubjectManager: ObservableObject {
    public static let shared = SubjectManager()
    
    private init() {
        loadSettings()
        loadCustomSubjects()
    }
    
    @Published private(set) var customSubjects: [CustomSubject] = []
    @Published private(set) var hiddenDefaultSubjects: Set<String> = []
    @Published private(set) var modifiedDefaultSubjects: [String: String] = [:]
    
    // 새로운 과목 추가
    func addCustomSubject(name: String, icon: String = "book.circle") {
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveCustomSubjects()
    }
    
    // 과목 제거
    func removeCustomSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveCustomSubjects()
    }
    
    // UserDefaults를 사용한 저장 및 로드
    private func saveCustomSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    private func loadCustomSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            self.customSubjects = decoded
        }
    }
    
    // "삭제된" 과목 복원을 위한 백업 저장
    private var deletedSubjectsBackup: Set<String> = []
    
    func isDeleted(_ subjectId: String) -> Bool {
            return hiddenDefaultSubjects.contains(subjectId)
        }
        
    func toggleDefaultSubject(_ subject: DefaultSubject) {
        print("🔄 Toggling subject visibility: \(subject.displayName)")
        if hiddenDefaultSubjects.contains(subject.id) {
            print("➖ Removing from hidden: \(subject.id)")
            hiddenDefaultSubjects.remove(subject.id)
        } else {
            print("➕ Adding to hidden: \(subject.id)")
            hiddenDefaultSubjects.insert(subject.id)
        }
        saveAndNotify()
        print("📊 Current hidden subjects: \(hiddenDefaultSubjects)")
    }
        
    private func saveAndNotify() {
        saveSettings()
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    // 로드 시 UserDefaults에서 설정 불러오기
    private func loadSettings() {
        if let hidden = UserDefaults.standard.array(forKey: "hiddenDefaultSubjects") as? [String] {
            hiddenDefaultSubjects = Set(hidden)
        }
        modifiedDefaultSubjects = UserDefaults.standard.dictionary(forKey: "modifiedDefaultSubjects") as? [String: String] ?? [:]
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
        }
        // 변경사항을 알림
        notifySubjectsChange()
    }

    
    // 과목 이름 업데이트 함수 수정
    func updateDefaultSubjectName(_ subject: DefaultSubject, newName: String) {
        print("✏️ Updating name for subject: \(subject.displayName) to: \(newName)")
        modifiedDefaultSubjects[subject.id] = newName
        print("💾 Current modified names: \(modifiedDefaultSubjects)")
        saveAndNotify()
    }
    
    // 과목 이름 초기화 함수 수정
    func resetDefaultSubjectName(_ subject: DefaultSubject) {
        modifiedDefaultSubjects.removeValue(forKey: subject.id)
        saveAndNotify()
    }
    
    // 변경사항 알림을 위한 NotificationCenter 키
    static let subjectsDidChangeNotification = Notification.Name("SubjectsDidChange")
    
    private func notifySubjectsChange() {
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    
    // 과목 "삭제" (실제로는 숨김)
    func deleteDefaultSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.insert(subject.id)
        deletedSubjectsBackup.insert(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // 삭제된 과목 복원
    func restoreDeletedSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.remove(subject.id)
        deletedSubjectsBackup.remove(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // 과목이 "삭제"되었는지 확인
    func isDeleted(_ subject: DefaultSubject) -> Bool {
        hiddenDefaultSubjects.contains(subject.id)
    }
    
    // 사용 가능한(삭제되지 않은) 과목들 가져오기
    var availableSubjects: [any SubjectType] {
        let visibleDefaultSubjects = DefaultSubject.allCases.filter { !hiddenDefaultSubjects.contains($0.id) }
        let activeCustomSubjects = customSubjects.filter { $0.isActive }
        return visibleDefaultSubjects + activeCustomSubjects
    }
    
    // 저장된 설정에 삭제된 과목 정보 포함
    private func saveSettings() {
        UserDefaults.standard.set(Array(hiddenDefaultSubjects), forKey: "hiddenDefaultSubjects")
        UserDefaults.standard.set(Array(deletedSubjectsBackup), forKey: "deletedSubjectsBackup")
        UserDefaults.standard.set(modifiedDefaultSubjects, forKey: "modifiedDefaultSubjects")
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    
    

    
    // 기본 과목 이름 관리 메서드 추가
    func getDisplayName(for subject: DefaultSubject) -> String {
        return modifiedDefaultSubjects[subject.id] ?? subject.displayName
    }
    

    
    // CustomSubject 관리 메서드
    func updateSubject(_ subject: CustomSubject, newName: String) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].name = newName
            saveSettings()
        }
    }
    
    func toggleSubjectActive(_ subject: CustomSubject) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].isActive.toggle()
            saveSettings()
        }
    }
    
    func deleteSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveSettings()
    }
    

    
    // 기본 과목 숨김 상태 관리
        func toggleSubjectVisibility(_ subject: DefaultSubject) {
            if hiddenDefaultSubjects.contains(subject.id) {
                hiddenDefaultSubjects.remove(subject.id)
            } else {
                hiddenDefaultSubjects.insert(subject.id)
            }
            saveSettings()
        }
        
        // 과목이 숨겨져 있는지 확인
        func isHidden(_ subject: DefaultSubject) -> Bool {
            hiddenDefaultSubjects.contains(subject.id)
        }
        
        
        // 모든 활성화된 과목 가져오기 (숨겨지지 않은 기본 과목 + 활성화된 사용자 정의 과목)
    var allSubjects: [SubjectType] {
        var subjects: [SubjectType] = Array(DefaultSubject.allCases)
        subjects.append(contentsOf: customSubjects.filter { $0.isActive })
        return subjects
    }
    
    
    // 과목 추가 메서드 수정
    func addSubject(name: String, icon: String) {  // color 매개변수 제거
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveSubjects()
        
        print("""
        ✅ Added new custom subject:
        • Name: \(name)
        • ID: \(newSubject.id)
        • Total custom subjects: \(customSubjects.count)
        """)
    }
    
    // 저장 메서드 수정
    private func saveSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
            print("💾 Saved \(customSubjects.count) custom subjects to UserDefaults")
        }
    }
    
    // 로드 메서드 수정
    private func loadSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
            print("📤 Loaded \(customSubjects.count) custom subjects from UserDefaults")
            print("📚 Custom Subjects: \(customSubjects.map { $0.displayName })")
        }
    }
    
}



// MARK: - Color Extension for Hex
extension Color {
    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components else { return nil }
        
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        let hex = String(format: "%02lX%02lX%02lX",
                        lroundf(r * 255),
                        lroundf(g * 255),
                        lroundf(b * 255))
        
        return hex
    }
    
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        
        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else {
            return nil
        }
        
        let r = Double((rgb & 0xFF0000) >> 16) / 255.0
        let g = Double((rgb & 0x00FF00) >> 8) / 255.0
        let b = Double(rgb & 0x0000FF) / 255.0
        
        self.init(red: r, green: g, blue: b)
    }
}


// ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // 실제 구현에서는 저장 상태를 확인하는 로직 추가
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


// ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


// ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


// ./AISnapStudy/Views/Question/QuestionSettingsView.swift



import SwiftUI
import PhotosUI
import UIKit
import AVFoundation

struct QuestionSettingsView: View {
    @StateObject private var viewModel: QuestionSettingsViewModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedTab: Int
    @State private var expandedSections: Set<SectionType> = []
    @State private var isTextInputSelected = false
    @State private var showNamePopup = false
    @State private var isGeneratingQuestions = false
    @State private var activeSheet: ActiveSheet?
    
    // 여기를 Subject에서 DefaultSubject로 변경
    let subject: DefaultSubject  // Subject를 DefaultSubject로 변경
    
    public enum SectionType: Hashable {
        case questionAbout
        case learningSubject
        case questionTypes
        case educationLevel
    }
    
    private enum ActiveSheet: Identifiable {
        case camera, gallery
        
        var id: Int {
            switch self {
            case .camera: return 1
            case .gallery: return 2
            }
        }
    }
    
    
    init(subject: DefaultSubject, homeViewModel: HomeViewModel, selectedTab: Binding<Int>) {
        self.subject = subject
        self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
            subject: subject,
            homeViewModel: homeViewModel
        ))
        self._selectedTab = selectedTab
    }

    var body: some View {
        VStack(spacing: 0) {
            // Instructions Card
            Form {
                // Speed Up and Language Selection Section
                Section {
                    SpeedUpSection(useTextExtraction: $viewModel.useTextExtraction)
                }
                .listRowSpacing(0)

                Section {
                    LanguageSection(selectedLanguage: $viewModel.selectedLanguage)
                }
                .listRowSpacing(0)
                
                VStack(alignment: .leading, spacing: 10) {
                    Text("How to Generate Questions")
                        .font(.headline)
                        .padding(.bottom, 4)
                    
                    Text("Select one of these methods here and then choose Subject and Type to create questions:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    // Input Methods with descriptions
                    HStack(spacing: 12) {
                        Group {
                            InputMethodCard(
                                icon: "camera.fill",
                                title: "Camera",
                                isUsed: viewModel.hasSelectedCamera,
                                isDisabled: !viewModel.canUseImageInput,
                                action: {
                                    if viewModel.canUseImageInput {
                                        viewModel.isTextInputActive = false
                                        Task {
                                            if await viewModel.checkCameraPermission() {
                                                activeSheet = .camera
                                            }
                                        }
                                    }
                                }
                            )
                            .frame(maxWidth: .infinity)
                        }
                        
                        
                        Group {
                            InputMethodCard(
                                icon: "photo.fill",
                                title: "Gallery",
                                isUsed: viewModel.hasSelectedGallery,
                                isDisabled: !viewModel.canUseImageInput,
                                action: {
                                    if viewModel.canUseImageInput {
                                        viewModel.isTextInputActive = false
                                        Task {
                                            if await viewModel.checkGalleryPermission() {
                                                activeSheet = .gallery
                                            }
                                        }
                                    }
                                }
                            )
                            .frame(maxWidth: .infinity)
                        }
                        
                        Group {
                            InputMethodCard(
                                icon: "text.bubble.fill",
                                title: "Text",
                                isUsed: viewModel.isTextInputActive,
                                isDisabled: !viewModel.canUseTextInput,
                                action: {
                                    viewModel.toggleTextInput()
                                }
                            )
                            .frame(maxWidth: .infinity)
                        }
                    }
                }
                .padding()
                .background(Color(.systemBackground))
                .cornerRadius(12)
                
                // Text Input Field
                if viewModel.isTextInputActive {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .padding(.horizontal)
                }

                // Selected Images Display
                if !viewModel.selectedImages.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                SelectedImageCell(
                                    image: viewModel.selectedImages[index],
                                    onDelete: {
                                        viewModel.removeImage(at: index)
                                    }
                                )
                            }
                        }
                        .padding(.vertical, 8)
                    }
                }
                
                // Subject Section
                Section {
                    DisclosureGroup(
                        isExpanded: isExpandedBinding(for: .learningSubject)
                    ) {
                        LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                    } label: {
                        HStack {
                            Text("Subject")
                                .font(.headline)
                            Spacer()
                            Text(viewModel.selectedSubject.displayName)
                                .foregroundColor(.gray)
                        }
                    }
                }.listRowSpacing(0)
                
                if viewModel.isTextInputActive {
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .educationLevel)
                        ) {
                            EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                        } label: {
                            HStack {
                                Text("Education")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.educationLevel.displayName)
                                    .foregroundColor(.gray)
                            }
                        }
                    }.listRowSpacing(0)
                }

                
                // Question Types Section
                Section {
                    DisclosureGroup(
                        isExpanded: isExpandedBinding(for: .questionTypes)
                    ) {
                        QuestionTypesSelectionSection(viewModel: viewModel)
                    } label: {
                        HStack {
                            Text("Type")
                                .font(.headline)
                            Spacer()
                            Text("\(viewModel.totalQuestionCount) questions")
                                .foregroundColor(.gray)
                        }
                    }
                }.listRowSpacing(0)
                
                if isTextInputSelected {
                    // Education Level Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .educationLevel)
                        ) {
                            EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                        } label: {
                            HStack {
                                Text("Education")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.educationLevel.displayName)
                                    .foregroundColor(.gray)
                            }
                        }
                    }.listRowSpacing(0)
                }
            }
            .listSectionSpacing(4)
            
            // Generate Questions Button
            VStack {
                Button(action: {
                    showNamePopup = true
                    isGeneratingQuestions = true
                    Task {
                        await viewModel.sendAllImages()
                    }
                }) {
                    Text("Generate Questions")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                        .cornerRadius(10)
                }
                .disabled(!isGenerateButtonEnabled)
                .padding()
            }
            .background(Color(UIColor.systemGroupedBackground))
        }
        .overlay(popupOverlay)
        .navigationBarItems(leading: cancelButton)
        .navigationBarTitleDisplayMode(.inline)
        .sheet(item: $activeSheet) { sheet in
            switch sheet {
            case .camera:
                ImagePicker(
                    image: $viewModel.selectedImage,
                    sourceType: .camera,
                    onImageSelected: { image in
                        Task {
                            await viewModel.handleCameraImage(image)
                        }
                    }
                )
                .interactiveDismissDisabled()
                
            case .gallery:
                PhotoPicker(selectedImages: $viewModel.selectedImages)
                    .interactiveDismissDisabled()
            }
        }
        .alert(isPresented: $viewModel.showAlert) {
            Alert(
                title: Text(viewModel.alertTitle),
                message: Text(viewModel.alertMessage),
                dismissButton: .default(Text("OK")) {
                    if viewModel.alertTitle == "Success" {
                        dismiss()
                    }
                }
            )
        }
        .onChange(of: viewModel.shouldShowStudyView) { show in
            if show {
                dismiss()
                selectedTab = 1
            }
        }
    }
    
    private var cancelButton: some View {
        Button("Cancel") {
            viewModel.resetCounts()
            dismiss()
        }
    }
    
    private var popupOverlay: some View {
        Group {
            if showNamePopup {
                ProblemSetNamePopup(
                    isPresented: $showNamePopup,
                    problemSetName: $viewModel.problemSetName,
                    isGeneratingQuestions: $viewModel.isGeneratingQuestions,
                    defaultName: viewModel.generateDefaultName()
                ) {
                    viewModel.saveProblemSetName()
                    showNamePopup = false
                    viewModel.shouldShowStudyView = true
                }
                .transition(.opacity)
                .animation(.easeInOut, value: showNamePopup)
            }
        }
    }
    
    private var isGenerateButtonEnabled: Bool {
        let hasInput = !viewModel.selectedImages.isEmpty ||
            (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
        let hasQuestionType = viewModel.totalQuestionCount > 0
        return hasInput && hasQuestionType
    }
    
    private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
        Binding(
            get: { expandedSections.contains(section) },
            set: { isExpanded in
                withAnimation {
                    if isExpanded {
                        expandedSections.insert(section)
                    } else {
                        expandedSections.remove(section)
                    }
                }
            }
        )
    }
}




struct ProblemSetNamePopup: View {
    @Binding var isPresented: Bool
    @Binding var problemSetName: String
    @Binding var isGeneratingQuestions: Bool
    let defaultName: String
    let onSubmit: () -> Void
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 24) {
                Text("Name Your Question Set")
                    .font(.title2)
                    .fontWeight(.bold)
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("Enter a name for your question set:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("Enter name", text: $problemSetName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .font(.body)
                        .frame(height: 44)
                        .placeholder(when: problemSetName.isEmpty) {
                            Text("Default: \(defaultName)")
                                .foregroundColor(.gray)
                        }
                }
                
                Text(isGeneratingQuestions ?
                     "Questions are being generated... Please wait." :
                     "Questions are ready. Please save the name to continue.")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Button(action: {
                    if problemSetName.isEmpty {
                        problemSetName = defaultName
                    }
                    if !isGeneratingQuestions {
                        onSubmit()
                    }
                }) {
                    Text(isGeneratingQuestions ? "Generating Questions..." : "Save Name")
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(isGeneratingQuestions ? Color.gray : Color.blue)
                        .cornerRadius(10)
                }
                .disabled(isGeneratingQuestions)
            }
            .padding(32)
            .background(Color(.systemBackground))
            .cornerRadius(16)
            .shadow(radius: 10)
            .padding(.horizontal, 32)
        }
        // 불필요한 onChange나 onReceive 모디파이어 제거
    }
}

struct SubjectSelectionButton: View {
    let subject: any SubjectType
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.caption)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .padding(.horizontal, 8)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .foregroundColor(isSelected ? subject.color : .gray)
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}



struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // 추가
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSection도 수정
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // 총 문제 수 표시
                HStack {
                    Text("Type")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/10")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    var body: some View {
        Section("Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    // 기본 과목
                    ForEach(DefaultSubject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected subject: \(subject.rawValue)")
                        }
                    }
                    
                    // 사용자 정의 과목
                    ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected custom subject: \(subject.name)")
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// ImagePicker, PhotoPicker, LoadingView 도 추가
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = 10
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

class CustomImagePickerController: UIImagePickerController {
    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .all // 모든 방향 지원
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)?
    
    class CustomImagePickerController: UIImagePickerController {
        override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
            return .portrait // 카메라 UI는 항상 세로 모드로 유지
        }
    }
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = CustomImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        
        if sourceType == .camera {
            picker.cameraDevice = .rear
            picker.cameraCaptureMode = .photo
            picker.allowsEditing = false
            
            // 전체 화면 모드로 설정
            picker.modalPresentationStyle = .fullScreen
            
            // 카메라 UI를 세로 모드로 고정
            picker.navigationController?.navigationBar.isHidden = false
            picker.navigationController?.interactivePopGestureRecognizer?.isEnabled = false
        }
        
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController,
                                 didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                // 이미지는 원래 방향 그대로 유지
                parent.image = image
                parent.onImageSelected?(image)
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

// UIImage extension for orientation fixing
extension UIImage {
    func fixedOrientation() -> UIImage {
        if imageOrientation == .up { return self }
        
        var transform = CGAffineTransform.identity
        
        switch imageOrientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: .pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: .pi/2)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: -.pi/2)
        case .up, .upMirrored:
            break
        @unknown default:
            break
        }
        
        guard let cgImage = self.cgImage else { return self }
        
        let context = CGContext(data: nil,
                              width: Int(size.width),
                              height: Int(size.height),
                              bitsPerComponent: cgImage.bitsPerComponent,
                              bytesPerRow: 0,
                              space: cgImage.colorSpace!,
                              bitmapInfo: cgImage.bitmapInfo.rawValue)!
        
        context.concatenate(transform)
        
        switch imageOrientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
        }
        
        guard let newCGImage = context.makeImage() else { return self }
        return UIImage(cgImage: newCGImage)
    }
}

struct InputMethodCard: View {
    let icon: String
    let title: String
    let isUsed: Bool
    let isDisabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .padding(.vertical, 16)
            .padding(.horizontal, 8)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isUsed ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isUsed ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(isDisabled)
        .opacity(isDisabled ? 0.5 : 1)
    }
}


// ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            VStack(alignment: .leading, spacing: 12) {
                TrueFalseButton(
                    title: "True",
                    isSelected: selectedAnswer?.lowercased() == "true",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "true"
                }
                
                TrueFalseButton(
                    title: "False",
                    isSelected: selectedAnswer?.lowercased() == "false",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "false"
                }
            }
            
            // Answer Result
            if showExplanation {
                HStack {
                    if let isCorrect = isCorrect {
                        HStack {
                            Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect ? .green : .red)
                            
                            Text(isCorrect ? "Correct!" : "Incorrect")
                                .foregroundColor(isCorrect ? .green : .red)
                                .fontWeight(.semibold)
                        }
                        .padding(.vertical, 4)
                        
                        Spacer()
                        
                    }
                }
                
                // Show correct answer if wrong
                if let isCorrect = isCorrect, !isCorrect {
                    Text("Answer: \(question.correctAnswer)")
                        .font(.subheadline)
                        .foregroundColor(.blue)
                        .padding(.vertical, 4)
                }
            }
            
            // Explanation Section
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}

// TrueFalseButton 구조체는 변경 없음
struct TrueFalseButton: View {
    let title: String
    let isSelected: Bool
    let disabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .disabled(disabled)
    }
}


// ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            // 질문 텍스트
            Text(question.question)
                .font(.title3)
                .fontWeight(.bold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 16)
            
            // 선택지
            VStack(spacing: 16) {
                ForEach(question.options, id: \.self) { option in
                    Button(action: { selectedAnswer = option }) {
                        HStack {
                            Text(option)
                                .font(.body)
                                .fontWeight(.medium)
                                .multilineTextAlignment(.leading)
                                .foregroundColor(getTextColor(for: option))
                            Spacer()
                            if selectedAnswer == option && showExplanation {
                                Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                    .foregroundColor(isCorrect == true ? .green : .red)
                                    .imageScale(.large)
                                    .transition(.scale.combined(with: .opacity))
                            }
                        }
                        .padding(.vertical, 16)
                        .padding(.horizontal, 20)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(getBackgroundColor(for: option))
                                .shadow(color: Color.black.opacity(0.05),
                                       radius: 4, x: 0, y: 2)
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    .disabled(showExplanation)
                }
            }
        }
        .padding()
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.15)
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.15)
            }
        }
        // 기본 배경색을 조금 더 명확하게 구분
        return Color(UIColor.systemGray6)
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue
            } else {
                return isCorrect == true ? .green : .red
            }
        }
        return .primary
    }
}


// ./AISnapStudy/Views/Question/Sections/EducationLevelSection.swift


import SwiftUI

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionTypesSection.swift


import SwiftUI

// Question Type Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Type") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "True/False",
                    count: $viewModel.trueFalseCount
                )
                
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionAboutSection.swift

import SwiftUI

import SwiftUI

struct QuestionAboutSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @Binding var isTextInputSelected: Bool

    var body: some View {
        VStack(spacing: 16) { // DisclosureGroup 제거
            // 기존 이미지 옵션 카드
            HStack(spacing: 12) {
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.takePhoto() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.selectFromGallery() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        isTextInputSelected.toggle()
                        viewModel.toggleTextInput()
                    }
                )
            }
            .padding(.horizontal)

            // 🟢 useTextExtraction 토글 추가
            Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                .padding(.horizontal)
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("📱 useTextExtraction changed to: \(newValue)")
                }

            // 텍스트 입력 필드
            if viewModel.isTextInputActive {
                TextField("Enter your question here...", text: $viewModel.questionText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }

            // 선택한 이미지 표시
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                            SelectedImageCell(
                                image: viewModel.selectedImages[index],
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .listRowSpacing(0)
    }
}


// ./AISnapStudy/Views/Question/Sections/LearningSubjectSection.swift

import SwiftUI

struct LearningSubjectSection: View {
    @StateObject private var subjectManager = SubjectManager.shared
    @Binding var selectedSubject: SubjectType
    
    var visibleSubjects: [SubjectType] {
        // 기본 과목 중 삭제되지 않은 것들만 필터링
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        // 활성화된 커스텀 과목만 필터링
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        📚 LearningSubjectSection - Visible Subjects:
        • Total Subjects: \(subjects.count)
        • Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        • Active Custom Subjects: \(customSubjects.map { $0.displayName })
        • Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
    
    var body: some View {
        LazyVGrid(columns: [
            GridItem(.flexible()),
            GridItem(.flexible()),
            GridItem(.flexible())
        ], spacing: 12) {
            ForEach(visibleSubjects, id: \.id) { subject in
                SubjectSelectionButton(
                    subject: subject,
                    isSelected: selectedSubject.id == subject.id
                ) {
                    withAnimation(.spring()) {
                        selectedSubject = subject
                        print("📝 Selected subject: \(subject.displayName)")
                    }
                }
            }
        }
        .padding(.vertical, 8)
        .onAppear {
            // 현재 선택된 과목이 삭제되었거나 비활성화된 경우 기본 과목으로 변경
            if let defaultSubject = selectedSubject as? DefaultSubject,
               subjectManager.isDeleted(defaultSubject) {
                // 첫 번째로 사용 가능한 과목을 선택
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            } else if let customSubject = selectedSubject as? CustomSubject,
                      !subjectManager.customSubjects.contains(where: { $0.id == customSubject.id && $0.isActive }) {
                // 첫 번째로 사용 가능한 과목을 선택
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Components/AddSubjectView.swift



import SwiftUI


// Helper Views
struct IconSelectionButton: View {
    let icon: String
    let isSelected: Bool
    let color: Color
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .frame(width: 50, height: 50)
                .foregroundColor(isSelected ? .white : color)
                .background(
                    Circle()
                        .fill(isSelected ? color : Color.gray.opacity(0.1))
                )
                .overlay(
                    Circle()
                        .stroke(isSelected ? color : Color.clear, lineWidth: 2)
                )
        }
    }
}

struct ColorSelectionButton: View {
    let color: Color
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Circle()
                .fill(color)
                .frame(width: 50, height: 50)
                .overlay(
                    Circle()
                        .stroke(Color.white, lineWidth: isSelected ? 3 : 0)
                )
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        }
    }
}



// ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // 상단 헤더
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // 태그 목록 (작고 간결하게)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // 최대 3개의 태그만 표시
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // 정보 그리드
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
            }
            .font(.footnote)
            
            // 설명 (더 짧게)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



// ./AISnapStudy/Views/Components/SpeedUpSection.swift


import SwiftUI

struct SpeedUpSection: View {
    @Binding var useTextExtraction: Bool
    @State private var isExpanded: Bool = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                Text("Automatically extracts text from images to generate questions faster. Recommended when images contain mostly text.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.vertical, 8)
            },
            label: {
                HStack {
                    Image(systemName: "bolt.fill")
                        .foregroundColor(.yellow)
                    Text("Speed Up")
                        .font(.headline)
                    Spacer()
                    Toggle("", isOn: $useTextExtraction)
                        .labelsHidden()
                }
            }
        )
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionsView.swift

import SwiftUI

struct SavedQuestionsView: View {
    let questions: [Question]
    let homeViewModel: HomeViewModel
    @State private var showStudyView = false
    
    var body: some View {
        List(questions) { question in
            SavedQuestionCard(question: question)
                .onTapGesture {
                    let problemSet = ProblemSet(
                        id: UUID().uuidString,
                        subject: question.subject,
                        subjectType: "default",  // 저장된 문제는 항상 기본 과목으로 처리
                        subjectId: question.subject.rawValue,
                        subjectName: question.subject.displayName,
                        questions: [question],
                        createdAt: Date(),
                        educationLevel: .elementary,
                        name: "Saved Question"
                    )
                    homeViewModel.setSelectedProblemSet(problemSet)
                    showStudyView = true
                }
        }
        .navigationTitle("Saved Questions")
        .background(
            NavigationLink(
                isActive: $showStudyView,
                destination: {
                    if let studyViewModel = homeViewModel.studyViewModel {
                        StudyView(
                            questions: [questions[0]],
                            studyViewModel: studyViewModel,
                            selectedTab: .constant(1)
                        )
                    }
                },
                label: { EmptyView() }
            )
        )
    }
}


// ./AISnapStudy/Views/Components/DraggableSubjectGrid.swift

import SwiftUI

struct DraggableSubjectGrid: View {
    @ObservedObject var subjectManager = SubjectManager.shared
    @State private var subjects: [SubjectType]
    @State private var draggingItem: SubjectType?
    @GestureState private var dragLocation: CGPoint = .zero
    
    // Grid layout settings
    let columns = [
        GridItem(.adaptive(minimum: 120), spacing: 12)
    ]
    
    init(subjects: [SubjectType]) {
        _subjects = State(initialValue: subjects)
    }
    
    var body: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(subjects, id: \.id) { subject in
                SubjectButton(subject: subject)
                    .overlay(draggingItem?.id == subject.id ? Color.blue.opacity(0.3) : Color.clear)
                    .onLongPressGesture(minimumDuration: 0.5) {
                        withAnimation(.spring()) {
                            self.draggingItem = subject
                        }
                    }
                    .gesture(
                        DragGesture()
                            .onChanged { value in
                                guard let draggingItem = draggingItem else { return }
                                let currentIndex = subjects.firstIndex { $0.id == draggingItem.id }
                                let targetIndex = computeTargetIndex(location: value.location)
                                
                                if let currentIndex = currentIndex,
                                   let targetIndex = targetIndex,
                                   currentIndex != targetIndex {
                                    withAnimation(.spring()) {
                                        subjects.move(fromOffsets: IndexSet(integer: currentIndex),
                                                    toOffset: targetIndex)
                                    }
                                }
                            }
                            .onEnded { _ in
                                self.draggingItem = nil
                                // Save new order to UserDefaults
                                saveSubjectOrder()
                            }
                    )
            }
        }
        .padding()
    }
    
    private func computeTargetIndex(location: CGPoint) -> Int? {
        // Convert point to index logic
        // ...
        return nil
    }
    
    private func saveSubjectOrder() {
        let subjectIds = subjects.map { $0.id }
        UserDefaults.standard.set(subjectIds, forKey: "subjectOrder")
    }
}

struct SubjectButton: View {
    let subject: SubjectType
    @State private var isPressed = false
    
    var body: some View {
        Button(action: {}) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.subheadline)
                    .lineLimit(1)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(subject.color.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(subject.color.opacity(0.2), lineWidth: 1)
                    )
            )
        }
        .scaleEffect(isPressed ? 1.05 : 1.0)
        .animation(.spring(), value: isPressed)
        .buttonStyle(PlainButtonStyle())
    }
}


// ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/LanguageButton.swift

import SwiftUI

// Add new supporting view for Language Button
struct LanguageButton: View {
    let language: Language
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 6) {
                Text(emoji(for: language))
                    .font(.title2)
                Text(displayName(for: language))
                    .font(.caption)
                    .foregroundColor(isSelected ? .white : .primary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.blue : Color.gray.opacity(0.1))
            )
        }
    }
    
    private func emoji(for language: Language) -> String {
        switch language {
        case .auto: return "🌐"
        case .english: return "🇺🇸"
        case .korean: return "🇰🇷"
        case .japanese: return "🇯🇵"
        case .chinese: return "🇨🇳"
        case .spanish: return "🇪🇸"
        case .french: return "🇫🇷"
        case .german: return "🇩🇪"
        case .russian: return "🇷🇺"
        case .italian: return "🇮🇹"
        }
    }
    
    private func displayName(for language: Language) -> String {
        switch language {
        case .auto: return "Auto"
        default: return language.rawValue
        }
    }
}



struct LanguageSection: View {
    @Binding var selectedLanguage: Language
    @State private var isExpanded: Bool = false
    @State private var showLanguageMenu = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Choose the language in which you want the questions to be generated. The generated questions will appear in your selected language regardless of the input language.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                        
                    Text("Current: \(selectedLanguage.displayName) \(selectedLanguage.emoji)")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            },
            label: {
                HStack {
                    HStack {
                        Image(systemName: "globe")
                            .foregroundColor(.blue)
                        Text("Language")
                            .font(.headline)
                    }
                    
                    Spacer()
                    
                    // 별도의 버튼으로 분리
                    Button(action: {
                        showLanguageMenu = true
                    }) {
                        HStack(spacing: 4) {
                            Text(selectedLanguage.emoji)
                            Image(systemName: "chevron.down")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
            }
        )
        .sheet(isPresented: $showLanguageMenu) {
            LanguageSelectionView(selectedLanguage: $selectedLanguage)
        }
    }
}

// LanguageSelectionView는 더 깔끔한 UI로 업데이트
struct LanguageSelectionView: View {
    @Binding var selectedLanguage: Language
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            List {
                ForEach(Language.allCases) { language in
                    LanguageRow(
                        language: language,
                        isSelected: language == selectedLanguage,
                        onSelect: {
                            selectedLanguage = language
                            UserDefaults.standard.set(language.rawValue, forKey: "selectedLanguage")
                            dismiss()
                        }
                    )
                }
            }
            .navigationTitle("Select Language")
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
        }
        .presentationDetents([.medium, .large])
    }
}

// 별도의 LanguageRow 컴포넌트
struct LanguageRow: View {
    let language: Language
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack(spacing: 12) {
                Text(language.emoji)
                    .font(.title3)
                
                VStack(alignment: .leading) {
                    Text(language.displayName)
                        .foregroundColor(.primary)
                    Text(language.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}


// Language.swift (새로운 파일)
enum Language: String, CaseIterable, Identifiable {
    case auto = "AUTO"
    case english = "english"
    case korean = "korean"
    case japanese = "japanese"
    case chinese = "chinese"
    case spanish = "spanish"
    case french = "french"
    case german = "german"
    case russian = "russian"
    case italian = "italian"
    
    var id: String { self.rawValue }
    
    // OpenAI API에서 사용할 언어 코드
    var languageCode: String {
        switch self {
        case .auto: return "auto"
        case .english: return "en"
        case .korean: return "ko"
        case .japanese: return "ja"
        case .chinese: return "zh"
        case .spanish: return "es"
        case .french: return "fr"
        case .german: return "de"
        case .russian: return "ru"
        case .italian: return "it"
        }
    }
}

// Update Language enum to include display names and emojis
extension Language {
    var displayName: String {
        switch self {
        case .auto: return "Automatic"
        case .english: return "English"
        case .korean: return "한국어"
        case .japanese: return "日本語"
        case .chinese: return "中文"
        case .spanish: return "Español"
        case .french: return "Français"
        case .german: return "Deutsch"
        case .russian: return "Русский"
        case .italian: return "Italiano"
        }
    }
    
    var emoji: String {
        switch self {
        case .auto: return "🌐"
        case .english: return "🇺🇸"
        case .korean: return "🇰🇷"
        case .japanese: return "🇯🇵"
        case .chinese: return "🇨🇳"
        case .spanish: return "🇪🇸"
        case .french: return "🇫🇷"
        case .german: return "🇩🇪"
        case .russian: return "🇷🇺"
        case .italian: return "🇮🇹"
        }
    }
}

extension Language {
    var description: String {
        switch self {
        case .auto:
            return "Detect language automatically"
        case .english:
            return "English"
        case .korean:
            return "한국어 (Korean)"
        case .japanese:
            return "日本語 (Japanese)"
        case .chinese:
            return "中文 (Chinese)"
        case .spanish:
            return "Español (Spanish)"
        case .french:
            return "Français (French)"
        case .german:
            return "Deutsch (German)"
        case .russian:
            return "Русский (Russian)"
        case .italian:
            return "Italiano (Italian)"
        }
    }
}


// ./AISnapStudy/Views/Components/SubjectManagementView.swift

import SwiftUI

struct SubjectManagementView: View {
   @StateObject private var subjectManager = SubjectManager.shared
   @State private var showingAddSubject = false
   @State private var showingDeleteAlert = false
   @State private var showingEditAlert = false
   @State private var showingRestoreAlert = false
   @State private var subjectToDelete: (any SubjectType)?
   @State private var newName = ""
   @State private var selectedSubject: (any SubjectType)?
   
   // 모든 활성 과목을 하나의 배열로 결합
   private var allSubjects: [SubjectType] {
       var subjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) } as [SubjectType]
       subjects.append(contentsOf: subjectManager.customSubjects)
       return subjects
   }
   
   var body: some View {
       List {
           // Combined Subjects Section
           Section(header: Text("SUBJECTS")) {
               ForEach(allSubjects, id: \.id) { subject in
                   if let defaultSubject = subject as? DefaultSubject {
                       DefaultSubjectRow(
                        subject: defaultSubject,
                        subjectManager: subjectManager,
                        onEdit: { subject in
                            selectedSubject = subject
                            newName = subjectManager.getDisplayName(for: subject)
                            showingEditAlert = true
                        },
                        onDelete: {
                            subjectToDelete = subject
                            showingDeleteAlert = true
                        }
                       )
                   } else if let customSubject = subject as? CustomSubject {
                       CustomSubjectRow(
                           subject: customSubject,
                           subjectManager: subjectManager,
                           onEdit: { subject in
                               selectedSubject = subject
                               newName = subject.name
                               showingEditAlert = true
                           },
                           onDelete: { subject in
                               subjectToDelete = subject
                               showingDeleteAlert = true
                           }
                       )
                   }
               }
               
               Button {
                   showingAddSubject = true
               } label: {
                   Label("Add Subject", systemImage: "plus")
               }
           }
           
           // Recently Deleted Section moved to bottom
           if !subjectManager.hiddenDefaultSubjects.isEmpty {
               Section(header: Text("RECENTLY DELETED")) {
                   Button(action: {
                       showingRestoreAlert = true
                   }) {
                       Label("Restore All Deleted Subjects", systemImage: "arrow.counterclockwise")
                           .foregroundColor(.blue)
                   }
               }
           }
       }
       .navigationTitle("Manage Subjects")
       .sheet(isPresented: $showingAddSubject) {
           AddSubjectView()
       }
       .alert("Rename Subject", isPresented: $showingEditAlert) {
           TextField("Subject Name", text: $newName)
           Button("Cancel", role: .cancel) { }
           Button("Save") {
               if let defaultSubject = selectedSubject as? DefaultSubject {
                   subjectManager.updateDefaultSubjectName(defaultSubject, newName: newName)
               } else if let customSubject = selectedSubject as? CustomSubject {  // 변경
                              subjectManager.updateSubject(customSubject, newName: newName)
               }
           }
           .disabled(newName.isEmpty)
       }
       .alert("Delete Subject", isPresented: $showingDeleteAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Delete", role: .destructive) {
               if let subject = subjectToDelete as? DefaultSubject {
                   subjectManager.toggleDefaultSubject(subject)
               } else if let subject = subjectToDelete as? CustomSubject {  // 변경
                   subjectManager.deleteSubject(subject)
               }
           }
       } message: {
           Text("Are you sure you want to delete this subject? You can restore it later from the Recently Deleted section.")
       }
       .alert("Restore Subjects", isPresented: $showingRestoreAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Restore All") {
               DefaultSubject.allCases.forEach { subject in
                   if subjectManager.isDeleted(subject) {
                       subjectManager.restoreDeletedSubject(subject)
                   }
               }
           }
       } message: {
           Text("Do you want to restore all deleted subjects?")
       }
       .onAppear {
           print("📱 SubjectManagementView appeared")
           print("📚 Active subjects: \(allSubjects.map { $0.displayName })")
           print("🗑️ Hidden subjects: \(subjectManager.hiddenDefaultSubjects)")
       }
   }
}

    
// 복원 섹션을 위한 별도의 뷰
struct RestoreSection: View {
    @ObservedObject var subjectManager: SubjectManager
    @Binding var showingRestoreAlert: Bool
    
    var body: some View {
        if !subjectManager.hiddenDefaultSubjects.isEmpty {
            Section(header: Text("Recently Deleted Subjects")) {
                Button(action: {
                    showingRestoreAlert = true
                }) {
                    Label("Restore All Deleted Subjects", systemImage: "arrow.counterclockwise")
                        .foregroundColor(.blue)
                }
            }
        }
    }
}

    // 기본 과목 섹션을 위한 별도의 뷰
struct DefaultSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: (DefaultSubject) -> Void
    
    var body: some View {
        Section(header: Text("Default Subjects")) {
            ForEach(DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }, id: \.id) { subject in
                DefaultSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { _ in onEdit(subject) },  // 수정된 부분
                    onDelete: { onDelete(subject) }     // 수정된 부분
                )
            }
        }
    }
}

// 커스텀 과목 섹션을 위한 별도의 뷰
struct CustomSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    @Binding var showingAddSubject: Bool
    let onEdit: (CustomSubject) -> Void  // 변경
    let onDelete: (CustomSubject) -> Void  // 변경
    
    var body: some View {
        Section(header: Text("Custom Subjects")) {
            ForEach(subjectManager.customSubjects) { subject in
                CustomSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { customSubject in  // 매개변수 이름 변경
                        onEdit(customSubject)
                    },
                    onDelete: { customSubject in  // 매개변수 이름 변경
                        onDelete(customSubject)
                    }
                )
            }
            
            Button {
                showingAddSubject = true
            } label: {
                Label("Add Subject", systemImage: "plus")
            }
        }
    }
}

struct DefaultSubjectRow: View {
    let subject: DefaultSubject
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subjectManager.getDisplayName(for: subject))
            Spacer()
            
            Button(action: {
                onDelete()
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button(role: .destructive) {
                onDelete()
            } label: {
                Label("Delete", systemImage: "trash")
            }
            
            if subjectManager.modifiedDefaultSubjects[subject.id] != nil {
                Button {
                    subjectManager.resetDefaultSubjectName(subject)
                } label: {
                    Label("Reset Name", systemImage: "arrow.counterclockwise")
                }
            }
        }
    }
}

// 사용자 정의 과목 행을 위한 컴포넌트
struct CustomSubjectRow: View {
    let subject: CustomSubject  // 변경
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (CustomSubject) -> Void  // 변경
    let onDelete: (CustomSubject) -> Void  // 변경
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subject.displayName)
            Spacer()
            
            // 삭제 버튼 추가
            Button(action: {
                onDelete(subject)
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
            
            if !subject.isActive {
                Image(systemName: "eye.slash")
                    .foregroundColor(.gray)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button {
                subjectManager.toggleSubjectActive(subject)
            } label: {
                if subject.isActive {
                    Label("Hide", systemImage: "eye.slash")
                } else {
                    Label("Show", systemImage: "eye")
                }
            }
            
            Button(role: .destructive) {
                onDelete(subject)
            } label: {
                Label("Delete", systemImage: "trash")
            }
        }
    }
}



struct AddSubjectView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var subjectName = ""
    @State private var selectedColor = Color.blue
    @State private var selectedIcon = "book.fill"
    
    let availableIcons = [
        "book.fill", "pencil", "function", "globe",
        "atom", "flask.fill", "keyboard", "music.note"
    ]
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Subject Details")) {
                    TextField("Subject Name", text: $subjectName)
                    
                    ColorPicker("Choose Color", selection: $selectedColor)
                    
                    Picker("Choose Icon", selection: $selectedIcon) {
                        ForEach(availableIcons, id: \.self) { icon in
                            Label(icon, systemImage: icon)
                                .tag(icon)
                        }
                    }
                    .pickerStyle(.menu)
                }
            }
            .navigationTitle("Add Subject")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        subjectManager.addSubject(
                            name: subjectName,
                            icon: selectedIcon
                        )
                        dismiss()
                    }
                    .disabled(subjectName.isEmpty)
                }
            }
        }
    }
}



// ./AISnapStudy/Views/Components/ReviewProblemSetCard.swift

import SwiftUI

struct ReviewProblemSetCard: View {
    let subject: SubjectType
    let problemSet: ProblemSet
    let onDelete: () -> Void
    let onRename: (String) -> Void
    
    @State private var isShowingRenameAlert = false
    @State private var newName = ""
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                    .font(.headline)
                    .foregroundColor(.primary)
                Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
            if problemSet.isFavorite {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
            }
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(Color(UIColor.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        )
        .padding(.vertical, 4)
        .contextMenu {
            // Rename option
            Button(action: {
                newName = problemSet.name
                isShowingRenameAlert = true
            }) {
                Label("Rename", systemImage: "pencil")
            }
            
            // Delete option
            Button(role: .destructive, action: onDelete) {
                Label("Delete", systemImage: "trash")
            }
        }
        .alert("Rename Problem Set", isPresented: $isShowingRenameAlert) {
            TextField("New name", text: $newName)
            Button("Cancel", role: .cancel) { }
            Button("Save") {
                if !newName.isEmpty {
                    onRename(newName)
                }
            }
        } message: {
            Text("Enter a new name for this problem set")
        }
    }
}


// ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search Review...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


// ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


// ./AISnapStudy/Views/Components/InputMethodCard.swift


import SwiftUI




// ./AISnapStudy/Views/Components/ImageSelectionSection.swift



import SwiftUI
import PhotosUI
import UIKit

struct ImageSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @FocusState private var isTextFieldFocused: Bool
    @State private var keyboardHeight: CGFloat = 0
  
    var body: some View {
        VStack(spacing: 16) {
            // Quick Text Mode Toggle
            Group {
                VStack(alignment: .leading, spacing: 8) {
                    Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                        .padding()
                        .onAppear {
                            print("🔄 Toggle initialized with: \(viewModel.useTextExtraction)")
                        }

                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Quick Text Mode")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            if viewModel.useTextExtraction {
                                Image(systemName: "bolt.fill")
                                    .foregroundColor(.yellow)
                                    .imageScale(.small)
                            }
                        }
                        Text("Extracts text for faster processing")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .toggleStyle(SwitchToggleStyle(tint: .blue))
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("📱 Quick Text Mode changed to: \(newValue)")
                }
            }
            .padding(.horizontal)

            Divider()

            // Input Type Selection Buttons
            HStack(spacing: 12) {
                // Camera Button
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.takePhoto()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Gallery Button
                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.selectFromGallery()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Text Input Button
                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        if viewModel.canUseTextInput {
                            viewModel.onImageOptionSelected()
                            viewModel.toggleTextInput()
                            if viewModel.isTextInputActive {
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isTextFieldFocused = true
                                }
                            } else {
                                isTextFieldFocused = false
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal)

            // Text Input Field
            if viewModel.isTextInputActive {
                VStack(spacing: 12) {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .focused($isTextFieldFocused)
                }
                .padding(.horizontal)
            }

            // Selected Images Display
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(Array(zip(viewModel.selectedImages.indices, viewModel.selectedImages)), id: \.0) { index, image in
                            let imageId = viewModel.getImageId(for: image)
                            SelectedImageCell(
                                image: image,
                                isLoading: viewModel.isLoadingTexts[imageId] ?? false,
                                extractionStatus: viewModel.extractionStatus[imageId],
                                extractedText: viewModel.extractedTexts[imageId],
                                showExtractedText: viewModel.useTextExtraction,
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.horizontal)
                }
            }

            // Generate Button for Selected Content
            if !viewModel.selectedImages.isEmpty || !viewModel.questionText.isEmpty {
                Button {
                    Task {
                        await viewModel.sendAllImages()
                    }
                } label: {
                    HStack {
                        Spacer()
                        Image(systemName: "sparkles")
                        Text("Generate Questions")
                            .fontWeight(.semibold)
                        Spacer()
                    }
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(viewModel.isLoading ? Color.gray : Color.green)
                    )
                    .animation(.easeInOut, value: viewModel.isLoading)
                }
                .buttonStyle(BorderlessButtonStyle())
                .disabled(viewModel.isLoading)
                .padding(.horizontal)
            }
        }
    }
}



// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
   let icon: String
   let isUsed: Bool
   let isDisabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 12) {
               Image(systemName: icon)
                   .font(.system(size: 30))
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 20)
           .foregroundColor(foregroundColor)
           .background(
               RoundedRectangle(cornerRadius: 12)
                   .fill(backgroundColor)
           )
           .overlay(
               RoundedRectangle(cornerRadius: 12)
                   .stroke(strokeColor, lineWidth: 1)
           )
       }
       .disabled(isDisabled)
       .buttonStyle(PlainButtonStyle())
   }
   
   private var foregroundColor: Color {
       if isDisabled {
           return .gray.opacity(0.5)
       }
       return isUsed ? .green : .gray
   }
   
   private var backgroundColor: Color {
       if isDisabled {
           return Color.gray.opacity(0.1)
       }
       return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
   }
   
   private var strokeColor: Color {
       if isDisabled {
           return .clear
       }
       return isUsed ? Color.green.opacity(0.2) : .clear
   }
}

struct SelectedImageCell: View {
    let image: UIImage
    let isLoading: Bool
    let extractionStatus: Bool?
    let extractedText: String?
    let showExtractedText: Bool
    let onDelete: () -> Void
    
    init(
        image: UIImage,
        isLoading: Bool = false,
        extractionStatus: Bool? = nil,
        extractedText: String? = nil,
        showExtractedText: Bool = false,
        onDelete: @escaping () -> Void
    ) {
        self.image = image
        self.isLoading = isLoading
        self.extractionStatus = extractionStatus
        self.extractedText = extractedText
        self.showExtractedText = showExtractedText
        self.onDelete = onDelete
    }
    
    var body: some View {
        ZStack(alignment: .topTrailing) {
            VStack(alignment: .leading, spacing: 4) {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .frame(width: 100, height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                    )
                
                if showExtractedText {
                    if isLoading {
                        HStack(spacing: 4) {
                            ProgressView()
                                .scaleEffect(0.7)
                            Text("Extracting text...")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    } else if let status = extractionStatus {
                        HStack(spacing: 4) {
                            Image(systemName: status ? "doc.text.fill" : "exclamationmark.triangle.fill")
                                .foregroundColor(status ? .green : .orange)
                                .imageScale(.small)
                            Text(status ? "Text extracted" : "Extraction failed")
                                .font(.caption2)
                                .foregroundColor(status ? .green : .orange)
                        }
                    }
                }
            }
            
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 22))
                    .foregroundColor(.white)
                    .background(
                        Circle()
                            .fill(Color.black.opacity(0.5))
                            .frame(width: 24, height: 24)
                    )
            }
            .offset(x: 6, y: -6)
        }
    }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


// ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


// ./AISnapStudy/Views/Components/ReviewCard.swift



import SwiftUI

struct ReviewCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .foregroundColor(question.subject.color)
                    .cornerRadius(8)
                
                Spacer()
            }
            
            // Question Type
            Text(question.type.rawValue.replacingOccurrences(of: "_", with: " ").capitalized)
                .font(.caption)
                .foregroundColor(.secondary)
            
            // Question Text
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .padding(.vertical, 4)
            
            // Footer
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Image(systemName: "arrow.right.circle.fill")
                    .foregroundColor(.blue)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2)
        )
    }
}

#Preview {
    SavedQuestionCard(question: Question(
        id: UUID().uuidString,
        type: .multipleChoice,
        subject: .math,
        question: "Sample Question",
        options: ["A", "B", "C", "D"],
        correctAnswer: "A",
        explanation: "Sample explanation",
        hint: "Sample hint",
        isSaved: true,
        createdAt: Date()
    ))
    .padding()
}


// ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


// ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // 각 버튼에 대한 별도의 액션 정의
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // 중요: 버튼 스타일 분리
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // 중요: 버튼 스타일 분리
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @StateObject private var studyViewModel: StudyViewModel
    @StateObject private var reviewViewModel: ReviewViewModel  // 추가
    @State private var selectedTab = 0
    @StateObject private var statViewModel: StatViewModel
    
    
    init() {
        let homeVM = HomeViewModel.shared
        
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        
        // StudyViewModel 초기화 시점 변경
        let studyVM = StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        )
        self._studyViewModel = StateObject(wrappedValue: studyVM)
        
        let statVM = StatViewModel(
            context: CoreDataService.shared.viewContext,
            homeViewModel: homeVM,
            studyViewModel: studyVM
        )
        // ReviewViewModel 초기화 추가
        let reviewVM = ReviewViewModel(homeViewModel: homeVM)
        self._reviewViewModel = StateObject(wrappedValue: reviewVM)
        
        // StatViewModel도 studyViewModel 참조 추가
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
             context: CoreDataService.shared.viewContext,
             homeViewModel: homeVM,  // homeViewModel 전달
             studyViewModel: studyVM // studyViewModel 전달
         ))
        
        
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
        
        // homeViewModel에 studyViewModel 설정
        homeVM.setStudyViewModel(studyVM)
        
        // StatViewModel을 StudyViewModel에 연결
        studyVM.setStatViewModel(statVM)
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            Group {
                if studyViewModel.isGeneratingQuestions {  // 문제 생성 중일 때
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                } else if let problemSet = homeViewModel.selectedProblemSet {
                    StudyView(
                        questions: problemSet.questions,
                        studyViewModel: studyViewModel,
                        selectedTab: $selectedTab
                    )
                } else {
                    Text("No Problem Set Selected")
                }
            }
            .tabItem {
                Label("Study", systemImage: "book.fill")
            }
            .tag(1)
            
            ReviewView(
                viewModel: reviewViewModel,
                selectedTab: $selectedTab  // selectedTab 바인딩 전달
            )
            .tabItem {
                Label("Review", systemImage: "clock.fill")
            }
            .tag(2)
            
            StatView(
                viewModel: statViewModel,
                selectedTab: $selectedTab,
                correctAnswers: studyViewModel.correctAnswers,
                totalQuestions: studyViewModel.totalQuestions
            )
            .tabItem {
                Label("Stats", systemImage: "chart.bar.fill")
            }
            .tag(3)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { newProblemSet in
            if let problemSet = newProblemSet,
               // Review에서 선택된 경우에만 탭 전환
               selectedTab == 2 {  // 2는 Review 탭
                studyViewModel.loadQuestions(problemSet.questions)
                selectedTab = 1  // Study 탭으로 전환
            }
        }
         .environmentObject(homeViewModel)
    }
}


// ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData


struct StatView: View {
    @ObservedObject var viewModel: StatViewModel
    @Binding var selectedTab: Int
    let correctAnswers: Int
    let totalQuestions: Int
    @EnvironmentObject private var homeViewModel: HomeViewModel
    
    // 초기화 함수의 매개변수 순서 수정
    init(
        viewModel: StatViewModel,
        selectedTab: Binding<Int>,
        correctAnswers: Int,
        totalQuestions: Int
    ) {
        self.viewModel = viewModel
        self._selectedTab = selectedTab
        self.correctAnswers = correctAnswers
        self.totalQuestions = totalQuestions
    }
    
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                Text("학습 통계")
                    .font(.title)
                    .padding(.top)
                
                // 현재 스트릭
                HStack {
                    VStack(alignment: .leading) {
                        Text("현재 스트릭")
                            .font(.headline)
                        Text("\(viewModel.streak)일")
                            .font(.title)
                            .foregroundColor(.blue)
                    }
                    Spacer()
                    Image(systemName: "flame.fill")
                        .font(.system(size: 40))
                        .foregroundColor(.orange)
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
                
                // 통계 그리드
                LazyVGrid(columns: [
                    GridItem(.flexible()),
                    GridItem(.flexible())
                ], spacing: 20) {
                    StatCard(
                        title: "이번 세트 점수",
                        value: "\(correctAnswers * 10)점",  // correctAnswers 직접 사용
                        icon: "star.fill",
                        color: .yellow
                    )
                    
                    StatCard(
                        title: "정답률",
                        value: String(format: "%.1f%%",
                            Double(correctAnswers) / Double(totalQuestions) * 100),
                        icon: "percent",
                        color: .blue
                    )
                    
                    StatCard(
                        title: "완료한 문제",
                        value: "\(totalQuestions)개",
                        icon: "checkmark.circle.fill",
                        color: .green
                    )
                    
                    StatCard(
                        title: "정답 수",
                        value: "\(correctAnswers)개",
                        icon: "target",
                        color: .red
                    )
                }
                .padding()
                
                Spacer()  // 나머지 공간을 채움
                
                // 다시 풀기 버튼을 맨 아래에 배치
                Button(action: {
                    viewModel.resetProgress()
                    viewModel.logCurrentQuestionState()
                    withAnimation {
                        selectedTab = 1
                    }
                }) {
                    Text("다시 풀기")
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.blue)
                        .cornerRadius(10)
                }
                .padding(.horizontal)
                .padding(.bottom, 20)  // 하단 여백 추가
            }
        }
    }
}


// ./AISnapStudy/Views/Main/HomeView.swift




import SwiftUI
import Combine
import CoreData

struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Environment(\.managedObjectContext) private var context
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var selectedSubject: DefaultSubject = .math
    @StateObject private var subjectManager = SubjectManager.shared
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Create New Questions Button
                    MainActionButton(
                        title: "Create New Questions",
                        icon: "plus.circle.fill"
                    ) {
                        selectedSubject = .math
                        showQuestionSettings = true
                    }
                    
                    // Review Questions Button
                    MainActionButton(
                        title: "Review Questions",
                        icon: "book.fill"
                    ) {
                        if let problemSet = viewModel.selectedProblemSet {
                            viewModel.setSelectedProblemSet(problemSet)
                            selectedTab = 1
                        }
                    }
                    .disabled(viewModel.selectedProblemSet == nil)
                    .opacity(viewModel.selectedProblemSet == nil ? 0.5 : 1)
                    
                    // 사용자 정의 과목 리스트 (옵션)
                    if !subjectManager.customSubjects.isEmpty {
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Custom Subjects")
                                .font(.headline)
                                .padding(.horizontal)
                            
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: 12) {
                                    ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                                        CustomSubjectButton(subject: subject) {
                                            showQuestionSettings = true
                                        }
                                    }
                                }
                                .padding(.horizontal)
                            }
                        }
                    }
                }
                .padding(.vertical, 32)
            }
            .navigationTitle("Home")
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab
            )
        }
    }
}

struct CustomSubjectButton: View {
    let subject: CustomSubject  // SubjectManager.CustomSubject에서 CustomSubject로 변경
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                    .foregroundColor(subject.color)
                Text(subject.displayName)
                    .font(.caption)
                    .foregroundColor(.primary)
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(10)
        }
    }
}

// SubjectType 확장
extension DefaultSubject {
    static var defaultSubject: DefaultSubject {
        return .math
    }
    
    public var displayName: String {
        SubjectManager.shared.modifiedDefaultSubjects[self.id] ?? defaultDisplayName
    }
    
    // 원래의 displayName을 defaultDisplayName으로 이동
    private var defaultDisplayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
}


// ./AISnapStudy/Views/Main/ReviewView.swift

import SwiftUI



struct ReviewView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @ObservedObject var viewModel: ReviewViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var showSubjectManagement = false
    @State private var searchText = ""
    @State private var selectedSubject: SubjectType?
    @Binding var selectedTab: Int  // 새로 추가
   
    // 초기화 구문 수정
    public init(viewModel: ReviewViewModel, selectedTab: Binding<Int>) {
        self.viewModel = viewModel
        self._selectedTab = selectedTab
    }
    
    private var visibleSubjects: [SubjectType] {
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        📚 ReviewView - Visible Subjects:
        • Total Subjects: \(subjects.count)
        • Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        • Active Custom Subjects: \(customSubjects.map { $0.displayName })
        • Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
   
   private var allSubjects: [SubjectType] {
       var subjects: [SubjectType] = []
       
       let activeDefaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
       subjects.append(contentsOf: activeDefaultSubjects)
       
       let activeCustomSubjects = subjectManager.customSubjects.filter { $0.isActive }
       subjects.append(contentsOf: activeCustomSubjects)
       
       print("📚 Review - Active Default Subjects: \(activeDefaultSubjects.map { $0.displayName })")
       print("📚 Review - Active Custom Subjects: \(activeCustomSubjects.map { $0.displayName })")
       print("🔒 Review - Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)")
       
       return subjects
   }
   
    var body: some View {
        NavigationView {
            VStack(spacing: 16) {
                ScrollView {
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 16) {
                        // allSubjects를 사용하여 모든 과목 표시
                        ForEach(visibleSubjects, id: \.id) { subject in
                            NavigationLink(
                                destination: ProblemSetsListView(
                                    subject: subject,
                                    problemSets: filterProblemSets(subject: subject),
                                    selectedTab: $selectedTab  // selectedTab 전달
                                )
                            ) {
                                SubjectCardView(
                                    subject: subject,
                                    problemSetCount: filterProblemSets(subject: subject).count
                                )
                            }
                            .onAppear {
                                print("""
                            📱 Subject Card Appeared:
                            • Subject: \(subject.displayName)
                            """)
                            }
                        }
                    }
                    .padding()
                }
                .navigationTitle("Review")
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: {
                            showSubjectManagement = true
                        }) {
                            Image(systemName: "slider.horizontal.3")
                                .foregroundColor(.blue)
                        }
                    }
                }
                .sheet(isPresented: $showSubjectManagement) {
                    NavigationView {
                        SubjectManagementView()
                            .navigationTitle("Manage Subjects")
                            .navigationBarItems(
                                trailing: Button("Done") {
                                    showSubjectManagement = false
                                }
                            )
                    }
                }
                
            }}
        .onAppear {
            print("📱 ReviewView appeared")
            print("📚 Available subjects: \(visibleSubjects.map { $0.displayName })")
        }
    }
    // 필터링 함수 수정
    private func filterProblemSets(subject: SubjectType) -> [ProblemSet] {
        return homeViewModel.problemSets.filter { problemSet in
            if let defaultSubject = subject as? DefaultSubject {
                return problemSet.subjectType == "default" &&
                       problemSet.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return problemSet.subjectType == "custom" &&
                       problemSet.subjectId == customSubject.id
            }
            return false
        }
    }
}

struct SubjectCardView: View {
   let subject: SubjectType
   let problemSetCount: Int
   
   var body: some View {
       VStack(spacing: 12) {
           Image(systemName: subject.icon)
               .font(.system(size: 32))
               .foregroundColor(subject.color)
           
           Text(subject.displayName)
               .font(.headline)
               .foregroundColor(.primary)
               .lineLimit(1)
           
           Text("\(problemSetCount) sets")
               .font(.caption)
               .foregroundColor(.secondary)
       }
       .frame(maxWidth: .infinity)
       .padding(.vertical, 24)
       .background(
           RoundedRectangle(cornerRadius: 16)
               .fill(subject.color.opacity(0.1))
               .overlay(
                   RoundedRectangle(cornerRadius: 16)
                       .stroke(subject.color.opacity(0.2), lineWidth: 1)
               )
       )
       .contentShape(Rectangle())
   }
}

// SavedQuestionsRow 컴포넌트 분리
struct SavedQuestionsRow: View {
    let savedQuestions: [Question]
    let homeViewModel: HomeViewModel
    
    var body: some View {
        NavigationLink(
            destination: SavedQuestionsView(
                questions: savedQuestions,
                homeViewModel: homeViewModel
            )
        ) {
            HStack {
                Image(systemName: "bookmark.fill")
                    .foregroundColor(.blue)
                Text("Saved Questions")
                    .font(.headline)
                Spacer()
                Text("\(savedQuestions.count)")
                    .foregroundColor(.secondary)
            }
        }
    }
}

// SubjectRow 컴포넌트 분리
struct SubjectListRow: View {
    let subject: SubjectType
    let problemSets: [ProblemSet]
    let subjectManager: SubjectManager  // SubjectManager 인스턴스 필요
    @Binding var selectedTab: Int  // 추가
    
    var body: some View {
        if !subjectManager.isDeleted(subject.id) {
            NavigationLink(
                destination: ProblemSetsListView(
                    subject: subject,
                    problemSets: filterProblemSets(subject: subject, problemSets: problemSets),
                    selectedTab: $selectedTab  // 추가
                )
            ) {
                HStack {
                    Image(systemName: subject.icon)
                        .foregroundColor(subject.color)
                    // 여기를 수정 - subject.displayName 대신 subjectManager.getDisplayName 사용
                    if let defaultSubject = subject as? DefaultSubject {
                        Text(subjectManager.getDisplayName(for: defaultSubject))
                    } else {
                        Text(subject.displayName)
                    }
                    Spacer()
                    Image(systemName: "chevron.right")
                        .foregroundColor(.gray)
                        .font(.system(size: 14))
                }
            }
        }
    }
    
    private func filterProblemSets(subject: SubjectType, problemSets: [ProblemSet]) -> [ProblemSet] {
        return problemSets.filter { problemSet in
            if let defaultSubject = subject as? DefaultSubject {
                return problemSet.subjectType == "default" &&
                       problemSet.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return problemSet.subjectType == "custom" &&
                       problemSet.subjectId == customSubject.id
            }
            return false
        }
    }
}
// ReviewView용 DefaultSubjectsSection 컴포넌트
struct ReviewDefaultSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let problemSets: [ProblemSet]
    @ObservedObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int  // 추가
    
    var body: some View {
        Section(header: Text("Default Subjects")) {
            ForEach(DefaultSubject.allCases, id: \.id) { subject in
                let filteredSets = problemSets.filter {
                    $0.subjectType == "default" &&
                    $0.subject.rawValue == subject.rawValue
                }.sorted(by: { $0.createdAt > $1.createdAt })
                
                NavigationLink(
                    destination: ProblemSetsListView(
                        subject: subject,
                        problemSets: filteredSets,
                        selectedTab: $selectedTab  // 추가
                    )
                ) {
                    SubjectRow(subject: subject)
                }
            }
        }
    }
}

// ReviewView용 CustomSubjectsSection 컴포넌트
struct ReviewCustomSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let problemSets: [ProblemSet]
    @ObservedObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int  // 추가
    
    var body: some View {
        Section(header: Text("Custom Subjects")) {
            ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                let filteredSets = problemSets.filter { $0.subject.displayName == subject.displayName }
                    .sorted(by: { $0.createdAt > $1.createdAt })
                
                NavigationLink(
                    destination: ProblemSetsListView(
                        subject: subject,
                        problemSets: filteredSets,
                        selectedTab: $selectedTab  // 추가
                    )
                ) {
                    SubjectRow(subject: subject)
                }
            }
        }
    }
}

extension SubjectType {
    func isDeleted(in subjectManager: SubjectManager) -> Bool {
        if let defaultSubject = self as? DefaultSubject {
            return subjectManager.isDeleted(defaultSubject)
        }
        return false
    }
}

// ProblemSetsListView는 그대로 유지


struct ProblemSetsListView: View {
    let subject: SubjectType
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var isShowingStudyView = false
    @State private var isShowingDeleteAlert = false
    @State private var problemSetToDelete: ProblemSet?
    @Binding var selectedTab: Int  // 새로 추가
    
    init(subject: SubjectType,
         problemSets: [ProblemSet],
         selectedTab: Binding<Int>) {  // 초기화 구문에 selectedTab 추가
        self.subject = subject
        self.problemSets = problemSets
        self._selectedTab = selectedTab
    }
    
    var body: some View {
        List {
            ForEach(problemSets) { problemSet in
                ProblemSetRow(
                    problemSet: problemSet,
                    isShowingStudyView: $isShowingStudyView,
                    isShowingDeleteAlert: $isShowingDeleteAlert,
                    problemSetToDelete: $problemSetToDelete,
                    selectedTab: $selectedTab  // selectedTab 전달
                )
            }
        }
        .listStyle(InsetGroupedListStyle())
        .navigationTitle("\(subject.displayName) Sets")
        .alert("Delete Problem Set", isPresented: $isShowingDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let problemSet = problemSetToDelete {
                    Task {
                        await homeViewModel.deleteProblemSet(problemSet)
                    }
                }
            }
        } message: {
            Text("Are you sure you want to delete this problem set? This action cannot be undone.")
        }
    }
}

// 별도의 row 컴포넌트로 분리
struct ProblemSetRow: View {
    let problemSet: ProblemSet
    @Binding var isShowingStudyView: Bool
    @Binding var isShowingDeleteAlert: Bool
    @Binding var problemSetToDelete: ProblemSet?
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var refreshTrigger = RefreshTrigger()
    @Binding var selectedTab: Int  // 새로 추가
    
    // 이름 변경을 위한 상태 변수
    @State private var displayName: String
    
    init(problemSet: ProblemSet,
         isShowingStudyView: Binding<Bool>,
         isShowingDeleteAlert: Binding<Bool>,
         problemSetToDelete: Binding<ProblemSet?>,
         selectedTab: Binding<Int>) {  // 초기화 구문에 selectedTab 추가
        self.problemSet = problemSet
        self._isShowingStudyView = isShowingStudyView
        self._isShowingDeleteAlert = isShowingDeleteAlert
        self._problemSetToDelete = problemSetToDelete
        self._selectedTab = selectedTab  // 새로 추가
        self._displayName = State(initialValue: problemSet.name)
    }
    
    var body: some View {
        Button(action: {
            Task {
                // ProblemSet 설정
                homeViewModel.setSelectedProblemSet(problemSet)
                
                // StudyViewModel에 직접 questions 설정
                if let studyViewModel = homeViewModel.studyViewModel {
                    // 상태 리셋
                    await studyViewModel.resetState()
                    // 문제 로드
                    studyViewModel.loadQuestions(problemSet.questions)
                    
                    // 탭 전환 및 UI 업데이트
                    await MainActor.run {
                        withAnimation {
                            selectedTab = 1  // Study 탭으로 전환
                            isShowingStudyView = true
                        }
                    }
                }
            }
        }) {
            ReviewProblemSetCard(
                subject: problemSet.resolvedSubject,
                problemSet: problemSet.copy(withName: displayName),
                onDelete: {
                    problemSetToDelete = problemSet
                    isShowingDeleteAlert = true
                },
                onRename: { newName in
                    Task {
                        await homeViewModel.renameProblemSet(problemSet, newName: newName)
                        // UI 즉시 업데이트
                        await MainActor.run {
                            displayName = newName
                        }
                    }
                }
            )
        }
        .onChange(of: problemSet.name) { newName in
            displayName = newName
        }
    }
}

extension ProblemSet {
    func copy(withName newName: String) -> ProblemSet {
        ProblemSet(
            id: self.id,
            subject: self.subject,
            subjectType: self.subjectType,
            subjectId: self.subjectId,
            subjectName: self.subjectName,
            questions: self.questions,
            createdAt: self.createdAt,
            educationLevel: self.educationLevel,
            name: newName  // 새 이름 사용
        )
    }
}


// StudyView destination을 별도 컴포넌트로 분리
// StudyDestinationView (기존과 동일)
struct StudyDestinationView: View {
    let problemSet: ProblemSet
    @EnvironmentObject var homeViewModel: HomeViewModel
    
    var body: some View {
        Group {
            if let studyViewModel = homeViewModel.studyViewModel {
                StudyView(
                    questions: problemSet.questions,
                    studyViewModel: studyViewModel,
                    selectedTab: .constant(1)
                )
            } else {
                Text("Study ViewModel not available")
            }
        }
    }
}


class RefreshTrigger: ObservableObject {
    @Published var id = UUID()
    
    func refresh() {
        id = UUID()
    }
}


// 과목 행 컴포넌트
struct SubjectRow: View {
    // Style enum to handle different display modes
    enum Style {
        case navigation
        case management
    }
    
    let subject: SubjectType
    let style: Style
    let isDefault: Bool
    
    // Default initializer for navigation style
    init(subject: SubjectType) {
        self.subject = subject
        self.style = .navigation
        self.isDefault = false
    }
    
    // Management style initializer
    init(subject: SubjectType, isDefault: Bool) {
        self.subject = subject
        self.style = .management
        self.isDefault = isDefault
    }
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
                .font(style == .management ? .title2 : .body)
            
            Text(subject.displayName)
                .foregroundColor(.primary)
                .font(style == .management ? .body : .headline)
                .padding(.leading, style == .management ? 0 : 8)
            
            if style == .management {
                if isDefault {
                    Spacer()
                    Text("Default")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(.vertical, style == .management ? 8 : 0)
    }
}


// ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
    @State private var isCorrect: Bool? = nil  // 이 부분이 중요합니다
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // 추가
   @State private var previewIsCorrect: Bool? = nil        // 추가
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
    var body: some View {
        VStack {
            if studyViewModel.isGeneratingQuestions {
                VStack(spacing: 16) {
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.white)
                    .transition(.opacity)
                    
                    if !studyViewModel.generatedQuestions.isEmpty {
                        ScrollView {
                            LazyVStack(spacing: 12) {
                                ForEach(studyViewModel.generatedQuestions) { question in
                                    QuestionPreviewCard(
                                        question: question,
                                        selectedAnswer: $previewSelectedAnswer,
                                        isCorrect: $previewIsCorrect,
                                        onAnswerSelected: { correct in
                                            print("Answer selected: \(correct)")
                                        }
                                    )
                                    .transition(.slide)
                                }
                            }
                            .padding()
                        }
                    }
                }
            } else if !studyViewModel.hasQuestions {
                Text("No questions available")
                    .font(.title3)
                    .foregroundColor(.gray)
            } else {
                VStack {
                    Spacer()
                        .frame(height: 20)
                    
                    ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                               total: Double(studyViewModel.totalQuestions))
                        .progressViewStyle(CustomProgressViewStyle())
                        .padding(.horizontal, 20)
                        .padding(.bottom, 10)
                    
                    Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.secondary)
                        .padding(.bottom, 20)
                    
                    if !studyViewModel.hasQuestions {
                        Text("No questions available")
                            .font(.title3)
                            .foregroundColor(.gray)
                    } else {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 20) {
                                if let currentQuestion = studyViewModel.currentQuestion {
                                    switch currentQuestion.type {
                                    case .multipleChoice:
                                        MultipleChoiceView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect
                                        )
                                        
                                    case .trueFalse:
                                        TrueFalseView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect  // 여기 isCorrect 바인딩이 문제일 수 있습니다
                                        )
                                    }
                                    
                                    if showExplanation && studyViewModel.showExplanation {
                                        ExplanationView(explanation: currentQuestion.explanation)
                                    }
                                }
                            }
                            .padding()
                        }
                        
                        VStack {
                            Divider()
                            
                            HStack(spacing: 12) {
                                if studyViewModel.showExplanation {
                                    UtilityButtons(
                                        showExplanation: $showExplanation,
                                        isSaved: $isSaved,
                                        studyViewModel: studyViewModel
                                    )
                                }
                                
                                ActionButton(
                                    viewModel: studyViewModel,
                                    selectedTab: $selectedTab,
                                    isCorrect: $isCorrect,
                                    showExplanation: $showExplanation
                                )
                            }
                            .padding()
                            .background(Color(UIColor.systemBackground))
                        }
                    }
                }
            }
        }
        .onAppear {
            if let currentQuestion = studyViewModel.currentQuestion {
                isSaved = currentQuestion.isSaved
            }
        }
        .onChange(of: studyViewModel.currentQuestion) { newQuestion in
            if let question = newQuestion {
                isSaved = question.isSaved
            }
        }
    }
}

struct CustomProgressViewStyle: ProgressViewStyle {
    func makeBody(configuration: Configuration) -> some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 12)
                
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.blue)
                    .frame(width: CGFloat(configuration.fractionCompleted ?? 0) * geometry.size.width,
                           height: 12)
            }
        }
        .frame(height: 12)
    }
}

// 새로 추가된 미리보기 카드 뷰
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // 상단 정보
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
          }
          
          // 질문
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // 답변 옵션
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// 기존 컴포넌트들은 유지
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil  // 다음 문제로 넘어갈 때 리셋
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               if let currentQuestion = viewModel.currentQuestion,
                  let selectedAnswer = viewModel.selectedAnswer {
                   isCorrect = currentQuestion.correctAnswer.lowercased() == selectedAnswer.lowercased()
               }
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}

struct GeneratingQuestionsOverlay: View {
    let questionCount: Int  // 필요하지만 사용하지 않을 매개변수
    @State private var rotation: Double = 0
    @State private var dotScale: CGFloat = 1.0
    @State private var currentTipIndex = 0
    let timer = Timer.publish(every: 5, on: .main, in: .common).autoconnect()
    
    var body: some View {
        ZStack {
            // 배경색을 흰색으로 변경
            Color.white
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 30) {
                // Main Animation Circle
                ZStack {
                    // Outer rotating circle
                    Circle()
                        .stroke(lineWidth: 6)
                        .frame(width: 200, height: 200)
                        .foregroundColor(.blue.opacity(0.3))
                        .rotationEffect(.degrees(rotation))
                    
                    // Inner gradient circle
                    Circle()
                        .stroke(
                            LinearGradient(
                                gradient: Gradient(colors: [.blue, .purple]),
                                startPoint: .top,
                                endPoint: .bottom
                            ),
                            lineWidth: 10
                        )
                        .frame(width: 180, height: 180)
                        .rotationEffect(.degrees(-rotation))
                    
                    // Center content - 텍스트 색상을 검은색으로 변경하고 Questions 수 표시 제거
                    VStack(spacing: 8) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 40))
                            .foregroundColor(.blue)
                        Text("Generating")
                            .font(.title)
                            .foregroundColor(.black)  // 검은색으로 변경
                        Text("Questions")
                            .font(.title2)
                            .foregroundColor(.black)  // 검은색으로 변경
                    }
                }
                .onAppear {
                    withAnimation(
                        .linear(duration: 4)
                        .repeatForever(autoreverses: false)
                    ) {
                        rotation = 360
                    }
                }
                
                // Animated Dots
                HStack(spacing: 8) {
                    ForEach(0..<3) { index in
                        Circle()
                            .fill(Color.blue)
                            .frame(width: 12, height: 12)
                            .scaleEffect(dotScale)
                            .animation(
                                .easeInOut(duration: 0.6)
                                .repeatForever()
                                .delay(Double(index) * 0.2),
                                value: dotScale
                            )
                    }
                }
                .onAppear {
                    dotScale = 0.5
                }
                
                // Tips Section
                VStack(spacing: 12) {
                    Text(tips[currentTipIndex])
                        .font(.headline)
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                        .frame(height: 60)
                        .transition(.opacity.combined(with: .slide))
                        .id(currentTipIndex)
                        .animation(.easeInOut, value: currentTipIndex)
                    
                    // Progress Dots
                    HStack(spacing: 6) {
                        ForEach(0..<tips.count) { index in
                            Circle()
                                .fill(index == currentTipIndex ? Color.white : Color.gray)
                                .frame(width: 8, height: 8)
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 15)
                        .fill(Color.blue.opacity(0.8))
                )
            }
            .padding(30)
        }
        .onReceive(timer) { _ in
            withAnimation {
                currentTipIndex = (currentTipIndex + 1) % tips.count
            }
        }
    }
    
    private let tips = [
        "Creating personalized questions just for you...",
        "Analyzing content to ensure the best learning experience...",
        "Getting ready to challenge your knowledge...",
        "Preparing explanations to help you understand better...",
        "Almost there! Your questions are being finalized..."
    ]
}

struct GeneratedQuestionPreviewCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: question.type == .multipleChoice ? "list.bullet.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(.blue)
                Text(question.type == .multipleChoice ? "Multiple Choice" : "True/False")
                    .font(.caption)
                    .foregroundColor(.blue)
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .foregroundColor(.primary)
        }
        .padding()
        .background(Color.white)
        .cornerRadius(10)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
    }
}


// ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 512 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.8
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // 이미지의 크기를 최대 치수에 맞게 조정
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // 설정된 품질로 압축
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // 크기가 최대 파일 크기를 초과하는 경우, 품질을 낮춰서 추가 압축 시도
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera),
                  UIImagePickerController.isCameraDeviceAvailable(.rear) else {
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetail의 설정 값을 사용
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // 예측 토큰 수 계산
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        📊 Image Optimization Results:
        • Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        • Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        • Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        • Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        • Estimated Tokens: \(estimatedTokens)
        • Processing Time: \(String(format: "%.3f", processingTime))s
        • Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}



// ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
    case fileProviderAccessDenied
    case fileCoordinationFailed
}

public class StorageService {
    // MARK: - Properties
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let fileCoordinator = NSFileCoordinator()
    private let fileManager = FileManager.default
    
    // MARK: - Constants
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    private let maxRetryCount = 3
    private let retryDelay: TimeInterval = 0.5
    
    // MARK: - File System
    private var documentDirectory: URL? {
        fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
    }
    
    private func getDirectoryURL(for type: String) -> URL? {
        documentDirectory?.appendingPathComponent(type)
    }
    
    // MARK: - FileProvider Handling
    private func handleFileProviderAccess<T>(_ operation: @escaping (URL) throws -> T) throws -> T {
        guard checkFileProviderAuthorization() else {
            throw StorageError.fileProviderAccessDenied
        }
        
        guard let url = documentDirectory else {
            throw StorageError.invalidData
        }
        
        var coordinationError: NSError?
        var result: T?
        var operationError: Error?
        
        fileCoordinator.coordinate(writingItemAt: url, options: .forMoving, error: &coordinationError) { coordinatedURL in
            do {
                result = try operation(coordinatedURL)
            } catch {
                operationError = error
            }
        }
        
        if let error = coordinationError {
            throw StorageError.fileCoordinationFailed
        }
        
        if let error = operationError {
            throw error
        }
        
        return result!
    }
    
    private func checkFileProviderAuthorization() -> Bool {
        // 실제 환경에서는 적절한 권한 체크 로직 구현
        return true
    }
    
    // MARK: - Error Handling
    private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
        do {
            return try operation()
        } catch let error as NSError {
            Logger.logError(error, category: "FileOperation")
            
            // 재시도 로직
            for attempt in 1...maxRetryCount {
                Logger.log("Retrying operation (attempt \(attempt)/\(maxRetryCount))", category: "FileOperation")
                do {
                    return try operation()
                } catch {
                    if attempt == maxRetryCount {
                        throw error
                    }
                    Thread.sleep(forTimeInterval: retryDelay)
                }
            }
            throw error
        }
    }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var problemSets = try self.getProblemSets()
                problemSets.append(problemSet)
                
                let data = try self.encoder.encode(problemSets)
                self.defaults.set(data, forKey: self.problemSetsKey)
            }
        }
    }
    
    public func getProblemSets() throws -> [ProblemSet] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: problemSetsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([ProblemSet].self, from: data)
            } catch {
                Logger.logError(error, category: "ProblemSets")
                throw StorageError.loadFailed
            }
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                sessions.append(session)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: studySessionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([StudySession].self, from: data)
            } catch {
                Logger.logError(error, category: "StudySessions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.deleteFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                
                guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
                    throw StorageError.notFound
                }
                
                sessions.remove(at: index)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func saveQuestion(_ question: Question) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var savedQuestions = try self.getSavedQuestions()
                savedQuestions.append(question)
                
                let data = try self.encoder.encode(savedQuestions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: savedQuestionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([Question].self, from: data)
            } catch {
                Logger.logError(error, category: "SavedQuestions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func saveQuestions(_ questions: [Question]) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                let data = try self.encoder.encode(questions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("📝 [\(category)] \(message)")
        #endif
    }
    
    static func logError(_ error: Error, category: String) {
        #if DEBUG
        print("❌ [\(category)] Error: \(error.localizedDescription)")
        #endif
    }
}


// ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    private let apiKey: String
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    
    static let shared: OpenAIService = {
        do {
            return try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAIService: \(error)")
        }
    }()
    
    
    func sendTextExtractionResult(_ extractedText: String) async throws -> String {
        print("🔄 Processing extracted text in OpenAI service...")
        print("📝 Input text: \(extractedText)")
        
        let url = URL(string: baseURL)!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        let body: [String: Any] = [
            "model": "gpt-4o",
            "messages": [
                ["role": "system", "content": "You are an expert at analyzing extracted text."],
                ["role": "user", "content": extractedText]
            ],
            "temperature": 0.7,
            "max_tokens": 2000
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        print("🌐 Sending request to OpenAI API...")
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("❌ Invalid response received")
            throw NetworkError.invalidResponse
        }
        
        print("📡 Response status code: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            print("❌ API request failed with status code: \(httpResponse.statusCode)")
            throw NetworkError.apiError("API request failed with status \(httpResponse.statusCode)")
        }

        let result = String(data: data, encoding: .utf8) ?? "No response"
        print("✅ OpenAI processing completed: \(result)")
        return result
    }


        func sendImageDataToOpenAI(_ imageData: Data) async throws {
            let url = URL(string: "https://api.openai.com/v1/images")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("Bearer YOUR_API_KEY", forHTTPHeaderField: "Authorization")

            let body: [String: Any] = [
                "image": imageData.base64EncodedString(),
                "purpose": "image-analysis"
            ]

            request.httpBody = try JSONSerialization.data(withJSONObject: body, options: [])

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw NSError(domain: "OpenAIService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to get valid response from OpenAI API"])
            }

            let result = String(data: data, encoding: .utf8) ?? "No response"
            print("✅ Image sent to OpenAI. Response: \(result)")
        }
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public 으로 변경
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init 추가
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public 으로 변경
        let subject: DefaultSubject  // Subject -> DefaultSubject로 변경
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        let language: Language
        
        public init(    // public init 추가
            subject: DefaultSubject,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int],
            language: Language
        ) {
            self.subject = subject
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
            self.language = language
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("❌ Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("📸 Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("❌ Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }
    
    // StreamResponse 구조체도 필요합니다
    private struct StreamResponse: Codable {
        struct Choice: Codable {
            struct Delta: Codable {
                let content: String?
            }
            let delta: Delta
        }
        let choices: [Choice]
    }

    // extractCompleteQuestion 함수도 추가
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSON이 완전한 객체인지 확인
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSON이 아직 완성되지 않았거나 파싱할 수 없는 경우
            return nil
        }
    }
    
    // 나머지 private 구조체들은 그대로 유지
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Initialization
    init() throws {
        self.apiKey = try ConfigurationManager.shared.getValue(for: "OpenAIAPIKey")
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("✅ Retrieved questions from cache")
            return cachedQuestions
        }
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // 이미지 또는 텍스트를 처리하는 태스크 추가
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            let questions = try await self.performQuestionGeneration(
                input: processedInput,                     // 이미지 데이터 전달
                textInput: processedTextInput,             // 텍스트 데이터 전달
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(
        _ subject: SubjectType,
        isImageInput: Bool,
        isExtractedText: Bool,  // 새로운 매개변수 추가
        educationLevel: EducationLevel,
        language: Language
    ) -> SubjectPrompt {
        let subjectName = if let customSubject = subject as? CustomSubject {  // 수정된 부분
            customSubject.displayName
        } else {
            subject.displayName
        }
        
        let languageInstructionText = language == .auto ?
            "Generate questions in the exact same language as the input text." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.displayName) language.
            DO NOT use the input text's language. Even if the input is in another language, the output must be in \(language.displayName) only.
            """
        
        let languageInstructionImage = language == .auto ?
            "Generate questions in the same language as any visible text in the image." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.displayName) (\(language.rawValue)).
            DO NOT use the language of visible text in the image. All output must be in \(language.displayName) only.
            """

        // 순수 이미지 기반 입력
        if isImageInput && !isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained, image-based questions.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as visible text in the image" : language.displayName)
                    - Ensure consistent language usage throughout all content.
                    - Translate concepts accurately without losing meaning.
                    
                    FORMATTING REQUIREMENTS:
                    - Each question must be self-contained with all necessary context provided.
                    - Avoid ambiguous or overly broad questions.
                    - Ensure True/False answers are always lowercase ("true" or "false").
                    - Do not translate True/False answers into other languages.

                    ERROR PREVENTION:
                    - Avoid using "Yes", "No", or "That's correct" for True/False questions.
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Create high-quality, context-rich questions based on the given image.
                    \(languageInstructionImage)
                    Each question must include detailed explanations and hints.

                    Examples of good questions:
                    - "If the sum of the angles in a triangle is 180°, and one angle is 90°, what are the other two angles?"
                    - "The Roman Empire declined for many reasons. Which of the following factors contributed the most to its fall?"
                    
                    Examples of bad questions:
                    - "What does the text explain?"
                    - "Is this image interesting?"
                    """
            )
        }
        // 이미지에서 추출된 텍스트 기반 입력
        else if isImageInput && isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained questions based on extracted text from images.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as the extracted text" : language.displayName)
                    - Maintain consistent language usage across all questions, answers, and explanations.
                    - Preserve technical terms and proper nouns during translation.

                    FORMATTING REQUIREMENTS:
                    - Create questions with all necessary context included.
                    - True/False answers must be "true" or "false" (lowercase).
                    - Avoid "wh-" questions like "what", "who", or "how".

                    ERROR PREVENTION:
                    - Do not use variations like "Yes", "No", or "That's correct" for True/False questions.
                    - Avoid ambiguity in technical or academic concepts.
                    """,
                userPromptTemplate: """
                    Generate accurate and context-aware questions from the extracted text in the image.
                    \(languageInstructionImage)
                    Include hints and explanations for each question.

                    Examples of good questions:
                    - "The fall of the Roman Empire is often attributed to external invasions. Which of the following best explains this?"
                    - "In the Pythagorean theorem, if a² + b² = c², what does 'c' represent in a right triangle?"

                    Examples of bad questions:
                    - "What does this text mean?"
                    - "Explain the context."
                    """
            )
        }
        // 텍스트 기반 입력
        else {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating questions for \(educationLevel.displayName) students.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as input text" : language.displayName)
                    - Maintain consistent language usage in all content.
                    - Translate concepts accurately and preserve their original meaning.

                    FORMATTING REQUIREMENTS:
                    - Include all necessary context within the questions.
                    - Avoid overly broad or simplistic questions.
                    - True/False answers must be "true" or "false" (lowercase) and must not be translated.

                    ERROR PREVENTION:
                    - Do not use "Yes", "No", or "That's correct" for True/False answers.
                    - Ensure clarity and precision in question phrasing.
                    """,
                userPromptTemplate: """
                    Create thoughtful and context-rich questions based on the input text.
                    \(languageInstructionText)
                    Create National Assessment of Educational Progress questions for \(educationLevel.displayName) school students
                    Include hints and detailed explanations.

                    Examples of good questions:
                    - "The Renaissance was a cultural movement in Europe. Which of the following innovations was NOT developed during this period?"
                    - "If a car travels 60 miles in one hour, how far will it travel in three hours at the same speed?"

                    Examples of bad questions:
                    - "What is the capital of France?"
                    - "Explain this text."
                    """
            )
        }
    }

    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            isExtractedText: !input.isImage && input.content.count > 0,  // 텍스트 추출 여부 확인
            educationLevel: parameters.educationLevel,
            language: parameters.language
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": ["type": "array", "items": ["type": "string"]],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint" ]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        print("🤖 OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages 배열을 미리 선언
        var messages: [[String: Any]]

        // 구조화된 메시지 생성
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI 공식 멀티모달 포맷 사용
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        print("""
        🌐 API Request:
        • URL: \(baseURL)
        • Method: POST
        • Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            🌐 API Response:
            • Status Code: \(httpResponse.statusCode)
            • Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            // True/False 질문에서 접두사 제거
            let processedQuestion = questionData.type == "true_false" ?
                questionData.question
                    .replacingOccurrences(
                        of: "^(True or False:|True/False:|T/F:|\\(True/False\\)|\\[True/False\\]|True or False\\?|Is it true or false:|True False:)\\s*",
                        with: "",
                        options: [.regularExpression, .caseInsensitive]
                    )
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)  // 여러 공백을 하나로
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)   // 줄바꿈을 공백으로
                    .trimmingCharacters(in: .whitespacesAndNewlines) :
                questionData.question
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)  // 여러 공백을 하나로
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)   // 줄바꿈을 공백으로
                    .trimmingCharacters(in: .whitespacesAndNewlines)

            // True/False 답변 정규화
            var correctAnswer = questionData.correctAnswer
            if questionData.type == "true_false" {
                correctAnswer = correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
                if ["yes", "네", "true", "correct", "that's right", "맞습니다", "네, 그렇습니다", "사실입니다"].contains(correctAnswer) {
                    correctAnswer = "true"
                } else if ["no", "아니오", "false", "incorrect", "that's wrong", "아닙니다", "아니요", "사실이 아니다", "사실이 아닙니다"].contains(correctAnswer) {
                    correctAnswer = "false"
                }
            }

            return Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                question: processedQuestion,  // 처리된 질문 사용
                options: questionData.options,
                correctAnswer: correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        ✅ Questions Generated:
        • Count: \(questions.count)
        • Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


// ./AISnapStudy/Services/VisionService.swift

// Services/VisionService.swift

import Vision
import UIKit

// Vision 관련 에러 타입 정의
enum VisionError: Error {
    case invalidImage
    case processingFailed
    case noTextFound
    case unknown(Error)
}

class VisionService {
    static let shared = VisionService()
    
    private init() {}
    
    func extractText(from image: UIImage) async throws -> String {
        print("🔍 Starting universal text extraction...")
        
        guard let cgImage = image.cgImage else {
            print("❌ Failed to get CGImage from UIImage")
            throw VisionError.invalidImage
        }

        let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        let request = VNRecognizeTextRequest()
        
        // Universal text recognition settings
        request.recognitionLevel = .accurate
        request.usesLanguageCorrection = true
        request.automaticallyDetectsLanguage = true // Enable automatic language detection
        
        print("📝 Configured for universal text recognition")
        
        do {
            try requestHandler.perform([request])
            
            let observations = request.results ?? []
            print("📊 Found \(observations.count) text observations")
            
            var textBlocks: [(text: String, location: CGRect)] = []
            
            for observation in observations {
                if let candidate = observation.topCandidates(1).first {
                    let text = candidate.string
                    let confidence = candidate.confidence
                    
                    if confidence > 0.2 {
                        textBlocks.append((text, observation.boundingBox))
                    }
                }
            }
            
            let finalText = processTextBlocks(textBlocks)
            
            guard !finalText.isEmpty else {
                print("⚠️ No valid text extracted")
                throw VisionError.noTextFound
            }
            
            print("✅ Successfully extracted text")
            return finalText
            
        } catch {
            print("❌ Text extraction failed: \(error.localizedDescription)")
            throw VisionError.processingFailed
        }
    }
    
    private func processTextBlocks(_ blocks: [(text: String, location: CGRect)]) -> String {
        // Sort blocks by their position on the page
        let sortedBlocks = blocks.sorted { (block1, block2) -> Bool in
            // Different lines (threshold for line height difference)
            if abs(block1.location.minY - block2.location.minY) > 0.05 {
                return block1.location.minY > block2.location.minY
            }
            // Same line - left to right
            return block1.location.minX < block2.location.minX
        }
        
        // Process and join text blocks
        let processedText = sortedBlocks
            .map { block in
                var text = block.text
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Fix common punctuation issues
                text = text.replacingOccurrences(of: "\\s*([.,!?])\\s*", with: "$1 ", options: .regularExpression)
                text = text.replacingOccurrences(of: "([.,!?])\\1+", with: "$1", options: .regularExpression)
                
                return text
            }
            .joined(separator: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        return processedText
    }
}


// ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    // MARK: - Singleton
    static let shared = NetworkMonitor()
    
    // MARK: - Properties
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    private var timestampQueue: TimestampQueue
    
    // MARK: - Published Properties
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    // MARK: - Constants
    private let maxTimestamps = 1000
    private let cleanupInterval: TimeInterval = 300 // 5 minutes
    
    // MARK: - Debug Control
    private var shouldLog: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    // MARK: - Initialization
    private init() {
        self.timestampQueue = TimestampQueue(maxSize: maxTimestamps)
        setupPeriodicCleanup()
        startMonitoring()
    }
    
    // MARK: - Monitoring
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            self.timestampQueue.enqueue(Date().timeIntervalSince1970)
            
            DispatchQueue.main.async {
                self.updateNetworkStatus(path)
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    private func updateNetworkStatus(_ path: NWPath) {
        self.status = path.status
        self.isReachable = path.status == .satisfied
        self.connectionType = path.availableInterfaces.first?.type
        self.isExpensive = path.isExpensive
        self.isConstrained = path.isConstrained
        
        if shouldLog {
            switch path.status {
            case .satisfied:
                // 중요한 네트워크 상태 변경만 노티피케이션 발송
                if !isReachable {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            case .unsatisfied:
                Logger.log("Network disconnected", category: "Network")
            default:
                break
            }
        }
    }
    
    // MARK: - Network Status Check
    func checkNetworkAvailability() -> Bool {
        return status == .satisfied
    }
    
    func handleNetworkError(_ error: Error) async throws -> Bool {
        if !checkNetworkAvailability() {
            throw NetworkError.noConnection
        }
        return true
    }
    
    // MARK: - Timestamp Management
    private func setupPeriodicCleanup() {
        Timer.scheduledTimer(withTimeInterval: cleanupInterval, repeats: true) { [weak self] _ in
            self?.performTimestampCleanup()
        }
    }
    
    private func performTimestampCleanup() {
        let currentTime = Date().timeIntervalSince1970
        timestampQueue.removeTimestampsBefore(currentTime - cleanupInterval)
        if shouldLog {
            Logger.log("Timestamp cleanup completed", category: "Network")
        }
    }
    
    // MARK: - Utility Methods
    func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    // MARK: - Connection Management
    func getConnectionDetails() -> String {
        """
        Network Status:
        • Connection: \(isReachable ? "Connected" : "Disconnected")
        • Type: \(getInterfaceTypeString(connectionType))
        • Expensive: \(isExpensive ? "Yes" : "No")
        • Constrained: \(isConstrained ? "Yes" : "No")
        """
    }
    
    // MARK: - Cleanup
    func stopMonitoring() {
        monitor.cancel()
        if shouldLog {
            Logger.log("Network monitoring stopped", category: "Network")
        }
    }
    
    deinit {
        stopMonitoring()
    }
}

// MARK: - TimestampQueue
private class TimestampQueue {
    private var timestamps: [TimeInterval]
    private let maxSize: Int
    
    init(maxSize: Int) {
        self.maxSize = maxSize
        self.timestamps = []
        timestamps.reserveCapacity(maxSize)
    }
    
    func enqueue(_ timestamp: TimeInterval) {
        if timestamps.count >= maxSize {
            timestamps.removeFirst()
        }
        timestamps.append(timestamp)
    }
    
    func removeTimestampsBefore(_ time: TimeInterval) {
        timestamps.removeAll { $0 < time }
    }
    
    var count: Int {
        timestamps.count
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("📱 [\(category)] \(message)")
        #endif
    }
}


