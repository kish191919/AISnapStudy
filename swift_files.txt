## ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

@MainActor
class QuestionSettingsViewModel: ObservableObject {
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private var openAIService: OpenAIService?
    private let totalMaximumQuestions = 10
    private var studyViewModel: StudyViewModel? // Ï∂îÍ∞Ä
    
    // UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastDifficulty = "lastDifficulty"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastFillInBlanksCount = "lastFillInBlanksCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView = false
    @Published var problemSetName: String = ""
    
    let subject: Subject
    
    // MARK: - Published Properties with UserDefaults persistence
     @Published var selectedSubject: Subject {
         didSet {
             UserDefaults.standard.set(selectedSubject.rawValue, forKey: UserDefaultsKeys.lastSubject)
         }
     }
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
             print("üìö ViewModel - Education Level updated from \(oldValue) to \(educationLevel)")
         }
     }
     
     @Published var difficulty: Difficulty {
         didSet {
             UserDefaults.standard.set(difficulty.rawValue, forKey: UserDefaultsKeys.lastDifficulty)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
             print("ViewModel - Multiple Choice Count updated to: \(multipleChoiceCount)")
         }
     }
     
     @Published var fillInBlanksCount: Int {
         didSet {
             UserDefaults.standard.set(fillInBlanksCount, forKey: UserDefaultsKeys.lastFillInBlanksCount)
             print("ViewModel - Fill in Blanks Count updated to: \(fillInBlanksCount)")
         }
     }
     
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
             print("ViewModel - True/False Count updated to: \(trueFalseCount)")
         }
     }
     
     
     
     // MARK: - Initialization
    @MainActor
     init(subject: Subject, homeViewModel: HomeViewModel) {
         self.subject = subject
         self.homeViewModel = homeViewModel
         self.studyViewModel = homeViewModel.studyViewModel
         
         // Load last used values from UserDefaults
         let lastSubjectRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastSubject)
         let lastEducationLevelRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel)
         let lastDifficultyRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastDifficulty)
         
         // Initialize with last used values or defaults
         self.selectedSubject = Subject(rawValue: lastSubjectRaw ?? "") ?? subject
         self.educationLevel = EducationLevel(rawValue: lastEducationLevelRaw ?? "") ?? .elementary
         self.difficulty = Difficulty(rawValue: lastDifficultyRaw ?? "") ?? .medium
         
         // Load last question counts
         self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         self.fillInBlanksCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastFillInBlanksCount)
         self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         self.isLoading = false
         self.networkError = nil
         self.isNetworkAvailable = true
         self.showImagePicker = false
         self.showCamera = false
         self.selectedImages = []
         self.showAlert = false
         self.alertTitle = ""
         self.alertMessage = ""
         self.trueFalseCount = 0
         self.selectedImages = []
         
         // After all properties are initialized, setup network monitoring
         self.isNetworkAvailable = networkMonitor.isReachable
         
         // Initialize OpenAI service
         do {
             self.openAIService = try OpenAIService()
         } catch {
             self.error = error
             print("Failed to initialize OpenAI service:", error)
         }
     }
    
    // Í∏∞Î≥∏ Ïù¥Î¶Ñ ÏÉùÏÑ± Î©îÏÑúÎìú
    func generateDefaultName() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMdd_HHmm"
        let dateString = dateFormatter.string(from: Date())
        let totalQuestions = multipleChoiceCount + fillInBlanksCount + trueFalseCount
        
        return "\(selectedSubject.displayName)_\(totalQuestions)Q_\(dateString)"
        // Ïòà: "Math_10Q_0515_1430"
    }
     
     // Í∏∞Ï°¥ resetCounts Î©îÏÑúÎìú ÏàòÏ†ï
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         fillInBlanksCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults ÏôÑÏ†Ñ Ï¥àÍ∏∞ÌôîÍ∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞Î•º ÏúÑÌïú ÏÉàÎ°úÏö¥ Î©îÏÑúÎìú
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastDifficulty)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastFillInBlanksCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         difficulty = .medium
         resetCounts()
     }
    
    
    @Published var isLoading: Bool
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool
    @Published var alertTitle: String
    @Published var alertMessage: String
    
    // questionTextÍ∞Ä ÎπÑÏñ¥ÏûàÏßÄ ÏïäÏúºÎ©¥ Ïù¥ÎØ∏ÏßÄ ÏòµÏÖòÏùÑ Ïà®Í∏∞Í∏∞ ÏúÑÌïú Í≥ÑÏÇ∞ ÏÜçÏÑ±
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // ÌÖçÏä§Ìä∏ ÏûÖÎ†•ÏùÑ Î¶¨ÏÖãÌïòÎäî Î©îÏÑúÎìú
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // Ïã§Ï†ú ÏÑ†ÌÉùÎêú Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏùÑ ÎïåÎßå Ï≤¥ÌÅ¨
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // Îã§Ïùå ÏÉÅÌÉú Î≥ÄÍ≤ΩÏùÑ ÏúÑÌï¥ Î¶¨ÏÖã
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // ÏÉÅÌÉú Î¶¨ÏÖã
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + fillInBlanksCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + fillInBlanksCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }
    
    // MARK: - Image Management
    @MainActor
    func addImage(_ image: UIImage) async {
        do {
            let compressedData = try await Task {
                try ImageService.shared.compressForAPI(image)
            }.value
            
            if let compressedImage = UIImage(data: compressedData) {
                selectedImages.append(compressedImage)
                if hasCameraImage {
                    hasSelectedCamera = true
                }
                if hasGalleryImages {
                    hasSelectedGallery = true
                }
            }
        } catch {
            self.error = error
            showError(error)
        }
    }
    

    func removeImage(at index: Int) {
        selectedImages.remove(at: index)
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false    // Reset states
            hasSelectedGallery = false   // Reset states
        }
    }
    
    @MainActor
    func sendAllImages() async {
       print("\nüöÄ Starting sendAllImages")
       print("Current state:")
       print("‚Ä¢ Selected Subject: \(selectedSubject.displayName)")
       print("‚Ä¢ Selected Images: \(selectedImages.count)")
       print("‚Ä¢ Question Text: \(questionText.isEmpty ? "Empty" : "Has content")")
       print("‚Ä¢ Is Loading: \(isLoading)")
       
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("‚ùå No content to generate questions from")
           return
       }
       
       guard networkMonitor.isReachable else {
           print("‚ùå No network connection")
           showError(NetworkError.noConnection as Error)
           return
       }
       
       // OpenAIÎ°ú Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° Ïãú LoadingView ÌëúÏãú
       isLoading = true
       print("üîÑ Started loading state")
       
       do {
           let questionTypes: [QuestionType: Int] = [
               .multipleChoice: multipleChoiceCount,
               .fillInBlanks: fillInBlanksCount,
               .trueFalse: trueFalseCount
           ].filter { $0.value > 0 }
           
           let parameters = OpenAIService.QuestionParameters(
               subject: selectedSubject,
               difficulty: difficulty,
               educationLevel: educationLevel,
               questionTypes: questionTypes
           )
           
           if problemSetName.isEmpty {
               problemSetName = generateDefaultName()
           }
           
           print("""
           üìù Question Generation Parameters:
           ‚Ä¢ Subject: \(selectedSubject.displayName)
           ‚Ä¢ Difficulty: \(difficulty.displayName)
           ‚Ä¢ Education Level: \(educationLevel.displayName)
           ‚Ä¢ Question Types: \(questionTypes.map { "- \($0.key.rawValue): \($0.value)" }.joined(separator: "\n"))
           """)
           
           // Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°Ïù¥ ÏôÑÎ£åÎêòÎ©¥ LoadingViewÎ•º Ïà®Í∏∞Í≥†
           // StudyViewÏùò ÏßàÎ¨∏ ÏÉùÏÑ± ÏßÑÌñâ ÏÉÅÌÉú ÌëúÏãú ÏãúÏûë
           isLoading = false
           studyViewModel?.isGeneratingQuestions = true
           
           if !selectedImages.isEmpty {
               print("üì∏ Processing \(selectedImages.count) images")
               for (index, image) in selectedImages.enumerated() {
                   print("üñºÔ∏è Processing image \(index + 1) of \(selectedImages.count)")
                   let compressedData = try await Task {
                       try ImageService.shared.compressForAPI(image)
                   }.value
                   
                   let input = OpenAIService.QuestionInput(
                       content: compressedData,
                       isImage: true
                   )
                   
                   await generateQuestions(from: input, parameters: parameters)
               }
               selectedImages.removeAll()
               print("‚úÖ All images processed and cleared")
           } else if !questionText.isEmpty {
               print("üìù Processing text input: \(questionText)")
               guard let textData = questionText.data(using: .utf8) else {
                   throw NetworkError.invalidData
               }
               let input = OpenAIService.QuestionInput(
                   content: textData,
                   isImage: false
               )
               
               await generateQuestions(from: input, parameters: parameters)
               print("‚úÖ Text input processed")
           }
           
           // ÏßàÎ¨∏ ÏÉùÏÑ±Ïù¥ ÏôÑÎ£åÎêòÎ©¥ ÏßÑÌñâ ÏÉÅÌÉú ÌëúÏãú Ï¢ÖÎ£å
           studyViewModel?.isGeneratingQuestions = false
           print("‚úÖ Successfully generated questions")
           showSuccess()
           
           // Study ViewÎ°ú Ï†ÑÌôò
           shouldShowStudyView = true
           
       } catch {
           print("‚ùå Error in sendAllImages: \(error)")
           self.error = error
           showError(error)
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
       }
    }
    
    // MARK: - Image Capture Methods
    @MainActor
    func takePhoto() async {
        print("üì∏ Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }
    
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("üì∏ Processing camera image...")
        guard let image = image else {
            print("‚ùå No image captured")
            return
        }

        Task {
            do {
                await addImage(image)
                hasCameraImage = true
                hasSelectedCamera = true
                print("‚úÖ Camera image added successfully")
            } catch {
                print("‚ùå Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }
     
     @MainActor
     func selectFromGallery() async {
         do {
             let hasPermission = try await imageService.requestPermission(for: .gallery)
             if hasPermission {
                 showImagePicker = true
                 hasGalleryImages = true
             } else {
                 self.error = ImageServiceError.permissionDenied
                 showError(ImageServiceError.permissionDenied)
             }
         } catch {
             if let imageError = error as? ImageServiceError {
                 showError(imageError)
             } else {
                 showError(error)
             }
         }
     }
    
    // MARK: - Question Generation
    @MainActor
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
        guard let openAIService = openAIService else {
            print("‚ùå OpenAI service not initialized")
            return
        }
        
        do {
            let questionTypes: [QuestionType: Int] = [
                .multipleChoice: multipleChoiceCount,
                .fillInBlanks: fillInBlanksCount,
                .trueFalse: trueFalseCount
            ].filter { $0.value > 0 }
            
            // Î°úÍπÖ
            print("üöÄ Preparing to send data to OpenAI API:")
            print("‚Ä¢ Subject: \(subject.rawValue)")
            print("‚Ä¢ Difficulty: \(difficulty.rawValue)")
            print("‚Ä¢ Education Level: \(educationLevel.rawValue)")
            print("‚Ä¢ Question Types: \(questionTypes)")
            
            let questions = try await openAIService.generateQuestions(
                from: input,
                parameters: parameters
            )
            
            print("‚úÖ Generated \(questions.count) questions")
            await processGeneratedQuestions(questions)
        } catch {
            print("‚ùå Question generation error: \(error)")
            self.error = error
            showError(error)
        }
    }
    
    @MainActor
    func processGeneratedQuestions(_ questions: [Question]) async {
        print("\nüîÑ Processing Generated Questions:")
        print("Number of questions by type:")
        let questionsByType = Dictionary(grouping: questions, by: { $0.type })
        questionsByType.forEach { type, questions in
            print("- \(type.rawValue): \(questions.count) questions")
        }
        
        let subject = questions.first?.subject ?? self.subject
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            title: "Generated Questions",
            subject: subject,
            difficulty: difficulty,
            questions: questions,
            createdAt: Date(),
            educationLevel: self.educationLevel, // Ï∂îÍ∞Ä
            name: "Default Name" // Ï∂îÍ∞Ä
        )

        
        print("\nüì¶ Setting ProblemSet in HomeViewModel")
        // ProblemSet Ï†ÄÏû•
        await homeViewModel.saveProblemSet(problemSet)
        // Ï†ÄÏû•Îêú ProblemSetÏùÑ Î∞îÎ°ú ÏÑ†ÌÉùÌïòÏó¨ ÏÇ¨Ïö©
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // Study ÌÉ≠ÏúºÎ°ú ÏûêÎèô Ï†ÑÌôò
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
    }

    @MainActor
    private func showSuccess() {
       alertTitle = "Success"
       alertMessage = "Questions have been successfully generated."
       showAlert = true
    }
    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


## ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var streak: Int = 0
    @Published var totalPoints: Int = 0
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var correctAnswers: Int = 0
    @Published var isLoading = false
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    private var homeViewModel: HomeViewModel?
    private var studyViewModel: StudyViewModel?
    
    init(context: NSManagedObjectContext,
         homeViewModel: HomeViewModel? = nil,
         studyViewModel: StudyViewModel? = nil) {
        self.context = context
        self.homeViewModel = homeViewModel
        self.studyViewModel = studyViewModel
        loadStats()
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("üîÑ Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("üîÑ Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    func loadStats() {
        isLoading = true
        let request: NSFetchRequest<CDStudySession> = CDStudySession.fetchRequest()
        
        do {
            let sessions = try context.fetch(request)
            calculateStats(from: sessions)
        } catch {
            print("Failed to fetch study sessions:", error)
        }
        
        isLoading = false
    }

    private func calculateStats(from sessions: [CDStudySession]) {
        totalQuestions = sessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrect = sessions.reduce(0) { total, session in
            total + (session.questions?.filter { ($0 as? CDQuestion)?.isCorrect == true }.count ?? 0)
        }
        
        averageScore = totalQuestions > 0 ? (Double(totalCorrect) / Double(totalQuestions)) * 100 : 0
        correctAnswers = totalCorrect
        completedQuestions = totalQuestions
        totalPoints = completedQuestions * 10
        accuracyRate = completedQuestions > 0 ? (Double(correctAnswers) / Double(completedQuestions)) * 100 : 0
        streak = calculateStreak(from: sessions)
    }

    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
            print("üîÑ Starting resetProgress...")
            correctAnswers = 0
            completedQuestions = 0
            accuracyRate = 0
            
            // HomeViewModelÏùÑ ÌÜµÌï¥ StudyViewModelÏóê Ï†ëÍ∑º
            guard let homeVM = homeViewModel else {
                print("‚ùå homeViewModel is nil in resetProgress")
                return
            }
            
            guard let studyVM = homeVM.studyViewModel else {
                print("‚ùå studyViewModel is nil in resetProgress")
                return
            }
            
            guard let currentProblemSet = homeVM.selectedProblemSet else {
                print("‚ùå No selected problem set found")
                return
            }
            
            Task {
                print("üîÑ Resetting study state...")
                await studyVM.resetState()
                
                await MainActor.run {
                    print("üîÑ Loading questions...")
                    studyVM.loadQuestions(currentProblemSet.questions)
                    
                    print("""
                    ‚úÖ Reset complete:
                    ‚Ä¢ ProblemSet: \(currentProblemSet.id)
                    ‚Ä¢ Questions Count: \(currentProblemSet.questions.count)
                    ‚Ä¢ Current Index: \(studyVM.currentIndex)
                    ‚Ä¢ Current Question: \(studyVM.currentQuestion?.question ?? "None")
                    """)
                }
            }
            
            loadStats()
        }
    

}


## ./AISnapStudy/ViewModels/HomeViewModel.swift

// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    @Published var studyViewModel: StudyViewModel?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var correctAnswers: Int = 0
    @Published var totalQuestions: Int = 0
    @Published private(set) var selectedProblemSet: ProblemSet?
    
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()

    
    init() {
        Task {
            await loadInitialData()
        }
    }
    
        
    func setStudyViewModel(_ viewModel: StudyViewModel) {
        print("üì± Setting StudyViewModel in HomeViewModel")
        self.studyViewModel = viewModel
    }
    
    @MainActor
    func resetAndSetProblemSet(_ problemSet: ProblemSet) async {
        print("üîÑ Starting complete ProblemSet reset")
        
        // ÏÉàÎ°úÏö¥ ProblemSet ÏÑ§Ï†ï
        self.selectedProblemSet = problemSet
        
        // StudyViewModelÏù¥ nilÏù¥ ÏïÑÎãåÏßÄ ÌôïÏù∏
        guard let studyVM = studyViewModel else {
            print("‚ùå StudyViewModel is nil")
            return
        }
        
        // ÏÉÅÌÉú Î¶¨ÏÖã Î∞è Î¨∏Ï†ú Îã§Ïãú Î°úÎìú
        await studyVM.resetState()
        studyVM.loadQuestions(problemSet.questions)
        
        print("""
        ‚úÖ ProblemSet reset complete:
        ‚Ä¢ ID: \(problemSet.id)
        ‚Ä¢ Questions: \(problemSet.questions.count)
        ‚Ä¢ Index reset to 0
        ‚Ä¢ Current Question: \(studyVM.currentQuestion?.question ?? "none")
        """)
    }
    
    // MARK: - Data Loading
    @MainActor
    private func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("üîµ HomeViewModel - Initial data loading")
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            hasLoadedData = true
            print("‚úÖ Initial data loaded successfully")
        } catch {
            print("‚ùå Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("üîµ HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // ÏµúÍ∑º ProblemSetÏùÑ selectedProblemSetÏúºÎ°ú ÏÑ§Ï†ï
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            print("‚úÖ Loaded problem sets: \(problemSets.count)")
            print("‚úÖ Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("‚ùå Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            print("üíæ Saving ProblemSet with \(problemSet.questions.count) questions")
            try await coreDataService.saveProblemSet(problemSet)
            
            // Îç∞Ïù¥ÌÑ∞ Î¶¨Î°úÎìú ÎåÄÏã† Î¨∏Ï†ú ÏÑ∏Ìä∏ ÏßÅÏ†ë Ï∂îÍ∞Ä
            problemSets.insert(problemSet, at: 0)
            setSelectedProblemSet(problemSet)
            
            print("‚úÖ Saved ProblemSet: \(problemSet.questions.count) questions")
        } catch {
            self.error = error
            print("‚ùå Failed to save ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("üîµ HomeViewModel - Setting selected problem set")
        
        // ÏÉÅÌÉú Î≥ÄÍ≤ΩÏùÑ Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú ÌïúÎ≤àÏóê Ï≤òÎ¶¨
        DispatchQueue.main.async {
            self.selectedProblemSet = problemSet
            
            if let problemSet = problemSet {
                print("""
                ‚úÖ ProblemSet set successfully:
                ‚Ä¢ ID: \(problemSet.id)
                ‚Ä¢ Questions: \(problemSet.questions.count)
                """)
            }
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("‚ùå Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("‚ùå Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                üìù Stored ProblemSets:
                ‚Ä¢ Count: \(storedSets.count)
                ‚Ä¢ Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("‚ùå Failed to verify storage: \(error)")
            }
        }
    }
}


## ./AISnapStudy/ViewModels/HistoryViewModel.swift


import Foundation

import Foundation

@MainActor
class HistoryViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            üìö History Data Loaded:
            ‚Ä¢ Study Sessions: \(studySessions.count)
            ‚Ä¢ Problem Sets: \(problemSets.count)
            ‚Ä¢ Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("‚ùå Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("‚úÖ Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("‚ùå Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("üì± HomeViewModel reference set in HistoryViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


## ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
   // OpenAIService ÌÉÄÏûÖ Ï∞∏Ï°∞ Ï∂îÍ∞Ä
   typealias QuestionInput = OpenAIService.QuestionInput
   typealias QuestionParameters = OpenAIService.QuestionParameters

   @Published private(set) var loadedQuestions: [Question] = []
   @Published private(set) var loadingProgress = 0
   
   private let openAIService: OpenAIService
   
   @Published private(set) var currentQuestion: Question?
   @Published var selectedAnswer: String?
   @Published var showExplanation = false
   private var questions: [Question] = []
   private var cancellables = Set<AnyCancellable>()
   @Published private(set) var currentIndex = 0
   @Published var correctAnswers: Int = 0
    
    // ÏßàÎ¨∏ ÏÉùÏÑ± Í¥ÄÎ†® ÌîÑÎ°úÌçºÌã∞ Ï∂îÍ∞Ä
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    

    
    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }
    
    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }
    
   var totalQuestions: Int {
       questions.count
   }
   
   private let context: NSManagedObjectContext
   private var currentSession: CDStudySession?
   private let homeViewModel: HomeViewModel
   
   private var hasInitialized = false
   
    init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
        self.context = context
        self.homeViewModel = homeViewModel
        
        // OpenAIService Ï¥àÍ∏∞Ìôî
        do {
            self.openAIService = try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAI service: \(error)")
        }
        
        Task { @MainActor in
            homeViewModel.$selectedProblemSet
                .compactMap { $0 }
                .removeDuplicates(by: { $0.id == $1.id })
                .receive(on: RunLoop.main)
                .sink { [weak self] problemSet in
                    guard let self = self else { return }
                    // async Î©îÏÑúÎìúÎ•º Task ÎÇ¥ÏóêÏÑú Ìò∏Ï∂úÌïòÎèÑÎ°ù ÏàòÏ†ï
                    Task {
                        await self.resetState()
                        await MainActor.run {
                            self.loadQuestions(problemSet.questions)
                        }
                    }
                }
                .store(in: &self.cancellables)
        }
        
        setupCurrentSession()
    }
   
    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true  // Ïù¥Ï†ú Ìï†Îãπ Í∞ÄÎä•
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []
        
        // ÏòàÏÉÅÎêòÎäî Ï¥ù ÏßàÎ¨∏ Ïàò Í≥ÑÏÇ∞
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)
        
        do {
            for try await question in openAIService.streamQuestions(from: input, parameters: parameters) {
                await MainActor.run {
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }
        
        await MainActor.run {
            isGeneratingQuestions = false
        }

        do {
            for try await question in openAIService.streamQuestions(from: input, parameters: parameters) {
                await MainActor.run {
                    loadedQuestions.append(question)
                    loadingProgress = min(100, Int((Float(loadedQuestions.count) / Float(parameters.questionTypes.values.reduce(0, +))) * 100))
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }
        
        await MainActor.run {
            isLoadingQuestions = false  // Ïù¥Ï†ú Ìï†Îãπ Í∞ÄÎä•
        }
    }
   
    @MainActor
    func resetState() async {
        print("üîÑ Performing complete state reset")
        currentIndex = 0
        selectedAnswer = nil
        showExplanation = false
        correctAnswers = 0
        
        await MainActor.run {
            questions.removeAll()
            
            if let problemSet = homeViewModel.selectedProblemSet {
                questions = problemSet.questions
                currentQuestion = questions.first
            }
        }
        
        print("""
        ‚úÖ State reset complete:
        ‚Ä¢ Questions count: \(questions.count)
        ‚Ä¢ Current index: \(currentIndex)
        ‚Ä¢ Current question: \(currentQuestion?.question ?? "No question loaded")
        """)
    }
   
   func loadQuestions(_ newQuestions: [Question]) {
       print("üìù Loading fresh set of \(newQuestions.count) questions")
       questions = newQuestions
       currentIndex = 0
       currentQuestion = questions.isEmpty ? nil : questions[0]
       
       print("‚úÖ First question loaded explicitly: \(currentQuestion?.question ?? "No question loaded") with currentIndex: \(currentIndex)")
   }
   
   private func setupCurrentSession() {
       let session = CDStudySession(context: context)
       session.startTime = Date()
       currentSession = session
       saveContext()
   }
   
   func submitAnswer() {
       guard let currentQuestion = currentQuestion else { return }
       
       let isCorrect = currentQuestion.correctAnswer == selectedAnswer
       if isCorrect {
           correctAnswers += 1
       }
       
       if let session = currentSession {
           let question = CDQuestion(context: context)
           question.isCorrect = isCorrect
           question.question = currentQuestion.question
           question.session = session
           saveContext()
       }
       
       showExplanation = true
   }
   
   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
   private func saveContext() {
       do {
           try context.save()
       } catch {
           print("Failed to save context: \(error)")
       }
   }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .fillInBlanks, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("‚úÖ Question save state toggled successfully")
       } catch {
           print("‚ùå Failed to toggle question save state: \(error)")
       }
   }
}


## ./AISnapStudy/ViewModels/ProfileViewModel.swift



import SwiftUI

class ProfileViewModel: ObservableObject {
    @Published var user: User
    @Published var isDarkMode: Bool {
        didSet {
            UserDefaults.standard.set(isDarkMode, forKey: "isDarkMode")
        }
    }
    @Published var notificationsEnabled: Bool {
        didSet {
            UserDefaults.standard.set(notificationsEnabled, forKey: "notificationsEnabled")
        }
    }
    
    init() {
        // Ïã§Ï†ú Ïï±ÏóêÏÑúÎäî ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìúÌïòÎäî Î°úÏßÅ Íµ¨ÌòÑ
        self.user = User(
            id: "1",
            name: "Test User",
            email: "test@example.com",
            preferences: User.UserPreferences(
                isDarkMode: false,
                notificationsEnabled: true,
                dailyGoal: 5,
                preferredDifficulty: .medium
            ),
            createdAt: Date(),
            lastActive: Date()
        )
        
        self.isDarkMode = UserDefaults.standard.bool(forKey: "isDarkMode")
        self.notificationsEnabled = UserDefaults.standard.bool(forKey: "notificationsEnabled")
    }
    
    func showTerms() {
        guard let url = URL(string: "https://example.com/terms") else { return }
        UIApplication.shared.open(url)
    }
    
    func showPrivacyPolicy() {
        guard let url = URL(string: "https://example.com/privacy") else { return }
        UIApplication.shared.open(url)
    }
    
    func signOut() {
        // Î°úÍ∑∏ÏïÑÏõÉ Î°úÏßÅ Íµ¨ÌòÑ
    }
}


## ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
    }

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
        }
    }
    
    private func setupAppearance() {
        // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î∞î Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        
        // ÌÉ≠ Î∞î Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        return true
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        üìä CoreData Configuration:
        ‚Ä¢ Store Descriptions: \(container.persistentStoreDescriptions.count)
        ‚Ä¢ View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("‚ùå No store URL found")
            return
        }
        
        print("‚Ä¢ Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("‚úÖ Created CoreData directory")
        } catch {
            print("‚ùå Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData ÏòµÏÖò ÏÑ§Ï†ï
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // ÏÑ±Îä• ÏµúÏ†ÅÌôî ÏÑ§Ï†ï
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


## ./AISnapStudy/CoreData/SecureArrayTransformer.swift



import Foundation

@objc(SecureArrayTransformer)
final class SecureArrayTransformer: NSSecureUnarchiveFromDataTransformer {
    
    static let transformerName = NSValueTransformerName(rawValue: "SecureArrayTransformer")
    
    override static var allowedTopLevelClasses: [AnyClass] {
        [NSArray.self, NSString.self, NSDictionary.self]
    }
    
    static func register() {
        let transformer = SecureArrayTransformer()
        ValueTransformer.setValueTransformer(
            transformer,
            forName: transformerName
        )
    }
}


## ./AISnapStudy/CoreData/CoreDataService.swift




import CoreData
import Foundation



class CoreDataService {
    static let shared = CoreDataService()
    
    // private -> publicÏúºÎ°ú Î≥ÄÍ≤Ω
    public var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "AISnapStudy")
        
        // Ï†ÄÏû•ÏÜå ÏÑ§Î™Ö ÏÉùÏÑ±
        let storeDescription = NSPersistentStoreDescription()
        
        // Application Support ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ± ÌôïÏù∏
        if let applicationSupportURL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
            // Application Support ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÎã§Î©¥ ÏÉùÏÑ±
            if !FileManager.default.fileExists(atPath: applicationSupportURL.path) {
                do {
                    try FileManager.default.createDirectory(
                        at: applicationSupportURL,
                        withIntermediateDirectories: true,
                        attributes: nil
                    )
                    print("‚úÖ Created Application Support directory")
                } catch {
                    print("‚ùå Failed to create Application Support directory: \(error)")
                }
            }
            
            // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌååÏùº URL ÏÑ§Ï†ï
            let storeURL = applicationSupportURL.appendingPathComponent("AISnapStudy.sqlite")
            storeDescription.url = storeURL
            
            print("üìÅ CoreData store URL: \(storeURL.path)")
            
            // ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏòµÏÖò ÏÑ§Ï†ï
            storeDescription.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
            storeDescription.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
            storeDescription.setOption(["journal_mode": "WAL"] as NSDictionary, forKey: NSSQLitePragmasOption)
            storeDescription.setOption(FileProtectionType.complete as NSString, forKey: NSPersistentStoreFileProtectionKey)
            
            container.persistentStoreDescriptions = [storeDescription]
        }
        
        // Ï†ÄÏû•ÏÜå Î°úÎìú
        container.loadPersistentStores { description, error in
            if let error = error {
                print("""
                ‚ùå CoreData Error:
                ‚Ä¢ Error: \(error.localizedDescription)
                ‚Ä¢ Description: \(description)
                ‚Ä¢ Store URL: \(description.url?.absoluteString ?? "unknown")
                """)
                
                // Ïò§Î•ò Î∞úÏÉù Ïãú Ï†ÄÏû•ÏÜå Ïû¨ÏÉùÏÑ± ÏãúÎèÑ
                if let storeURL = description.url {
                    do {
                        try FileManager.default.removeItem(at: storeURL)
                        print("üîÑ Removed existing store file")
                        
                        // Ï†ÄÏû•ÏÜå Ïû¨ÏÉùÏÑ±
                        try container.persistentStoreCoordinator.addPersistentStore(
                            ofType: NSSQLiteStoreType,
                            configurationName: nil,
                            at: storeURL,
                            options: [
                                NSMigratePersistentStoresAutomaticallyOption: true,
                                NSInferMappingModelAutomaticallyOption: true
                            ]
                        )
                        print("‚úÖ Successfully recreated store")
                    } catch {
                        print("‚ùå Failed to recreate store: \(error)")
                        fatalError("Unresolved error \(error)")
                    }
                }
            } else {
                print("‚úÖ CoreData store loaded successfully")
            }
        }
        
        // Context ÏÑ§Ï†ï
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        return container
    }()
    
    // MARK: - Question Operations ÏÑπÏÖòÏóê Ï∂îÍ∞Ä
    // MARK: - Question Operations
    public func fetchSavedQuestions() throws -> [Question] {
        print("üìä Fetching Saved Questions from CoreData")
        let request: NSFetchRequest<CDQuestion> = CDQuestion.fetchRequest()
        request.predicate = NSPredicate(format: "isSaved == true")
        request.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: false)]
        
        do {
            let cdQuestions = try viewContext.fetch(request)
            print("üìä Found \(cdQuestions.count) saved questions")
            
            let questions = cdQuestions.compactMap { cdQuestion -> Question? in
                guard let id = cdQuestion.id,
                      let type = cdQuestion.type,
                      let questionText = cdQuestion.question,
                      let correctAnswer = cdQuestion.correctAnswer,
                      let explanation = cdQuestion.explanation else {
                    print("‚ö†Ô∏è Invalid question data found")
                    return nil
                }
                
                let options = cdQuestion.options as? [String] ?? []
                
                return Question(
                    id: id,
                    type: QuestionType(rawValue: type) ?? .multipleChoice,
                    subject: Subject(rawValue: cdQuestion.problemSet?.subject ?? "") ?? .math,
                    difficulty: Difficulty(rawValue: cdQuestion.problemSet?.difficulty ?? "") ?? .medium,
                    question: questionText,
                    options: options,
                    correctAnswer: correctAnswer,
                    explanation: explanation,
                    hint: cdQuestion.hint,
                    isSaved: cdQuestion.isSaved,
                    createdAt: cdQuestion.createdAt ?? Date()
                )
            }
            
            print("‚úÖ Successfully mapped \(questions.count) saved questions")
            return questions
            
        } catch {
            print("‚ùå Failed to fetch saved questions: \(error)")
            throw error
        }
    }

    // Í∏∞Ï°¥ saveQuestion Î©îÏÑúÎìú ÏàòÏ†ï
    public func saveQuestion(_ question: Question) throws {
        print("üíæ Attempting to save question: \(question.id)")
        
        // Î®ºÏ†Ä Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
        let request: NSFetchRequest<CDQuestion> = CDQuestion.fetchRequest()
        request.predicate = NSPredicate(format: "id == %@", question.id)
        
        do {
            let existingQuestions = try viewContext.fetch(request)
            let cdQuestion: CDQuestion
            
            if let existingQuestion = existingQuestions.first {
                print("üìù Updating existing question")
                cdQuestion = existingQuestion
            } else {
                print("üìù Creating new question")
                cdQuestion = CDQuestion(context: viewContext)
            }
            
            // ÏßàÎ¨∏ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            updateCDQuestion(cdQuestion, with: question)
            
            try viewContext.save()
            print("‚úÖ Successfully saved question: \(question.id)")
            
        } catch {
            print("‚ùå Failed to save question: \(error)")
            viewContext.rollback()
            throw error
        }
    }
    
    // viewContextÏóê ÎåÄÌïú public Ï†ëÍ∑ºÏûê Ï∂îÍ∞Ä
    public var viewContext: NSManagedObjectContext {
        persistentContainer.viewContext
    }
    
    private init() {}
    
    // Í≥µÍ∞ú Î©îÏÑúÎìúÎì§...
    public func saveContext() {
        if viewContext.hasChanges {
            do {
                try viewContext.save()
                print("‚úÖ CoreData context saved successfully")
            } catch {
                print("‚ùå CoreData context save error: \(error)")
                viewContext.rollback()
            }
        }
    }
    
    public func newBackgroundContext() -> NSManagedObjectContext {
        let context = persistentContainer.newBackgroundContext()
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return context
    }
    
    // MARK: - ProblemSet Operations
    // File: ./AISnapStudy/CoreData/CoreDataService.swift

    public func fetchProblemSets() throws -> [ProblemSet] {
        print("üìä Fetching ProblemSets from CoreData")
        let request: NSFetchRequest<CDProblemSet> = CDProblemSet.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: false)]
        
        do {
            let cdProblemSets = try viewContext.fetch(request)
            print("üìä Fetched \(cdProblemSets.count) ProblemSets from CoreData")
            
            return try cdProblemSets.map { cdProblemSet -> ProblemSet in
                let questions = (cdProblemSet.questions?.allObjects as? [CDQuestion])?
                    .compactMap { cdQuestion -> Question? in
                        guard let id = cdQuestion.id,
                              let type = cdQuestion.type,
                              let questionText = cdQuestion.question,
                              let correctAnswer = cdQuestion.correctAnswer,
                              let explanation = cdQuestion.explanation else {
                            print("‚ö†Ô∏è Invalid question data found")
                            return nil
                        }
                        
                        let options = cdQuestion.options as? [String] ?? []
                
                        
                        return Question(
                            id: id,
                            type: QuestionType(rawValue: type) ?? .multipleChoice,
                            subject: Subject(rawValue: cdProblemSet.subject ?? "") ?? .math,
                            difficulty: Difficulty(rawValue: cdProblemSet.difficulty ?? "") ?? .medium,
                            question: questionText,
                            options: options,
                            correctAnswer: correctAnswer,
                            explanation: explanation,
                            hint: cdQuestion.hint,
                            isSaved: cdQuestion.isSaved,
                            createdAt: cdQuestion.createdAt ?? Date()
                        )
                    } ?? []
                
                print("üìö Loaded \(questions.count) questions for ProblemSet: \(cdProblemSet.id ?? "")")
                
                return ProblemSet(
                    id: cdProblemSet.id ?? UUID().uuidString,
                    title: cdProblemSet.title ?? "",
                    subject: Subject(rawValue: cdProblemSet.subject ?? "") ?? .math,
                    difficulty: Difficulty(rawValue: cdProblemSet.difficulty ?? "") ?? .medium,
                    questions: questions,
                    createdAt: cdProblemSet.createdAt ?? Date(),
                    lastAttempted: cdProblemSet.lastAttempted,
                    educationLevel: EducationLevel(rawValue: cdProblemSet.educationLevel ?? "") ?? .elementary, // Ï∂îÍ∞Ä
                    name: cdProblemSet.name ?? "Default Name" // Ï∂îÍ∞Ä
                )

            }
        } catch {
            print("‚ùå Failed to fetch ProblemSets: \(error)")
            throw error
        }
    }
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        print("üìù Starting to save ProblemSet: \(problemSet.id)")
        
        let cdProblemSet = CDProblemSet(context: viewContext)
        cdProblemSet.id = problemSet.id
        cdProblemSet.title = problemSet.title
        cdProblemSet.subject = problemSet.subject.rawValue
        cdProblemSet.difficulty = problemSet.difficulty.rawValue
        cdProblemSet.createdAt = problemSet.createdAt
        cdProblemSet.lastAttempted = problemSet.lastAttempted
        
        // Î¨∏Ï†ú Ï†ÄÏû• Ï†Ñ Î°úÍ∑∏
        print("üíæ Preparing to save \(problemSet.questions.count) questions")
        
        // questions Í¥ÄÍ≥Ñ ÏÑ§Ï†ï
        let questionSet = NSMutableSet()
        
        for question in problemSet.questions {
            let cdQuestion = CDQuestion(context: viewContext)
            cdQuestion.id = question.id
            cdQuestion.type = question.type.rawValue
            cdQuestion.question = question.question
            
            // options Î∞∞Ïó¥ Î≥ÄÌôò Î∞è Ï†ÄÏû•
            cdQuestion.options = NSArray(array: question.options)
            
            cdQuestion.correctAnswer = question.correctAnswer
            cdQuestion.explanation = question.explanation
            cdQuestion.hint = question.hint
            cdQuestion.isSaved = question.isSaved
            cdQuestion.createdAt = question.createdAt
            cdQuestion.problemSet = cdProblemSet
            
            questionSet.add(cdQuestion)
            
            print("‚úèÔ∏è Prepared question: \(question.id)")
        }
        
        cdProblemSet.questions = questionSet
        
        do {
            try viewContext.save()
            print("‚úÖ Successfully saved ProblemSet with \(questionSet.count) questions")
            
            // Ï†ÄÏû• ÌõÑ ÌôïÏù∏
            if let savedQuestions = cdProblemSet.questions {
                print("üìö Verified \(savedQuestions.count) questions in CoreData")
            }
        } catch {
            print("‚ùå Failed to save ProblemSet: \(error)")
            viewContext.rollback()
            throw error
        }
    }
    
    public func deleteQuestion(_ question: Question) throws {
        // Type annotationÏùÑ Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏßÄÏ†ï
        let request = NSFetchRequest<CDQuestion>(entityName: "CDQuestion")
        // ÎòêÎäî ÏïÑÎûòÏôÄ Í∞ôÏù¥ ÏûëÏÑ± Í∞ÄÎä•
        // let request: NSFetchRequest<CDQuestion> = NSFetchRequest(entityName: "CDQuestion")
        
        request.predicate = NSPredicate(format: "id == %@", question.id)
        
        do {
            let questions = try viewContext.fetch(request)
            if let cdQuestion = questions.first {
                viewContext.delete(cdQuestion)
                try viewContext.save()
                print("‚úÖ Deleted Question: \(question.id)")
            }
        } catch {
            print("‚ùå Failed to delete Question: \(error)")
            viewContext.rollback()
            throw error
        }
    }
    
    // MARK: - Helper Methods
    // Ï°∞Ìöå Î°úÏßÅÎèÑ ÏàòÏ†ï
    private func updateCDQuestion(_ cdQuestion: CDQuestion, with question: Question) {
        cdQuestion.id = question.id
        cdQuestion.type = question.type.rawValue
        cdQuestion.question = question.question
        
        // Convert String arrays to NSArray
        cdQuestion.options = NSArray(array: question.options)
        cdQuestion.correctAnswer = question.correctAnswer
        cdQuestion.explanation = question.explanation
        cdQuestion.hint = question.hint
        cdQuestion.isSaved = question.isSaved
        cdQuestion.createdAt = question.createdAt
    }
}

// CDQuestion+Extension ÏàòÏ†ï
extension CDQuestion {
    func toDomain() -> Question? {
        guard let id = self.id,
              let type = self.type,
              let question = self.question,
              let correctAnswer = self.correctAnswer,
              let explanation = self.explanation else {
            return nil
        }
        
        // NSArrayÎ•º [String]ÏúºÎ°ú Î≥ÄÌôò
        let options = (self.options as? [String]) ?? []
        
        return Question(
            id: id,
            type: QuestionType(rawValue: type) ?? .multipleChoice,
            subject: Subject(rawValue: self.problemSet?.subject ?? "") ?? .math,
            difficulty: Difficulty(rawValue: self.problemSet?.difficulty ?? "") ?? .medium,
            question: question,
            options: options,
            correctAnswer: correctAnswer,
            explanation: explanation,
            hint: self.hint,
            isSaved: self.isSaved,
            createdAt: self.createdAt ?? Date()
        )
    }
}


## ./AISnapStudy/CoreData/CoreDataModels+Extensions.swift



import Foundation
import CoreData

// MARK: - CDProblemSet Extension
extension CDProblemSet {
    func toDomain() -> ProblemSet {
        let questions = (self.questions?.allObjects as? [CDQuestion])?.compactMap { question -> Question? in
            question.toDomain()
        } ?? []

        return ProblemSet(
            id: self.id ?? UUID().uuidString,
            title: self.title ?? "",
            subject: Subject(rawValue: self.subject ?? "") ?? .math,
            difficulty: Difficulty(rawValue: self.difficulty ?? "") ?? .medium,
            questions: questions,
            createdAt: self.createdAt ?? Date(),
            lastAttempted: self.lastAttempted,
            educationLevel: EducationLevel(rawValue: self.educationLevel ?? "") ?? .elementary, // Ï∂îÍ∞Ä
            name: self.name ?? "", // Ï∂îÍ∞Ä
            tags: self.tags as? [String] ?? [], // Ï∂îÍ∞Ä
            problemSetDescription: self.problemSetDescription,
            isFavorite: self.isFavorite
        )
    }
}

// MARK: - CDQuestion Extension
extension CDQuestion {
    func toDomain() -> Question {
        Question(
            id: self.id ?? UUID().uuidString,
            type: QuestionType(rawValue: self.type ?? "") ?? .multipleChoice,
            subject: Subject(rawValue: self.problemSet?.subject ?? "") ?? .math,
            difficulty: Difficulty(rawValue: self.problemSet?.difficulty ?? "") ?? .medium,
            question: self.question ?? "",
            options: self.options as? [String] ?? [],
            correctAnswer: self.correctAnswer ?? "",
            explanation: self.explanation ?? "",
            hint: self.hint,
            isSaved: self.isSaved,
            createdAt: self.createdAt ?? Date()
        )
    }
}

// MARK: - CDStudySession Extension
// MARK: - CDStudySession Extension
extension CDStudySession {
    func toDomain() -> StudySession {
        StudySession(
            id: self.id ?? UUID().uuidString,
            problemSet: self.problemSet?.toDomain() ?? ProblemSet(
                id: UUID().uuidString,
                title: "Unknown",
                subject: .math,
                difficulty: .medium,
                questions: [],
                createdAt: Date(),
                educationLevel: .elementary, // Ï∂îÍ∞Ä
                name: "Default Name" // Ï∂îÍ∞Ä
            ),
            startTime: self.startTime ?? Date(),
            endTime: self.endTime,
            answers: self.answers as? [String: String] ?? [:],
            score: Int(self.score)
        )
    }
}


## ./AISnapStudy/CoreData/CDQuestion+CoreDataClass.swift



import Foundation
import CoreData


public class CDQuestion: NSManagedObject {

}


## ./AISnapStudy/CoreData/CDStudySession+CoreDataClass.swift

//
//  CDStudySession+CoreDataClass.swift
//  AISnapStudy
//
//  Created by sunghwan ki on 11/10/24.
//
//

import Foundation
import CoreData


public class CDStudySession: NSManagedObject {

}


## ./AISnapStudy/CoreData/CDProblemSet+CoreDataProperties.swift



import Foundation
import CoreData


extension CDProblemSet {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDProblemSet> {
        return NSFetchRequest<CDProblemSet>(entityName: "CDProblemSet")
    }

    @NSManaged public var createdAt: Date?
    @NSManaged public var difficulty: String?
    @NSManaged public var educationLevel: String?
    @NSManaged public var id: String?
    @NSManaged public var isFavorite: Bool
    @NSManaged public var lastAttempted: Date?
    @NSManaged public var name: String?
    @NSManaged public var problemSetDescription: String?
    @NSManaged public var subject: String?
    @NSManaged public var tags: NSArray?
    @NSManaged public var title: String?
    @NSManaged public var questions: NSSet?

}

// MARK: Generated accessors for questions
extension CDProblemSet {

    @objc(addQuestionsObject:)
    @NSManaged public func addToQuestions(_ value: CDQuestion)

    @objc(removeQuestionsObject:)
    @NSManaged public func removeFromQuestions(_ value: CDQuestion)

    @objc(addQuestions:)
    @NSManaged public func addToQuestions(_ values: NSSet)

    @objc(removeQuestions:)
    @NSManaged public func removeFromQuestions(_ values: NSSet)

}

extension CDProblemSet : Identifiable {

}


## ./AISnapStudy/CoreData/CDQuestion+CoreDataProperties.swift



import Foundation
import CoreData


extension CDQuestion {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDQuestion> {
        return NSFetchRequest<CDQuestion>(entityName: "CDQuestion")
    }

    @NSManaged public var attribute: String?
    @NSManaged public var correctAnswer: String?
    @NSManaged public var createdAt: Date?
    @NSManaged public var explanation: String?
    @NSManaged public var hint: String?
    @NSManaged public var id: String?
    @NSManaged public var isCorrect: Bool
    @NSManaged public var isSaved: Bool
    @NSManaged public var options: NSObject?
    @NSManaged public var question: String?
    @NSManaged public var type: String?
    @NSManaged public var problemSet: CDProblemSet?
    @NSManaged public var session: CDStudySession?

}

extension CDQuestion : Identifiable {

}


## ./AISnapStudy/CoreData/CDStudySession+CoreDataProperties.swift

//
//  CDStudySession+CoreDataProperties.swift
//  AISnapStudy
//
//  Created by sunghwan ki on 11/10/24.
//
//

import Foundation
import CoreData


extension CDStudySession {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDStudySession> {
        return NSFetchRequest<CDStudySession>(entityName: "CDStudySession")
    }

    @NSManaged public var answers: NSObject?
    @NSManaged public var endTime: Date?
    @NSManaged public var id: String?
    @NSManaged public var score: Int16
    @NSManaged public var startTime: Date?
    @NSManaged public var problemSet: CDProblemSet?
    @NSManaged public var questions: NSSet?

}

// MARK: Generated accessors for questions
extension CDStudySession {

    @objc(addQuestionsObject:)
    @NSManaged public func addToQuestions(_ value: CDQuestion)

    @objc(removeQuestionsObject:)
    @NSManaged public func removeFromQuestions(_ value: CDQuestion)

    @objc(addQuestions:)
    @NSManaged public func addToQuestions(_ values: NSSet)

    @objc(removeQuestions:)
    @NSManaged public func removeFromQuestions(_ values: NSSet)

}

extension CDStudySession : Identifiable {

}


## ./AISnapStudy/CoreData/CDProblemSet+CoreDataClass.swift

//
//  CDProblemSet+CoreDataClass.swift
//  AISnapStudy
//
//  Created by sunghwan ki on 11/11/24.
//
//

import Foundation
import CoreData


public class CDProblemSet: NSManagedObject {

}


## ./AISnapStudy/Utils/Constants.swift


import SwiftUI

enum Constants {
    enum API {
        static let baseURL = "https://api.openai.com/v1"
        static let version = "v1"
    }
    
    enum UI {
        static let cornerRadius: CGFloat = 10
        static let spacing: CGFloat = 16
        static let padding: CGFloat = 20
    }
    
    enum Storage {
        static let problemSetsKey = "problemSets"
        static let savedQuestionsKey = "savedQuestions"
        static let userPreferencesKey = "userPreferences"
    }
}


## ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


## ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


## ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


## ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



## ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


## ./AISnapStudy/Utils/Helpers/ImageCompressor.swift

// Utils/Helpers/ImageCompressor.swift
import UIKit

enum ImageCompressorError: Error {
    case compressionFailed
    case invalidImage
}

class ImageCompressor {
    static let shared = ImageCompressor()
    
    private enum Constraints {
        // ÌååÏùº ÌÅ¨Í∏∞ Ï†úÌïúÏùÑ Îçî ÎÇÆÍ≤å ÏÑ§Ï†ï (400KBÎ°ú Ï§ÑÏûÑ)
        static let targetFileSize = 400 * 1024  // 400KB
        // ÏµúÎåÄ ÏπòÏàòÎ•º Îçî ÏûëÍ≤å ÏÑ§Ï†ï (800 -> 640)
        static let maxDimension: CGFloat = 640
        static let minDimension: CGFloat = 320
        // ÏµúÏÜå ÌíàÏßàÏùÑ ÎÇÆÏ∂§ (0.5 -> 0.3)
        static let minimumQuality: CGFloat = 0.3
    }
    
    private init() {}
    
    func compress(
        image: UIImage,
        maxSize: Int = Constraints.targetFileSize,
        maxDimension: CGFloat = Constraints.maxDimension
    ) throws -> Data {
        let startTime = Date()
        
        // ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ ÌÅ¨Í∏∞ Î°úÍπÖ
        if let originalData = image.jpegData(compressionQuality: 1.0) {
            print("üì∏ Original image size: \(formatFileSize(originalData.count))")
            print("üìê Original dimensions: \(Int(image.size.width))x\(Int(image.size.height))")
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ïßï
        let resizedImage = resizeImage(image, maxDimension: maxDimension)
        print("‚úÇÔ∏è Resized dimensions: \(Int(resizedImage.size.width))x\(Int(resizedImage.size.height))")
        
        // ÏïïÏ∂ï ÏãúÏûë ÌíàÏßàÏùÑ 0.6ÏóêÏÑú 0.3ÏúºÎ°ú ÎÇÆÏ∂§
        var compression: CGFloat = 0.3
        var compressedData = resizedImage.jpegData(compressionQuality: compression)!
        
        while compressedData.count > maxSize && compression > Constraints.minimumQuality {
            compression -= 0.1
            if let newData = resizedImage.jpegData(compressionQuality: compression) {
                compressedData = newData
                print("üîÑ Trying compression quality: \(String(format: "%.1f", compression))")
                print("üì¶ Current size: \(formatFileSize(compressedData.count))")
            }
        }
        
        if compressedData.count > maxSize {
            let scale = sqrt(Double(maxSize) / Double(compressedData.count))
            let newSize = CGSize(
                width: resizedImage.size.width * scale,
                height: resizedImage.size.height * scale
            )
            
            let finalImage = UIGraphicsImageRenderer(size: newSize).image { _ in
                resizedImage.draw(in: CGRect(origin: .zero, size: newSize))
            }
            
            compressedData = finalImage.jpegData(compressionQuality: compression) ?? compressedData
            print("üìê Final resize dimensions: \(Int(newSize.width))x\(Int(newSize.height))")
        }
        
        print("""
        ‚úÖ Compression completed:
        ‚Ä¢ Duration: \(String(format: "%.2f", Date().timeIntervalSince(startTime)))s
        ‚Ä¢ Final size: \(formatFileSize(compressedData.count))
        ‚Ä¢ Compression ratio: \(String(format: "%.1f", Float(compressedData.count) / Float(image.jpegData(compressionQuality: 1.0)?.count ?? 1) * 100))%
        """)
        
        return compressedData
    }

    
    private func resizeImage(_ image: UIImage, maxDimension: CGFloat) -> UIImage {
        let originalSize = image.size
        var targetSize = originalSize
        
        // ÏµúÏÜå/ÏµúÎåÄ ÌÅ¨Í∏∞ Ï†úÌïú Ï†ÅÏö©
        if originalSize.width > maxDimension || originalSize.height > maxDimension {
            let widthRatio = maxDimension / originalSize.width
            let heightRatio = maxDimension / originalSize.height
            let ratio = min(widthRatio, heightRatio)
            targetSize = CGSize(
                width: max(Constraints.minDimension, originalSize.width * ratio),
                height: max(Constraints.minDimension, originalSize.height * ratio)
            )
        }
        
        let format = UIGraphicsImageRendererFormat()
        format.scale = 1
        
        let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
        return renderer.image { context in
            image.draw(in: CGRect(origin: .zero, size: targetSize))
        }
    }
    
    private func formatFileSize(_ bytes: Int) -> String {
        return ByteCountFormatter.string(fromByteCount: Int64(bytes), countStyle: .file)
    }
}


## ./AISnapStudy/Utils/Helpers/ErrorHandler.swift

// Utils/Helpers/ErrorHandler.swift
import Foundation

enum AppError: Error {
    case networkError(String)
    case imageProcessingError(String)
    case storageError(String)
    case openAIError(String)
}

class ErrorHandler {
    static func handle(_ error: Error) {
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏóêÎü¨ Î°úÍπÖ, ÏÇ¨Ïö©Ïûê ÏïåÎ¶º Îì±ÏùÑ Ï≤òÎ¶¨
        print("Error occurred: \(error.localizedDescription)")
    }
}


## ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


## ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    let day: String          // "Mon", "Tue", etc.
    let questionsCompleted: Int
    let correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.day = date.formatted(.dateTime.weekday(.abbreviated))
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


## ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // Ï∂îÍ∞Ä: Structured OutputsÏùò refusal Ï≤òÎ¶¨Î•º ÏúÑÌï¥
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


## ./AISnapStudy/Models/ProblemSet.swift


import Foundation

public struct ProblemSet: Identifiable, Codable {
    public let id: String
    public let title: String
    public let subject: Subject
    public let difficulty: Difficulty
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    
    
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÌï† ÏÜçÏÑ±Îì§
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?
    public var isFavorite: Bool
    
    public var questionCount: Int {
        questions.count
    }
    
    public init(
          id: String,
          title: String,
          subject: Subject,
          difficulty: Difficulty,
          questions: [Question],
          createdAt: Date,
          lastAttempted: Date? = nil,
          educationLevel: EducationLevel,
          name: String,
          tags: [String] = [],
          problemSetDescription: String? = nil,
          isFavorite: Bool = false
      ) {
          self.id = id
          self.title = title
          self.subject = subject
          self.difficulty = difficulty
          self.questions = questions
          self.createdAt = createdAt
          self.lastAttempted = lastAttempted
          self.educationLevel = educationLevel
          self.name = name
          self.tags = tags
          self.problemSetDescription = problemSetDescription
          self.isFavorite = isFavorite
      }
}

// MARK: - Hashable
extension ProblemSet: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id
    }
}


## ./AISnapStudy/Models/HistoryFilter.swift


import Foundation

enum HistoryFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



## ./AISnapStudy/Models/User.swift


import Foundation

struct User: Codable, Identifiable {
    let id: String
    var name: String
    var email: String
    var preferences: UserPreferences
    var createdAt: Date
    var lastActive: Date
    
    struct UserPreferences: Codable {
        var isDarkMode: Bool
        var notificationsEnabled: Bool
        var dailyGoal: Int
        var preferredDifficulty: Difficulty
    }
}


## ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
    case multipleChoice = "multiple_choice"
    case fillInBlanks = "fill_in_blanks"
    case trueFalse = "true_false"  
}

public struct Question: Identifiable, Codable {
    public let id: String
    public let type: QuestionType
    public let subject: Subject
    public let difficulty: Difficulty
    public let question: String
    public let options: [String]
    public let correctAnswer: String
    public let explanation: String
    public let hint: String?
    public var isSaved: Bool
    public let createdAt: Date
    
    public init(
        id: String,
        type: QuestionType,
        subject: Subject,
        difficulty: Difficulty,
        question: String,
        options: [String] = [],
        correctAnswer: String,
        explanation: String,
        hint: String? = nil,
        isSaved: Bool = false,
        createdAt: Date = Date()
    ) {
        self.id = id
        self.type = type
        self.subject = subject
        self.difficulty = difficulty
        self.question = question
        self.options = options
        self.correctAnswer = correctAnswer
        self.explanation = explanation
        self.hint = hint
        self.isSaved = isSaved
        self.createdAt = createdAt
    }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
    public static var supportsSecureCoding: Bool {
        return true
    }
    
    let question: Question
    
    init(question: Question) {
        self.question = question
        super.init()
    }
    
    public func encode(with coder: NSCoder) {
        coder.encode(question.id, forKey: "id")
        coder.encode(question.type.rawValue, forKey: "type")
        coder.encode(question.subject.rawValue, forKey: "subject")
        coder.encode(question.difficulty.rawValue, forKey: "difficulty")
        coder.encode(question.question, forKey: "question")
        coder.encode(question.options, forKey: "options")
        coder.encode(question.correctAnswer, forKey: "correctAnswer")
        coder.encode(question.explanation, forKey: "explanation")
        coder.encode(question.hint, forKey: "hint")
        coder.encode(question.isSaved, forKey: "isSaved")
        coder.encode(question.createdAt, forKey: "createdAt")
    }
    
    public required init?(coder: NSCoder) {
        guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
              let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
              let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
              let difficultyRaw = coder.decodeObject(of: NSString.self, forKey: "difficulty") as String?,
              let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
              let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
              let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
              let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
            return nil
        }
        
        let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
        let isSaved = coder.decodeBool(forKey: "isSaved")
        let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
        
        let question = Question(
            id: id,
            type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
            subject: Subject(rawValue: subjectRaw) ?? .math,
            difficulty: Difficulty(rawValue: difficultyRaw) ?? .medium,
            question: questionText,
            options: options,
            correctAnswer: correctAnswer,
            explanation: explanation,
            hint: hint,
            isSaved: isSaved,
            createdAt: createdAt
        )
        
        self.question = question
        super.init()
    }
}

// MARK: - Hashable
extension Question: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
}


## ./AISnapStudy/Models/Subject.swift


import SwiftUI

public enum Subject: String, Codable, CaseIterable {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        }
    }
    
    public var displayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        }
    }
}

public enum EducationLevel: String, Codable, CaseIterable {
    case elementary = "elementary"
    case middle = "middle"
    case high = "high"
    case college = "college"
    
    public var displayName: String {
        switch self {
        case .elementary:
            return "Elementary"
        case .middle:
            return "Middle"
        case .high:
            return "High"
        case .college:
            return "College"
        }
    }
    
    public var color: Color {
        switch self {
        case .elementary:
            return .green
        case .middle:
            return .green
        case .high:
            return .green
        case .college:
            return .green
        }
    }
}

public enum Difficulty: String, Codable, CaseIterable {
    case easy = "easy"
    case medium = "medium"
    case hard = "hard"
    
    public var iconName: String {
            switch self {
            case .easy:
                return "1.circle.fill"
            case .medium:
                return "2.circle.fill"
            case .hard:
                return "3.circle.fill"
            }
        }
    
    public var color: Color {
        switch self {
        case .easy:
            return .green
        case .medium:
            return .green
        case .hard:
            return .green
        }
    }
    
    public var displayName: String {
        rawValue.capitalized
    }
    
    public var icon: String {
        switch self {
        case .easy:
            return "1.circle.fill"
        case .medium:
            return "2.circle.fill"
        case .hard:
            return "3.circle.fill"
        }
    }
    
    // ÎÇúÏù¥ÎèÑÎ•º Ïà´ÏûêÎ°ú ÌëúÌòÑ
    public var level: Int {
        switch self {
        case .easy: return 1
        case .medium: return 2
        case .hard: return 3
        }
    }
}


## ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Ï†ÄÏû• ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÎäî Î°úÏßÅ Ï∂îÍ∞Ä
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


## ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


## ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


## ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


## ./AISnapStudy/Views/Question/QuestionSettingsView.swift


// File: ./AISnapStudy/Views/Question/QuestionSettingsView.swift

import SwiftUI
import PhotosUI
import UIKit

import SwiftUI
import PhotosUI
import UIKit

struct QuestionSettingsView: View {
   let subject: Subject
    @StateObject private var viewModel: QuestionSettingsViewModel
   @Environment(\.dismiss) private var dismiss
   @Binding var selectedTab: Int
   @State private var expandedSections: Set<SectionType> = []
   @State private var isTextInputSelected = false
    @State private var showNamePopup = false
    @State private var isGeneratingQuestions = false
    @State private var problemSetName: String = ""
   
   enum SectionType {
       case learningSubject
       case educationLevel
       case difficultyLevel
       case questionTypes
   }
   
   init(subject: Subject,
        homeViewModel: HomeViewModel,
        selectedTab: Binding<Int>) {
       self.subject = subject
       self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
           subject: subject,
           homeViewModel: homeViewModel
       ))
       self._selectedTab = selectedTab
   }
   
   var body: some View {
       VStack(spacing: 0) {
           Form {
               // Question About Section
               Section {
                   DisclosureGroup(
                       isExpanded: .constant(true)
                   ) {
                       VStack(spacing: 16) {
                           HStack(spacing: 12) {
                               ImageOptionCard(
                                   icon: "camera.fill",
                                   isUsed: viewModel.hasSelectedCamera,
                                   isDisabled: !viewModel.canUseImageInput,
                                   action: {
                                       if viewModel.canUseImageInput {
                                           isTextInputSelected = false
                                           Task { await viewModel.takePhoto() }
                                       }
                                   }
                               )
                               
                               ImageOptionCard(
                                   icon: "photo.fill",
                                   isUsed: viewModel.hasSelectedGallery,
                                   isDisabled: !viewModel.canUseImageInput,
                                   action: {
                                       if viewModel.canUseImageInput {
                                           isTextInputSelected = false
                                           Task { await viewModel.selectFromGallery() }
                                       }
                                   }
                               )
                               
                               ImageOptionCard(
                                   icon: "text.bubble.fill",
                                   isUsed: viewModel.isTextInputActive,
                                   isDisabled: !viewModel.canUseTextInput,
                                   action: {
                                       isTextInputSelected.toggle()
                                       viewModel.toggleTextInput()
                                   }
                               )
                           }
                           .padding(.horizontal)
                           
                           if viewModel.isTextInputActive {
                               TextField("Enter your question here...", text: $viewModel.questionText)
                                   .textFieldStyle(RoundedBorderTextFieldStyle())
                           }
                           
                           if !viewModel.selectedImages.isEmpty {
                               ScrollView(.horizontal, showsIndicators: false) {
                                   HStack(spacing: 12) {
                                       ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                           SelectedImageCell(
                                               image: viewModel.selectedImages[index],
                                               onDelete: {
                                                   viewModel.removeImage(at: index)
                                               }
                                           )
                                       }
                                   }
                                   .padding(.vertical, 8)
                               }
                           }
                       }
                   } label: {
                       HStack {
                           Text("Question About")
                               .font(.headline)
                           Spacer()
                           if !viewModel.selectedImages.isEmpty {
                               Text("\(viewModel.selectedImages.count) selected")
                                   .foregroundColor(.green)
                           } else if !viewModel.questionText.isEmpty {
                               Text("Text input")
                                   .foregroundColor(.green)
                           }
                       }
                   }
               }.listRowSpacing(0)
               
               // Learning Subject Section
               Section {
                   DisclosureGroup(
                       isExpanded: isExpandedBinding(for: .learningSubject)
                   ) {
                       LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                   } label: {
                       HStack {
                           Text("Learning Subject")
                               .font(.headline)
                           Spacer()
                           Text(viewModel.selectedSubject.displayName)
                               .foregroundColor(.gray)
                       }
                   }
               }.listRowSpacing(0)
               
               // Question Types Section
               Section {
                   DisclosureGroup(
                       isExpanded: isExpandedBinding(for: .questionTypes)
                   ) {
                       QuestionTypesSelectionSection(viewModel: viewModel)
                   } label: {
                       HStack {
                           Text("Question Types")
                               .font(.headline)
                           Spacer()
                           Text("\(viewModel.totalQuestionCount) questions")
                               .foregroundColor(.gray)
                       }
                   }
               }.listRowSpacing(0)
               
               if isTextInputSelected {
                   // Education Level Section
                   Section {
                       DisclosureGroup(
                           isExpanded: isExpandedBinding(for: .educationLevel)
                       ) {
                           EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                       } label: {
                           HStack {
                               Text("Education Level")
                                   .font(.headline)
                               Spacer()
                               Text(viewModel.educationLevel.displayName)
                                   .foregroundColor(.gray)
                           }
                       }
                   }.listRowSpacing(0)
                   
                   // Difficulty Level Section
                   Section {
                       DisclosureGroup(
                           isExpanded: isExpandedBinding(for: .difficultyLevel)
                       ) {
                           DifficultyLevelSection(difficulty: $viewModel.difficulty)
                       } label: {
                           HStack {
                               Text("Difficulty Level")
                                   .font(.headline)
                               Spacer()
                               Text(viewModel.difficulty.displayName)
                                   .foregroundColor(.gray)
                           }
                       }
                   }.listRowSpacing(0)
               }
           }.listSectionSpacing(4)
           
           // Generate Questions Button
           VStack {
               Button(action: {
                       showNamePopup = true
                       isGeneratingQuestions = true
                       Task {
                           await viewModel.sendAllImages()
                       }
                   }) {
                   Text("Generate Questions")
                       .font(.headline)
                       .foregroundColor(.white)
                       .frame(maxWidth: .infinity)
                       .padding()
                       .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                       .cornerRadius(10)
               }
               .disabled(!isGenerateButtonEnabled)
               .padding()
           }
           .background(Color(UIColor.systemGroupedBackground))
       }
       .overlay {
                   if showNamePopup {
                       ProblemSetNamePopup(
                           isPresented: $showNamePopup,
                           problemSetName: $viewModel.problemSetName,
                           defaultName: viewModel.generateDefaultName()
                       ) {
                           showNamePopup = false
                       }
                       .transition(.opacity)
                       .animation(.easeInOut, value: showNamePopup)
                   }
               }
       .navigationBarItems(
           leading: Button("Cancel") {
               viewModel.resetCounts()
               dismiss()
           }
       )
       .navigationBarTitleDisplayMode(.inline)
       .sheet(isPresented: $viewModel.showImagePicker) {
           PhotoPicker(selectedImages: $viewModel.selectedImages)
       }
       .sheet(isPresented: $viewModel.showCamera) {
           ImagePicker(
               image: $viewModel.selectedImage,
               sourceType: .camera,
               onImageSelected: { image in
                   Task {
                       await viewModel.handleCameraImage(image)
                   }
               }
           )
       }
       .alert(isPresented: $viewModel.showAlert) {
           Alert(
               title: Text(viewModel.alertTitle),
               message: Text(viewModel.alertMessage),
               dismissButton: .default(Text("OK")) {
                   if viewModel.alertTitle == "Success" {
                       dismiss()
                   }
               }
           )
       }
       .onChange(of: viewModel.shouldShowStudyView) { show in
           if show {
               dismiss()
               selectedTab = 1  // Study ÌÉ≠ÏúºÎ°ú Ï†ÑÌôò
           }
       }
       .overlay(alignment: .bottom) {
           if viewModel.isLoading {
               LoadingView()
                   .frame(maxHeight: 120)  // LoadingViewÏùò ÎÜíÏù¥Î•º Ï†úÌïú
                   .background(Color.black.opacity(0.7))
                   .cornerRadius(10)
                   .padding()
           }
       }
   }
   
   private var isGenerateButtonEnabled: Bool {
       let hasInput = !viewModel.selectedImages.isEmpty ||
                     (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
       let hasQuestionType = viewModel.totalQuestionCount > 0
       return hasInput && hasQuestionType
   }
   
   private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
       Binding(
           get: { expandedSections.contains(section) },
           set: { isExpanded in
               withAnimation {
                   if isExpanded {
                       expandedSections.insert(section)
                   } else {
                       expandedSections.remove(section)
                   }
               }
           }
       )
   }
}
struct GeneratingQuestionsOverlay: View {
    let questionCount: Int
    @State private var animatingDots = false
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 16) {
                ProgressView()
                    .scaleEffect(1.5)
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                
                Text("Generating \(questionCount) questions\(dots)")
                    .font(.headline)
                    .foregroundColor(.white)
                
                Text("Please wait...")
                    .font(.subheadline)
                    .foregroundColor(.white.opacity(0.8))
            }
            .padding()
            .background(Color.black.opacity(0.6))
            .cornerRadius(10)
        }
        .onAppear {
            withAnimation(Animation.easeInOut(duration: 0.8).repeatForever()) {
                animatingDots.toggle()
            }
        }
    }
    
    private var dots: String {
        animatingDots ? "..." : ""
    }
}

struct ProblemSetNamePopup: View {
    @Binding var isPresented: Bool
    @Binding var problemSetName: String
    let defaultName: String
    let onSubmit: () -> Void
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 20) {
                Text("Name Your Question Set")
                    .font(.headline)
                
                TextField("Enter name", text: $problemSetName)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .placeholder(when: problemSetName.isEmpty) {
                        Text("Default: \(defaultName)")
                            .foregroundColor(.gray)
                    }
                
                Text("Questions are being generated...")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            .padding()
            .background(Color(UIColor.systemBackground))
            .cornerRadius(12)
            .padding(.horizontal, 40)
        }
    }
}

struct LearningSubjectSection: View {
   @Binding var selectedSubject: Subject
   
   let columns = [
       GridItem(.flexible()),
       GridItem(.flexible()),
       GridItem(.flexible())
   ]
   
   var body: some View {
       LazyVGrid(columns: columns, spacing: 12) {
           ForEach(Subject.allCases, id: \.self) { subject in
               SubjectSelectionButton(
                   subject: subject,
                   isSelected: selectedSubject == subject
               ) {
                   withAnimation(.spring()) {
                       selectedSubject = subject
                   }
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SubjectSelectionButton: View {
   let subject: Subject
   let isSelected: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 8) {
               Image(systemName: subject.icon)
                   .font(.system(size: 24))
               Text(subject.displayName)
                   .font(.caption)
                   .lineLimit(1)
                   .minimumScaleFactor(0.8)
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 12)
           .padding(.horizontal, 8)
           .background(
               RoundedRectangle(cornerRadius: 10)
                   .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
           )
           .foregroundColor(isSelected ? subject.color : .gray)
           .overlay(
               RoundedRectangle(cornerRadius: 10)
                   .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
           )
       }
       .buttonStyle(PlainButtonStyle())
   }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}

struct DifficultyLevelSection: View {
   @Binding var difficulty: Difficulty
   
   var body: some View {
       HStack(spacing: 12) {
           ForEach(Difficulty.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: difficulty == level,
                   color: level.color
               ) {
                   withAnimation(.spring()) {
                       difficulty = level
                   }
               }
           }
       }
       .padding(.vertical, 8)
   }
}


struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // Ï∂îÍ∞Ä
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSectionÎèÑ ÏàòÏ†ï
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // Ï¥ù Î¨∏Ï†ú Ïàò ÌëúÏãú
                HStack {
                    Text("Question Types")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/20")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Fill in Blanks",
                        icon: "square.and.pencil",
                        count: $viewModel.fillInBlanksCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Learning Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(Subject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject == subject
                        ) {
                            viewModel.selectedSubject = subject
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education Level") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}

// Difficulty Section
struct DifficultySection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Difficulty Level") {
            Picker("Difficulty", selection: $viewModel.difficulty) {
                ForEach(Difficulty.allCases, id: \.self) { difficulty in
                    Text(difficulty.rawValue.capitalized)
                        .tag(difficulty)
                }
            }
            .pickerStyle(.segmented)
        }
    }
}

// Question Types Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Question Types") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "Fill in the Blanks",
                    count: $viewModel.fillInBlanksCount
                )
                
            }
        }
    }
}


// ImagePicker, PhotoPicker, LoadingView ÎèÑ Ï∂îÍ∞Ä
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = 10
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)? // Ï∂îÍ∞Ä
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.sourceType = sourceType
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.image = image
                parent.onImageSelected?(image)  // ÏΩúÎ∞± Ìò∏Ï∂ú
                print("üì∏ Image captured successfully")
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            print("üì∏ Camera capture cancelled")
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

struct LoadingView: View {
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 16) {
                ProgressView()
                    .scaleEffect(1.5)
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                Text("Processing...")
                    .font(.headline)
                    .foregroundColor(.white)
            }
            .padding()
            .background(Color.black.opacity(0.6))
            .cornerRadius(10)
        }
    }
}







## ./AISnapStudy/Views/Question/FillInBlanksView.swift

import SwiftUI

struct FillInBlanksView: View {
    let question: Question
    @Binding var answer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            // Answer Input - ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ
            VStack(alignment: .leading, spacing: 8) {
                Text("Your Answer")
                    .font(.headline)
                    .foregroundColor(.secondary)
                
                TextEditor(text: Binding(
                    get: { answer ?? "" },
                    set: { answer = $0 }
                ))
                .font(.system(size: 18))
                .frame(minHeight: 30)  // ÏµúÏÜå ÎÜíÏù¥ ÏÑ§Ï†ï
                .padding(8)
                .background(RoundedRectangle(cornerRadius: 8)
                    .fill(Color(.systemBackground)))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                )
                .disabled(showExplanation)
            }

            
            // Answer Result (only show when submitted)
            if showExplanation {
                if let isCorrect = isCorrect {
                    HStack {
                        Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                            .foregroundColor(isCorrect ? .green : .red)
                        
                        Text(isCorrect ? "Correct!" : "Incorrect")
                            .foregroundColor(isCorrect ? .green : .red)
                            .fontWeight(.semibold)
                    }
                    .padding(.vertical, 4)
                    
                    // Show correct answer if wrong
                    if !isCorrect {
                        Text("Answer: \(question.correctAnswer)")
                            .font(.subheadline)
                            .foregroundColor(.blue)
                            .padding(.vertical, 4)
                    }
                }
            }
            
            // Explanation Section (only show when icon is clicked)
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        // ÏÉÅÌÉúÍ∞Ä Î¶¨ÏÖãÎê† Îïå ÏÑ§Î™Ö Ïà®Í∏∞Í∏∞
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}


## ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            VStack(alignment: .leading, spacing: 12) {
                TrueFalseButton(
                    title: "True",
                    isSelected: selectedAnswer == "true",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "true"
                }
                
                TrueFalseButton(
                    title: "False",
                    isSelected: selectedAnswer == "false",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "false"
                }
            }
            
            // Answer Result
            if showExplanation {
                HStack {
                    if let isCorrect = isCorrect {
                        HStack {
                            Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect ? .green : .red)
                            
                            Text(isCorrect ? "Correct!" : "Incorrect")
                                .foregroundColor(isCorrect ? .green : .red)
                                .fontWeight(.semibold)
                        }
                        .padding(.vertical, 4)
                        
                        Spacer()
                        
                    }
                }
                
                // Show correct answer if wrong
                if let isCorrect = isCorrect, !isCorrect {
                    Text("Answer: \(question.correctAnswer)")
                        .font(.subheadline)
                        .foregroundColor(.blue)
                        .padding(.vertical, 4)
                }
            }
            
            // Explanation Section
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}

// TrueFalseButton Íµ¨Ï°∞Ï≤¥Îäî Î≥ÄÍ≤Ω ÏóÜÏùå
struct TrueFalseButton: View {
    let title: String
    let isSelected: Bool
    let disabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .disabled(disabled)
    }
}


## ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            ForEach(question.options, id: \.self) { option in
                Button(action: { selectedAnswer = option }) {
                    HStack {
                        Text(option)
                            .font(.body)
                            .multilineTextAlignment(.leading)
                            .foregroundColor(getTextColor(for: option))
                        Spacer()
                        if selectedAnswer == option && showExplanation {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                                .transition(.scale.combined(with: .opacity))
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .fill(getBackgroundColor(for: option))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 10)
                            .stroke(getBorderColor(for: option), lineWidth: 2)
                    )
                }
                .disabled(showExplanation)
            }
        }
        .padding()
        .animation(.easeInOut(duration: 0.3), value: selectedAnswer)
        .animation(.easeInOut(duration: 0.3), value: showExplanation)
        .animation(.easeInOut(duration: 0.3), value: isCorrect)
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.1)  // ÏÑ†ÌÉùÌñàÏùÑ Îïå ÌååÎûÄÏÉâ
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.1)  // Ï†úÏ∂ú ÌõÑ
            }
        }
        return Color.gray.opacity(0.05)
    }
    
    private func getBorderColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue  // ÏÑ†ÌÉùÌñàÏùÑ Îïå ÌååÎûÄÏÉâ
            } else {
                return isCorrect == true ? .green : .red  // Ï†úÏ∂ú ÌõÑ
            }
        }
        return .clear
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue  // ÏÑ†ÌÉùÌñàÏùÑ Îïå ÌååÎûÄÏÉâ
            } else {
                return isCorrect == true ? .green : .red  // Ï†úÏ∂ú ÌõÑ
            }
        }
        return .primary
    }
}


## ./AISnapStudy/Views/Components/DifficultySelector.swift


import SwiftUI

struct DifficultySelector: View {
    @Binding var selectedDifficulty: Difficulty
    
    var body: some View {
        HStack(spacing: 12) {
            ForEach(Difficulty.allCases, id: \.self) { difficulty in
                DifficultyButton(
                    difficulty: difficulty,
                    isSelected: selectedDifficulty == difficulty,
                    action: { selectedDifficulty = difficulty }
                )
            }
        }
        .padding(.horizontal)
    }
}

// Î≥ÑÎèÑÏùò Î≤ÑÌäº Ïª¥Ìè¨ÎÑåÌä∏Î°ú Î∂ÑÎ¶¨
private struct DifficultyButton: View {
    let difficulty: Difficulty
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack {
                Image(systemName: difficulty.iconName)
                    .font(.system(size: 24))
                Text(difficulty.displayName)
                    .font(.caption)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .background(backgroundColor)
            .foregroundColor(foregroundColor)
        }
    }
    
    private var backgroundColor: some View {
        RoundedRectangle(cornerRadius: 10)
            .fill(isSelected ? Color.accentColor : Color.secondaryBackground)
    }
    
    private var foregroundColor: Color {
        isSelected ? .white : .primary
    }
}



## ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // ÏÉÅÎã® Ìó§Îçî
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                    Text(problemSet.title.isEmpty ? "No Title" : problemSet.title)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // ÌÉúÍ∑∏ Î™©Î°ù (ÏûëÍ≥† Í∞ÑÍ≤∞ÌïòÍ≤å)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // ÏµúÎåÄ 3Í∞úÏùò ÌÉúÍ∑∏Îßå ÌëúÏãú
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // Ï†ïÎ≥¥ Í∑∏Î¶¨Îìú
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
                InfoRow(title: "Difficulty", value: problemSet.difficulty.rawValue)
            }
            .font(.footnote)
            
            // ÏÑ§Î™Ö (Îçî ÏßßÍ≤å)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



## ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


## ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search history...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


## ./AISnapStudy/Views/Components/HistoryCard.swift



import SwiftUI

struct HistoryCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(session.problemSet.title)
                    .font(.headline)
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


## ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
                
                Text(question.difficulty.rawValue.capitalized)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


## ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


## ./AISnapStudy/Views/Components/ImageSelectionSection.swift

// File: ./AISnapStudy/Views/Components/ImageSelectionSection.swift

import SwiftUI
import PhotosUI
import UIKit


struct ImageSelectionSection: View {
   @ObservedObject var viewModel: QuestionSettingsViewModel
   @FocusState private var isTextFieldFocused: Bool
   @State private var keyboardHeight: CGFloat = 0
   
   var body: some View {
       Section {
           DisclosureGroup(
               isExpanded: .constant(true),
               content: {
                   VStack(spacing: 16) {
                       // Input Type Selection Buttons
                       HStack(spacing: 12) {
                           // Camera Button
                           ImageOptionCard(
                               icon: "camera.fill",
                               isUsed: viewModel.hasSelectedCamera,
                               isDisabled: !viewModel.canUseImageInput,
                               action: {
                                   if viewModel.canUseImageInput {
                                       viewModel.isTextInputActive = false
                                       isTextFieldFocused = false
                                       viewModel.onImageOptionSelected()
                                       Task {
                                           await viewModel.takePhoto()
                                       }
                                   }
                               }
                           )
                           .frame(maxWidth: .infinity)
                           
                           // Gallery Button
                           ImageOptionCard(
                               icon: "photo.fill",
                               isUsed: viewModel.hasSelectedGallery,
                               isDisabled: !viewModel.canUseImageInput,
                               action: {
                                   if viewModel.canUseImageInput {
                                       viewModel.isTextInputActive = false
                                       isTextFieldFocused = false
                                       viewModel.onImageOptionSelected()
                                       Task {
                                           await viewModel.selectFromGallery()
                                       }
                                   }
                               }
                           )
                           .frame(maxWidth: .infinity)
                           
                           // Text Input Button
                           ImageOptionCard(
                               icon: "text.bubble.fill",
                               isUsed: viewModel.isTextInputActive,
                               isDisabled: !viewModel.canUseTextInput,
                               action: {
                                   if viewModel.canUseTextInput {
                                       viewModel.onImageOptionSelected()
                                       viewModel.toggleTextInput()
                                       if viewModel.isTextInputActive {
                                           DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                               isTextFieldFocused = true
                                           }
                                       } else {
                                           isTextFieldFocused = false
                                       }
                                   }
                               }
                           )
                           .frame(maxWidth: .infinity)
                       }
                       .padding(.horizontal)
                       
                       // Text Input Field and Generate Button
                       if viewModel.isTextInputActive {
                           VStack(spacing: 12) {
                               TextField("Enter your question here...", text: $viewModel.questionText)
                                   .textFieldStyle(RoundedBorderTextFieldStyle())
                                   .focused($isTextFieldFocused)
                                   .onChange(of: viewModel.questionText) { newValue in
                                       let trimmed = newValue.trimmingCharacters(in: .whitespacesAndNewlines)
                                       viewModel.isUsingTextInput = !trimmed.isEmpty
                                   }
                               
                               // Generate Button for Text Input
                               if !viewModel.questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                                   Button {
                                       print("üîµ Generate Questions Button Tapped (Text Input)")
                                       isTextFieldFocused = false
                                       Task {
                                           print("üìù Starting question generation from text")
                                           await viewModel.sendAllImages()
                                       }
                                   } label: {
                                       HStack {
                                           Spacer()
                                           Image(systemName: "sparkles")
                                           Text("Generate Questions")
                                               .fontWeight(.semibold)
                                           Spacer()
                                       }
                                       .font(.headline)
                                       .foregroundColor(.white)
                                       .padding()
                                       .background(
                                           RoundedRectangle(cornerRadius: 12)
                                               .fill(viewModel.isLoading ? Color.gray : Color.green)
                                       )
                                       .animation(.easeInOut, value: viewModel.isLoading)
                                   }
                                   .buttonStyle(BorderlessButtonStyle())
                                   .disabled(viewModel.isLoading)
                               }
                           }
                           .padding(.horizontal)
                           .padding(.bottom, keyboardHeight > 0 ? keyboardHeight + 20 : 0)
                           .animation(.easeOut, value: keyboardHeight)
                       }
                       
                       // Selected Images Display
                       if !viewModel.selectedImages.isEmpty {
                           VStack(alignment: .leading, spacing: 12) {
                               ScrollView(.horizontal, showsIndicators: false) {
                                   HStack(spacing: 12) {
                                       ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                           SelectedImageCell(
                                               image: viewModel.selectedImages[index],
                                               onDelete: {
                                                   viewModel.removeImage(at: index)
                                               }
                                           )
                                       }
                                   }
                                   .padding(.horizontal)
                               }
                               
                               // Generate Button for Images
                               Button {
                                   print("üîµ Generate Questions Button Tapped (Images)")
                                   Task { @MainActor in
                                       print("üìù Starting question generation from images")
                                       print("‚Ä¢ Number of images: \(viewModel.selectedImages.count)")
                                       
                                       viewModel.isLoading = true
                                       
                                       do {
                                           await viewModel.sendAllImages()
                                       } catch {
                                           print("‚ùå Error generating questions: \(error)")
                                       }
                                       
                                       viewModel.isLoading = false
                                   }
                               } label: {
                                   HStack {
                                       Spacer()
                                       Image(systemName: "sparkles")
                                       Text("Generate Questions")
                                           .fontWeight(.semibold)
                                       Spacer()
                                   }
                                   .font(.headline)
                                   .foregroundColor(.white)
                                   .padding()
                                   .background(
                                       RoundedRectangle(cornerRadius: 12)
                                           .fill(viewModel.isLoading ? Color.gray : Color.green)
                                   )
                                   .animation(.easeInOut, value: viewModel.isLoading)
                               }
                               .buttonStyle(BorderlessButtonStyle())
                               .disabled(viewModel.isLoading)
                               .padding(.horizontal)
                           }
                       }
                   }
                   .padding(.vertical, 8)
               },
               label: {
                   HStack {
                       Text("Question About")
                           .font(.headline)
                       Spacer()
                       if !viewModel.selectedImages.isEmpty {
                           Text("\(viewModel.selectedImages.count) selected")
                               .foregroundColor(viewModel.selectedImages.isEmpty ? .gray : .green)
                       } else if !viewModel.questionText.isEmpty {
                           Text("Text input")
                               .foregroundColor(.green)
                       }
                   }
               }
           )
       }
       .onTapGesture {
           isTextFieldFocused = false
       }
       .onAppear {
           NotificationCenter.default.addObserver(
               forName: UIResponder.keyboardWillShowNotification,
               object: nil,
               queue: .main
           ) { notification in
               if let keyboardFrame = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect {
                   self.keyboardHeight = keyboardFrame.height
               }
           }
           
           NotificationCenter.default.addObserver(
               forName: UIResponder.keyboardWillHideNotification,
               object: nil,
               queue: .main
           ) { _ in
               self.keyboardHeight = 0
           }
       }
   }
}

// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
    let icon: String
    let isUsed: Bool
    let isDisabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 12) {
                Image(systemName: icon)
                    .font(.system(size: 30))
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 20)
            .foregroundColor(foregroundColor)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(backgroundColor)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(strokeColor, lineWidth: 1)
            )
        }
        .disabled(isDisabled)
        .buttonStyle(PlainButtonStyle())
    }
    
    private var foregroundColor: Color {
        if isDisabled {
            return .gray.opacity(0.5)
        }
        return isUsed ? .green : .gray
    }
    
    private var backgroundColor: Color {
        if isDisabled {
            return Color.gray.opacity(0.1)
        }
        return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
    }
    
    private var strokeColor: Color {
        if isDisabled {
            return .clear
        }
        return isUsed ? Color.green.opacity(0.2) : .clear
    }
}

struct SelectedImageCell: View {
   let image: UIImage
   let onDelete: () -> Void
   
   var body: some View {
       ZStack(alignment: .topTrailing) {
           Image(uiImage: image)
               .resizable()
               .scaledToFill()
               .frame(width: 100, height: 100)
               .clipShape(RoundedRectangle(cornerRadius: 12))
               .overlay(
                   RoundedRectangle(cornerRadius: 12)
                       .stroke(Color.gray.opacity(0.2), lineWidth: 1)
               )
           
           Button(action: onDelete) {
               Image(systemName: "xmark.circle.fill")
                   .font(.system(size: 22))
                   .foregroundColor(.white)
                   .background(
                       Circle()
                           .fill(Color.black.opacity(0.5))
                           .frame(width: 24, height: 24)
                   )
           }
           .offset(x: 6, y: -6)
       }
   }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


## ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


## ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Subject and Difficulty Tags
            HStack {
                Text(question.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .foregroundColor(question.subject.color)
                    .cornerRadius(8)
                
                Spacer()
                
                Text(question.difficulty.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.difficulty.color.opacity(0.2))
                    .foregroundColor(question.difficulty.color)
                    .cornerRadius(8)
            }
            
            // Question Type
            Text(question.type.rawValue.replacingOccurrences(of: "_", with: " ").capitalized)
                .font(.caption)
                .foregroundColor(.secondary)
            
            // Question Text
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .padding(.vertical, 4)
            
            // Footer
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Image(systemName: "arrow.right.circle.fill")
                    .foregroundColor(.blue)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2)
        )
    }
}

#Preview {
    SavedQuestionCard(question: Question(
        id: UUID().uuidString,
        type: .multipleChoice,
        subject: .math,
        difficulty: .medium,
        question: "Sample Question",
        options: ["A", "B", "C", "D"],
        correctAnswer: "A",
        explanation: "Sample explanation",
        hint: "Sample hint",
        isSaved: true,
        createdAt: Date()
    ))
    .padding()
}


## ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


## ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // Í∞Å Î≤ÑÌäºÏóê ÎåÄÌïú Î≥ÑÎèÑÏùò Ïï°ÏÖò Ï†ïÏùò
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // Ï§ëÏöî: Î≤ÑÌäº Ïä§ÌÉÄÏùº Î∂ÑÎ¶¨
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // Ï§ëÏöî: Î≤ÑÌäº Ïä§ÌÉÄÏùº Î∂ÑÎ¶¨
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


## ./AISnapStudy/Views/Components/HistoryProblemSetCard.swift

import SwiftUI

struct HistoryProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                    .font(.headline)
                    .foregroundColor(.primary)
                Text(problemSet.title.isEmpty ? "No Title" : problemSet.title)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
            if problemSet.isFavorite {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
            }
        }
        .padding(10)
        .background(RoundedRectangle(cornerRadius: 8)
                        .fill(Color(UIColor.systemBackground))
                        .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1))
        .padding(.vertical, 4)
    }
}


## ./AISnapStudy/Views/Profile/EditProfileView.swift



import SwiftUI

struct EditProfileView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = EditProfileViewModel()
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    TextField("Name", text: $viewModel.name)
                        .textContentType(.name)
                    
                    TextField("Email", text: $viewModel.email)
                        .textContentType(.emailAddress)
                        .keyboardType(.emailAddress)
                }
                
                Section {
                    Button(action: viewModel.changePassword) {
                        Text("Change Password")
                    }
                }
            }
            .navigationTitle("Edit Profile")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        Task {
                            await viewModel.saveChanges()
                            dismiss()
                        }
                    }
                    .disabled(!viewModel.hasChanges)
                }
            }
        }
    }
}

class EditProfileViewModel: ObservableObject {
    @Published var name: String = ""
    @Published var email: String = ""
    private var originalName: String = ""
    private var originalEmail: String = ""
    
    var hasChanges: Bool {
        name != originalName || email != originalEmail
    }
    
    init() {
        // Ïã§Ï†ú Ïï±ÏóêÏÑúÎäî ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìú
        let currentUser = User(
            id: "1",
            name: "Test User",
            email: "test@example.com",
            preferences: User.UserPreferences(
                isDarkMode: false,
                notificationsEnabled: true,
                dailyGoal: 5,
                preferredDifficulty: .medium
            ),
            createdAt: Date(),
            lastActive: Date()
        )
        
        self.name = currentUser.name
        self.email = currentUser.email
        self.originalName = currentUser.name
        self.originalEmail = currentUser.email
    }
    
    func changePassword() {
        // ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω Î°úÏßÅ Íµ¨ÌòÑ
    }
    
    func saveChanges() async {
        // ÌîÑÎ°úÌïÑ Î≥ÄÍ≤Ω Ï†ÄÏû• Î°úÏßÅ Íµ¨ÌòÑ
    }
}


## ./AISnapStudy/Views/Profile/StudyPreferencesView.swift


import SwiftUI

struct StudyPreferencesView: View {
    @StateObject private var viewModel = StudyPreferencesViewModel()
    
    var body: some View {
        Form {
            Section(header: Text("Daily Goals")) {
                Stepper("Questions per day: \(viewModel.dailyGoal)",
                        value: $viewModel.dailyGoal, in: 1...20)
            }
            
            Section(header: Text("Preferred Difficulty")) {
                Picker("Default Difficulty", selection: $viewModel.preferredDifficulty) {
                    ForEach(Difficulty.allCases, id: \.self) { difficulty in
                        Text(difficulty.displayName)
                            .tag(difficulty)
                    }
                }
                .pickerStyle(.segmented)
            }
            
            Section(header: Text("Study Reminders")) {
                Toggle("Daily Reminder", isOn: $viewModel.dailyReminder)
                if viewModel.dailyReminder {
                    DatePicker("Reminder Time",
                              selection: $viewModel.reminderTime,
                              displayedComponents: .hourAndMinute)
                }
            }
        }
        .navigationTitle("Study Preferences")
    }
}

class StudyPreferencesViewModel: ObservableObject {
    @Published var dailyGoal: Int = UserDefaults.standard.integer(forKey: "dailyGoal") {
        didSet {
            UserDefaults.standard.set(dailyGoal, forKey: "dailyGoal")
        }
    }
    
    @Published var preferredDifficulty: Difficulty = Difficulty(rawValue:
        UserDefaults.standard.string(forKey: "preferredDifficulty") ?? "medium"
    ) ?? .medium {
        didSet {
            UserDefaults.standard.set(preferredDifficulty.rawValue, forKey: "preferredDifficulty")
        }
    }
    
    @Published var dailyReminder: Bool = UserDefaults.standard.bool(forKey: "dailyReminder") {
        didSet {
            UserDefaults.standard.set(dailyReminder, forKey: "dailyReminder")
        }
    }
    
    @Published var reminderTime: Date = Date(timeIntervalSince1970:
        UserDefaults.standard.double(forKey: "reminderTime")
    ) {
        didSet {
            UserDefaults.standard.set(reminderTime.timeIntervalSince1970, forKey: "reminderTime")
        }
    }
}



## ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @StateObject private var studyViewModel: StudyViewModel
    @State private var selectedTab = 0
    @StateObject private var statViewModel: StatViewModel
    
    
    init() {
        let homeVM = HomeViewModel.shared
        
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        
        // StudyViewModel Ï¥àÍ∏∞Ìôî ÏãúÏ†ê Î≥ÄÍ≤Ω
        let studyVM = StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        )
        self._studyViewModel = StateObject(wrappedValue: studyVM)
        
        // StatViewModelÎèÑ studyViewModel Ï∞∏Ï°∞ Ï∂îÍ∞Ä
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
             context: CoreDataService.shared.viewContext,
             homeViewModel: homeVM,  // homeViewModel Ï†ÑÎã¨
             studyViewModel: studyVM // studyViewModel Ï†ÑÎã¨
         ))
        
        
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
        
        // homeViewModelÏóê studyViewModel ÏÑ§Ï†ï
        homeVM.setStudyViewModel(studyVM)
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            if let problemSet = homeViewModel.selectedProblemSet {
                StudyView(
                    questions: problemSet.questions,
                    studyViewModel: studyViewModel,
                    selectedTab: $selectedTab
                )
                .tabItem {
                    Label("Study", systemImage: "book.fill")
                }
                .tag(1)
            } else {
                Text("No Problem Set Selected")
                    .tabItem {
                        Label("Study", systemImage: "book.fill")
                    }
                    .tag(1)
            }
            
            HistoryView()
                .tabItem {
                    Label("History", systemImage: "clock.fill")
                }
                .tag(2)
            
            StatView(
                correctAnswers: homeViewModel.correctAnswers,
                totalQuestions: homeViewModel.totalQuestions,
                viewModel: statViewModel,
                selectedTab: $selectedTab
            )
            .tabItem {
                Label("Stats", systemImage: "chart.bar.fill")
            }
            .tag(3)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { _ in
            if selectedTab == 1 {
                if let problemSet = homeViewModel.selectedProblemSet {
                    studyViewModel.loadQuestions(problemSet.questions)
                }
            }
        }
        .environmentObject(homeViewModel)
    }
}


## ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData

struct StatView: View {
    @ObservedObject var viewModel: StatViewModel // Change to ObservedObject
    @Binding var selectedTab: Int
    let correctAnswers: Int
    let totalQuestions: Int
    
 
    @EnvironmentObject private var homeViewModel: HomeViewModel

    
    init(correctAnswers: Int,
         totalQuestions: Int,
         viewModel: StatViewModel, // Pass viewModel directly
         selectedTab: Binding<Int>) {
        self.correctAnswers = correctAnswers
        self.totalQuestions = totalQuestions
        self.viewModel = viewModel // Direct assignment without StateObject
        self._selectedTab = selectedTab
    }
    
    var body: some View {
            ScrollView {
                VStack(spacing: 20) {
                    Text("ÌïôÏäµ ÌÜµÍ≥Ñ")
                        .font(.title)
                        .padding(.top)
                    
                    // ÌòÑÏû¨ Ïä§Ìä∏Î¶≠
                    HStack {
                        VStack(alignment: .leading) {
                            Text("ÌòÑÏû¨ Ïä§Ìä∏Î¶≠")
                                .font(.headline)
                            Text("\(viewModel.streak)Ïùº")
                                .font(.title)
                                .foregroundColor(.blue)
                        }
                        Spacer()
                        Image(systemName: "flame.fill")
                            .font(.system(size: 40))
                            .foregroundColor(.orange)
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(10)
                    
                    // ÌÜµÍ≥Ñ Í∑∏Î¶¨Îìú
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 20) {
                        StatCard(title: "Ï¥ù Ï†êÏàò", value: "\(viewModel.totalPoints)Ï†ê", icon: "star.fill", color: .yellow)
                        StatCard(title: "ÏôÑÎ£åÌïú Î¨∏Ï†ú", value: "\(viewModel.completedQuestions)Í∞ú", icon: "checkmark.circle.fill", color: .green)
                        StatCard(title: "Ï†ïÎãµÎ•†", value: String(format: "%.1f%%", viewModel.accuracyRate), icon: "percent", color: .blue)
                        StatCard(title: "Ï†ïÎãµ Ïàò", value: "\(viewModel.correctAnswers)Í∞ú", icon: "target", color: .red)
                    }
                    .padding()
                    
                    // Îã§Ïãú ÌíÄÍ∏∞ Î≤ÑÌäº
                    Button(action: {
                        // Î®ºÏ†Ä ÏÉÅÌÉú Î¶¨ÏÖã
                        viewModel.resetProgress()
                        
                        // Study ViewÎ°ú Ï†ÑÌôòÌïòÍ∏∞ ÏßÅÏ†Ñ ÏÉÅÌÉú ÌôïÏù∏ÏùÑ ÏúÑÌï¥ viewModelÏóêÏÑú Î°úÍ∑∏ Ï∂úÎ†•
                        viewModel.logCurrentQuestionState()

                        // Î∞îÎ°ú Study ÌÉ≠ÏúºÎ°ú Ïù¥Îèô
                        withAnimation {
                            selectedTab = 1
                        }
                    }) {
                        Text("Îã§Ïãú ÌíÄÍ∏∞")
                            .font(.headline)
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(10)
                    }
                    .padding()
                }
            }
        }
    }


## ./AISnapStudy/Views/Main/ProfileView.swift


import SwiftUI

struct ProfileView: View {
    @State private var showingEditProfile = false
    @StateObject private var viewModel = ProfileViewModel()
    
    var body: some View {
        NavigationView {
            List {
                // Profile Section
                Section {
                    HStack {
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .frame(width: 60, height: 60)
                            .foregroundColor(.accentColor)
                        
                        VStack(alignment: .leading) {
                            Text(viewModel.user.name)
                                .font(.headline)
                            Text(viewModel.user.email)
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding(.vertical, 8)
                }
                
                // Settings Section
                Section("Settings") {
                    Toggle("Dark Mode", isOn: $viewModel.isDarkMode)
                    Toggle("Notifications", isOn: $viewModel.notificationsEnabled)
                    
                    NavigationLink("Study Preferences") {
                        StudyPreferencesView()
                    }
                }
                
                // App Info Section
                Section("App Info") {
                    HStack {
                        Text("Version")
                        Spacer()
                        Text(Bundle.main.appVersion)
                            .foregroundColor(.secondary)
                    }
                    
                    Button("Terms of Service") {
                        viewModel.showTerms()
                    }
                    
                    Button("Privacy Policy") {
                        viewModel.showPrivacyPolicy()
                    }
                }
                
                // Account Actions
                Section {
                    Button("Sign Out", role: .destructive) {
                        viewModel.signOut()
                    }
                }
            }
            .navigationTitle("Profile")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Edit") {
                        showingEditProfile = true
                    }
                }
            }
            .sheet(isPresented: $showingEditProfile) {
                EditProfileView()
            }
        }
    }
}


## ./AISnapStudy/Views/Main/HomeView.swift

// File: ./AISnapStudy/Views/Main/HomeView.swift

import SwiftUI
import Combine
import CoreData

struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Environment(\.managedObjectContext) private var context
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var selectedSubject: Subject = .math
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Create New Questions Button
                    MainActionButton(
                        title: "Create New Questions",
                        icon: "plus.circle.fill"
                    ) {
                        selectedSubject = .math // Default subject
                        showQuestionSettings = true
                    }
                    
                    // Review Questions Button
                    MainActionButton(
                        title: "Review Questions",
                        icon: "book.fill"
                    ) {
                        if let problemSet = viewModel.selectedProblemSet {
                            viewModel.setSelectedProblemSet(problemSet)
                            selectedTab = 1
                        }
                    }
                    .disabled(viewModel.selectedProblemSet == nil)
                    .opacity(viewModel.selectedProblemSet == nil ? 0.5 : 1)
                }
                .padding(.horizontal)
                .padding(.vertical, 32)
            }
            .navigationTitle("Home")
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab  // selectedTab Î∞îÏù∏Îî© Ï†ÑÎã¨
            )
        }
    }
}


## ./AISnapStudy/Views/Main/HistoryView.swift

import SwiftUI

struct HistoryView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var viewModel: HistoryViewModel
    @State private var searchText = ""
    
    init() {
        let vm = HistoryViewModel(homeViewModel: HomeViewModel.shared)
        self._viewModel = StateObject(wrappedValue: vm)
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                SearchBar(text: $searchText)
                    .padding(.horizontal)
                
                List {
                    // Saved Questions Section
                    Section(header: Text("Saved Questions")) {
                        NavigationLink(
                            destination: SavedQuestionsView(
                                questions: viewModel.savedQuestions,
                                homeViewModel: homeViewModel
                            )
                        ) {
                            HStack {
                                Image(systemName: "bookmark.fill")
                                    .foregroundColor(.blue)
                                Text("Saved Questions")
                                    .font(.headline)
                                Spacer()
                                Text("\(viewModel.savedQuestions.count)")
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    
                    // Subject folders
                    ForEach(Subject.allCases, id: \.self) { subject in
                        NavigationLink(
                            destination: ProblemSetsListView(
                                subject: subject,
                                problemSets: filteredAndSortedProblemSets(for: subject)
                            )
                        ) {
                            HStack {
                                Image(systemName: "folder.fill")
                                    .foregroundColor(.blue)
                                Text(subject.displayName)
                                    .font(.headline)
                                    .padding(.leading, 8)
                            }
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())
                .navigationTitle("History")
                .navigationBarTitleDisplayMode(.inline)  // Ïù¥ Ï§ÑÏùÑ Ï∂îÍ∞Ä
                .refreshable {
                    viewModel.refreshData()
                }
            }
        }
        .onAppear {
                    viewModel.setHomeViewModel(homeViewModel)
                }
    }
    
    var problemSets: [ProblemSet] {
        homeViewModel.problemSets
    }
    
    // SubjectÎ≥ÑÎ°ú Problem Sets ÌïÑÌÑ∞ÎßÅ Î∞è Ï†ïÎ†¨ÌïòÎäî Î©îÏÑúÎìú
    private func filteredAndSortedProblemSets(for subject: Subject) -> [ProblemSet] {
        return viewModel.problemSets
            .filter { $0.subject == subject }
            .sorted(by: { $0.createdAt > $1.createdAt })
    }
}

struct SavedQuestionsView: View {
    let questions: [Question]
    let homeViewModel: HomeViewModel
    @State private var showStudyView = false
    
    var body: some View {
        List(questions) { question in
            SavedQuestionCard(question: question)
                .onTapGesture {
                    // Create a temporary ProblemSet for the saved question
                    let problemSet = ProblemSet(
                        id: UUID().uuidString,
                        title: "Saved Question",
                        subject: question.subject,
                        difficulty: question.difficulty,
                        questions: [question],
                        createdAt: Date(),
                        educationLevel: .elementary,
                        name: "Saved Question Practice"
                    )
                    homeViewModel.setSelectedProblemSet(problemSet)
                    showStudyView = true
                }
        }
        .navigationTitle("Saved Questions")
        .background(
            NavigationLink(
                isActive: $showStudyView,
                destination: {
                    if let studyViewModel = homeViewModel.studyViewModel {
                        StudyView(
                            questions: [questions[0]],
                            studyViewModel: studyViewModel,
                            selectedTab: .constant(1)
                        )
                    }
                },
                label: { EmptyView() }
            )
        )
    }
}

struct ProblemSetsListView: View {
    let subject: Subject
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var isShowingStudyView = false
    
    var body: some View {
        List(problemSets) { problemSet in
            Button(action: {
                homeViewModel.setSelectedProblemSet(problemSet)
                isShowingStudyView = true
            }) {
                HistoryProblemSetCard(problemSet: problemSet)
            }
            .background(
                NavigationLink(
                    isActive: $isShowingStudyView,
                    destination: {
                        guard let studyViewModel = homeViewModel.studyViewModel else {
                            return AnyView(Text("Study ViewModel not available"))
                        }
                        return AnyView(
                            StudyView(
                                questions: problemSet.questions,
                                studyViewModel: studyViewModel,
                                selectedTab: .constant(1)
                            )
                        )
                    }
                ) { EmptyView() }
                .hidden()
            )
        }
        .navigationTitle("\(subject.displayName) Sets")
        .listStyle(InsetGroupedListStyle())
    }
}


## ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
   @State private var isCorrect: Bool? = nil
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // Ï∂îÍ∞Ä
   @State private var previewIsCorrect: Bool? = nil        // Ï∂îÍ∞Ä
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
   var body: some View {
       VStack {
           // ÏßàÎ¨∏ ÏÉùÏÑ±Ï§ëÏùº ÎïåÏùò Î∑∞
           if studyViewModel.isGeneratingQuestions {
               VStack(spacing: 16) {
                   ProgressView(value: Double(studyViewModel.generatedQuestionCount),
                              total: Double(studyViewModel.totalExpectedQuestions)) {
                       Text("Generating Questions...")
                           .font(.headline)
                   }
                   .progressViewStyle(.linear)
                   .padding()
                   
                   Text("\(studyViewModel.generatedQuestionCount) / \(studyViewModel.totalExpectedQuestions)")
                       .font(.subheadline)
                       .foregroundColor(.secondary)
                   
                   // ÏÉùÏÑ±Îêú ÏßàÎ¨∏Îì§ ÎØ∏Î¶¨Î≥¥Í∏∞
                   if !studyViewModel.generatedQuestions.isEmpty {
                       ScrollView {
                           LazyVStack(spacing: 12) {
                               ForEach(studyViewModel.generatedQuestions) { question in
                                   QuestionPreviewCard(
                                       question: question,
                                       selectedAnswer: $previewSelectedAnswer,
                                       isCorrect: $previewIsCorrect,
                                       onAnswerSelected: { correct in
                                           print("Answer selected: \(correct)")
                                       }
                                   )
                                   .transition(.slide)
                               }
                           }
                           .padding()
                       }
                   }
               }
           }
           // ÏùºÎ∞ò ÌïôÏäµ Î∑∞
           else {
               ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                           total: Double(studyViewModel.totalQuestions))
                   .progressViewStyle(.linear)
                   .padding()
               
               Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                   .font(.subheadline)
                   .foregroundColor(.secondary)
               
               if !studyViewModel.hasQuestions {
                   Text("No questions available")
                       .font(.headline)
                       .foregroundColor(.gray)
               } else {
                   ScrollView {
                       VStack(alignment: .leading, spacing: 20) {
                           if let currentQuestion = studyViewModel.currentQuestion {
                               switch currentQuestion.type {
                               case .multipleChoice:
                                   MultipleChoiceView(
                                       question: currentQuestion,
                                       selectedAnswer: $studyViewModel.selectedAnswer,
                                       showExplanation: studyViewModel.showExplanation,
                                       isCorrect: isCorrect
                                   )
                                   
                               case .fillInBlanks:
                                   FillInBlanksView(
                                       question: currentQuestion,
                                       answer: $studyViewModel.selectedAnswer,
                                       showExplanation: studyViewModel.showExplanation,
                                       isCorrect: isCorrect
                                   )
                                   
                               case .trueFalse:
                                   TrueFalseView(
                                       question: currentQuestion,
                                       selectedAnswer: $studyViewModel.selectedAnswer,
                                       showExplanation: studyViewModel.showExplanation,
                                       isCorrect: isCorrect
                                   )
                               }
                               
                               if showExplanation && studyViewModel.showExplanation {
                                   ExplanationView(explanation: currentQuestion.explanation)
                               }
                           }
                       }
                       .padding()
                   }
                   
                   // Action Buttons
                   VStack {
                       Divider()
                       
                       HStack(spacing: 12) {
                           if studyViewModel.showExplanation {
                               UtilityButtons(
                                   showExplanation: $showExplanation,
                                   isSaved: $isSaved,
                                   studyViewModel: studyViewModel
                               )
                           }
                           
                           ActionButton(
                               viewModel: studyViewModel,
                               selectedTab: $selectedTab,
                               isCorrect: $isCorrect,
                               showExplanation: $showExplanation
                           )
                       }
                       .padding()
                       .background(Color(UIColor.systemBackground))
                   }
               }
           }
       }
       .onAppear {
           if let currentQuestion = studyViewModel.currentQuestion {
               isSaved = currentQuestion.isSaved
           }
       }
       .onChange(of: studyViewModel.currentQuestion) { newQuestion in
           if let question = newQuestion {
               isSaved = question.isSaved
           }
       }
   }
}

// ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ÎØ∏Î¶¨Î≥¥Í∏∞ Ïπ¥Îìú Î∑∞
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // ÏÉÅÎã® Ï†ïÎ≥¥
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
              
              Text(question.difficulty.rawValue.capitalized)
                  .font(.caption)
                  .foregroundColor(.secondary)
          }
          
          // ÏßàÎ¨∏
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // ÎãµÎ≥Ä ÏòµÏÖò
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// Í∏∞Ï°¥ Ïª¥Ìè¨ÎÑåÌä∏Îì§ÏùÄ Ïú†ÏßÄ
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               isCorrect = viewModel.selectedAnswer == viewModel.currentQuestion?.correctAnswer
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}


## ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 1024 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.9
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // Ïù¥ÎØ∏ÏßÄÏùò ÌÅ¨Í∏∞Î•º ÏµúÎåÄ ÏπòÏàòÏóê ÎßûÍ≤å Ï°∞Ï†ï
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // ÏÑ§Ï†ïÎêú ÌíàÏßàÎ°ú ÏïïÏ∂ï
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // ÌÅ¨Í∏∞Í∞Ä ÏµúÎåÄ ÌååÏùº ÌÅ¨Í∏∞Î•º Ï¥àÍ≥ºÌïòÎäî Í≤ΩÏö∞, ÌíàÏßàÏùÑ ÎÇÆÏ∂∞ÏÑú Ï∂îÍ∞Ä ÏïïÏ∂ï ÏãúÎèÑ
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera) else {
                print("Camera Not Available")
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetailÏùò ÏÑ§Ï†ï Í∞íÏùÑ ÏÇ¨Ïö©
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // ÏòàÏ∏° ÌÜ†ÌÅ∞ Ïàò Í≥ÑÏÇ∞
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        üìä Image Optimization Results:
        ‚Ä¢ Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        ‚Ä¢ Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        ‚Ä¢ Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        ‚Ä¢ Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        ‚Ä¢ Estimated Tokens: \(estimatedTokens)
        ‚Ä¢ Processing Time: \(String(format: "%.3f", processingTime))s
        ‚Ä¢ Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}


## ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
}

public class StorageService {
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    
    private let fileManager = FileManager.default
     
     private var documentDirectory: URL? {
         fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
     }
     
     private func getDirectoryURL(for type: String) -> URL? {
         documentDirectory?.appendingPathComponent(type)
     }
     
     private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
         do {
             return try operation()
         } catch let error as NSError {
             print("""
             ‚ùå File Operation Error:
             ‚Ä¢ Error Domain: \(error.domain)
             ‚Ä¢ Error Code: \(error.code)
             ‚Ä¢ Description: \(error.localizedDescription)
             """)
             
             // Ïû¨ÏãúÎèÑ Î°úÏßÅ
             let retryCount = 3
             for attempt in 1...retryCount {
                 print("üîÑ Retrying operation (attempt \(attempt)/\(retryCount))")
                 do {
                     return try operation()
                 } catch {
                     if attempt == retryCount {
                         throw error
                     }
                     Thread.sleep(forTimeInterval: 0.5)
                 }
             }
             throw error
         }
     }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileOperation {
            var problemSets = try getProblemSets()
            problemSets.append(problemSet)
            
            let data = try encoder.encode(problemSets)
            defaults.set(data, forKey: problemSetsKey)
        }
    }
        
    
    public func getProblemSets() throws -> [ProblemSet] {
        guard let data = defaults.data(forKey: problemSetsKey) else {
            return []
        }
        
        do {
            return try decoder.decode([ProblemSet].self, from: data)
        } catch {
            throw StorageError.loadFailed
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        var sessions = try getStudySessions()
        sessions.append(session)
        
        do {
            let data = try encoder.encode(sessions)
            defaults.set(data, forKey: studySessionsKey)
        } catch {
            throw StorageError.saveFailed
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        guard let data = defaults.data(forKey: studySessionsKey) else {
            return []
        }
        
        do {
            return try decoder.decode([StudySession].self, from: data)
        } catch {
            throw StorageError.loadFailed
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        var sessions = try getStudySessions()
        
        guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
            throw StorageError.notFound
        }
        
        sessions.remove(at: index)
        
        do {
            let data = try encoder.encode(sessions)
            defaults.set(data, forKey: studySessionsKey)
        } catch {
            throw StorageError.deleteFailed
        }
    }
    
    // MARK: - Saved Questions
    public func saveQuestion(_ question: Question) throws {
        var savedQuestions = try getSavedQuestions()
        savedQuestions.append(question)
        
        do {
            let data = try encoder.encode(savedQuestions)
            defaults.set(data, forKey: savedQuestionsKey)
        } catch {
            throw StorageError.saveFailed
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        guard let data = defaults.data(forKey: savedQuestionsKey) else {
            return []
        }
        
        do {
            return try decoder.decode([Question].self, from: data)
        } catch {
            throw StorageError.loadFailed
        }
    }
    

    public func saveQuestions(_ questions: [Question]) throws {
        do {
            let data = try encoder.encode(questions)
            defaults.set(data, forKey: savedQuestionsKey)
        } catch {
            throw StorageError.saveFailed
        }
    }
}


## ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    private let apiKey: String
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public ÏúºÎ°ú Î≥ÄÍ≤Ω
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init Ï∂îÍ∞Ä
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public ÏúºÎ°ú Î≥ÄÍ≤Ω
        let subject: Subject
        let difficulty: Difficulty
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        
        public init(    // public init Ï∂îÍ∞Ä
            subject: Subject,
            difficulty: Difficulty,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int]
        ) {
            self.subject = subject
            self.difficulty = difficulty
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("‚ùå Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("üì∏ Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("‚ùå Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }
    
    // StreamResponse Íµ¨Ï°∞Ï≤¥ÎèÑ ÌïÑÏöîÌï©ÎãàÎã§
    private struct StreamResponse: Codable {
        struct Choice: Codable {
            struct Delta: Codable {
                let content: String?
            }
            let delta: Delta
        }
        let choices: [Choice]
    }

    // extractCompleteQuestion Ìï®ÏàòÎèÑ Ï∂îÍ∞Ä
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSONÏù¥ ÏôÑÏ†ÑÌïú Í∞ùÏ≤¥Ïù∏ÏßÄ ÌôïÏù∏
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSONÏù¥ ÏïÑÏßÅ ÏôÑÏÑ±ÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò ÌååÏã±Ìï† Ïàò ÏóÜÎäî Í≤ΩÏö∞
            return nil
        }
    }
    
    // Ïä§Ìä∏Î¶¨Î∞çÏùÑ ÏúÑÌïú ÏÉàÎ°úÏö¥ Î©îÏÑúÎìú Ï∂îÍ∞Ä
    public func streamQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) -> AsyncThrowingStream<Question, Error> {
        return AsyncThrowingStream { continuation in
            Task {
                do {
                    print("üîÑ Starting question stream generation...")
                    let (schema, prompts) = try await preparePromptAndSchema(input: input, parameters: parameters)
                    
                    var request = URLRequest(url: URL(string: baseURL)!)
                    request.httpMethod = "POST"
                    request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
                    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                    
                    let requestBody: [String: Any] = [
                        "model": OpenAIModel.gpt4Vision,
                        "messages": buildMessages(input: input, prompts: prompts),
                        "stream": true,  // Ïä§Ìä∏Î¶¨Î∞ç ÌôúÏÑ±Ìôî
                        "max_tokens": OpenAIModel.maxTokens,
                        "temperature": 0.7,
                        "response_format": ["type": "json_object"]  // JSON ÏùëÎãµ ÌòïÏãù ÏßÄÏ†ï
                    ]
                    
                    request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
                    
                    print("üåê Starting streaming request...")
                    let (result, response) = try await session.bytes(for: request)
                    
                    guard let httpResponse = response as? HTTPURLResponse else {
                        throw NetworkError.invalidResponse
                    }
                    
                    print("üì° Stream connected with status: \(httpResponse.statusCode)")
                    
                    var questionBuffer = ""
                    var questionCount = 0
                    
                    for try await line in result.lines {
                        if line.hasPrefix("data: "), let data = line.dropFirst(6).data(using: .utf8) {
                            if let streamResponse = try? JSONDecoder().decode(StreamResponse.self, from: data),
                               let content = streamResponse.choices.first?.delta.content {
                                questionBuffer += content
                                
                                // JSON Í∞ùÏ≤¥Í∞Ä ÏôÑÏÑ±ÎêòÎ©¥ ÌååÏã±
                                if let questionData = try? extractCompleteQuestion(from: questionBuffer) {
                                    questionCount += 1
                                    print("‚úÖ Streaming question \(questionCount): \(questionData.question)")
                                    
                                    let question = Question(
                                        id: UUID().uuidString,
                                        type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                                        subject: parameters.subject,
                                        difficulty: parameters.difficulty,
                                        question: questionData.question,
                                        options: questionData.options,
                                        correctAnswer: questionData.correctAnswer,
                                        explanation: questionData.explanation,
                                        hint: questionData.hint,
                                        isSaved: false,
                                        createdAt: Date()
                                    )
                                    
                                    continuation.yield(question)
                                    questionBuffer = ""
                                }
                            }
                        }
                    }
                    
                    print("‚úÖ Stream completed: Generated \(questionCount) questions")
                    continuation.finish()
                } catch {
                    print("‚ùå Stream error: \(error)")
                    continuation.finish(throwing: error)
                }
            }
        }
    }
    
    // ÎÇòÎ®∏ÏßÄ private Íµ¨Ï°∞Ï≤¥Îì§ÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Initialization
    init() throws {
        self.apiKey = try ConfigurationManager.shared.getValue(for: "OpenAIAPIKey")
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)_\(parameters.difficulty.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("‚úÖ Retrieved questions from cache")
            return cachedQuestions
        }
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // Ïù¥ÎØ∏ÏßÄ ÎòêÎäî ÌÖçÏä§Ìä∏Î•º Ï≤òÎ¶¨ÌïòÎäî ÌÉúÏä§ÌÅ¨ Ï∂îÍ∞Ä
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            let questions = try await self.performQuestionGeneration(
                input: processedInput,                     // Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
                textInput: processedTextInput,             // ÌÖçÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(_ subject: Subject, isImageInput: Bool, educationLevel: EducationLevel, difficulty: Difficulty) -> SubjectPrompt {
        if isImageInput {
            return SubjectPrompt(
                systemPrompt: """
                   You are an \(subject.displayName) expert creating image-based questions.
                   Important : Generate questions in the exact same language as any visible text in the image.
                   Important : Ensure questions are clear and unambiguous and specific and detailed. 
                   """,
                userPromptTemplate: """
                   Create self-contained questions that provide all necessary context within each question.
                   Keep the same language as the image text.
                   Important : Include specific details from the content
                   Example format:
                   BAD: "What does the text explain?"
                   BAD: "what is the title of this image?"
                   GOOD: "In the passage where Jesus described the birds of the air, what characteristics of the birds did he emphasize?"
                   Good: "What lesson does the person mentioned in the text want to convey to us through ‚Äòtrying to endure many hardships while worrying about how to repay the mortgaged house price‚Äô"
                   """
            )
        } else {
            return SubjectPrompt(
                systemPrompt: """
                   You are an \(subject.displayName) expert specializing in creating questions for \(educationLevel.displayName) school students.
                   Important : Generate questions in the exact same language as the input text.
                   Important : Create self-contained questions that provide all necessary context within each question.
                   
                   Questions should:
                   - be made understandable at the level of \(educationLevel.displayName) school students. 
                   - Preserve the input text's language
                   - Use clear, precise language 
                   - Include detailed explanations and hints
                   - Never reference any images when input is text
                   """,
                userPromptTemplate: """
                   question creation guidelines:
                   Important - Generates questions in exactly the same language as the input text.
                   Important - Create self-contained questions that provide all necessary context within each question.

                   1. CONTEXT & CONTENT
                   - Generate questions directly from the user's input content
                   - Create questions at the \(educationLevel.displayName) school student

                   2. LANGUAGE & STRUCTURE
                   - Include specific dates, names, and events when relevant
                   - Avoid broad, oversimplified questions

                   3. EXAMPLE FORMATS
                   BAD:
                   - Overly general: "What happened during World War II?"
                   - Misleading premise: "When did America create democracy?"
                   - Missing context: "Why did they sign the document?"

                   GOOD:
                   - Specific: "How did the ratification of the 14th Amendment (1868) change citizenship rights in the United States?"
                   - Analytical: "What economic and social factors led to the Great Depression between 1929-1933?"
                   - Contextual: "How did the invention of the cotton gin by Eli Whitney in 1793 impact slavery in the Southern states?"
                   """
            )
        }
    }
    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            educationLevel: parameters.educationLevel,
            difficulty: parameters.difficulty
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
            .replacingOccurrences(of: "{difficulty}", with: parameters.difficulty.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": ["type": "array", "items": ["type": "string"]],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint" ]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        print("ü§ñ OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages Î∞∞Ïó¥ÏùÑ ÎØ∏Î¶¨ ÏÑ†Ïñ∏
        var messages: [[String: Any]]

        // Íµ¨Ï°∞ÌôîÎêú Î©îÏãúÏßÄ ÏÉùÏÑ±
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI Í≥µÏãù Î©ÄÌã∞Î™®Îã¨ Ìè¨Îß∑ ÏÇ¨Ïö©
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        print("""
        üåê API Request:
        ‚Ä¢ URL: \(baseURL)
        ‚Ä¢ Method: POST
        ‚Ä¢ Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            üåê API Response:
            ‚Ä¢ Status Code: \(httpResponse.statusCode)
            ‚Ä¢ Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                difficulty: parameters.difficulty,
                question: questionData.question,
                options: questionData.options,
                correctAnswer: questionData.correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        ‚úÖ Questions Generated:
        ‚Ä¢ Count: \(questions.count)
        ‚Ä¢ Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


## ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    static let shared = NetworkMonitor()
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    private init() {
        startMonitoring()
    }
    
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            DispatchQueue.main.async {
                self?.status = path.status
                self?.isReachable = path.status == .satisfied
                self?.connectionType = path.availableInterfaces.first?.type
                self?.isExpensive = path.isExpensive
                self?.isConstrained = path.isConstrained
                
                // Ïó∞Í≤∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïãú Ïû¨ÏãúÎèÑ Î°úÏßÅ Íµ¨ÌòÑ
                if path.status == .satisfied {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    // Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ ÌÉÄÏûÖÏùÑ Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôòÌïòÎäî Ìï®Ïàò Ï∂îÍ∞Ä
    private func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    func stopMonitoring() {
        monitor.cancel()
    }
    
    deinit {
        stopMonitoring()
    }
}


