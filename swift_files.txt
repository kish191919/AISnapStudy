// ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

@MainActor
class QuestionSettingsViewModel: ObservableObject {
    
    let openAIService: OpenAIService
    
    @Published var selectedSubject: any SubjectType {
        didSet {
            if let defaultSubject = selectedSubject as? DefaultSubject {
                UserDefaults.standard.set(defaultSubject.rawValue, forKey: "lastSelectedSubject")
            } else if let customSubject = selectedSubject as? CustomSubject {
                UserDefaults.standard.set("custom_" + customSubject.id, forKey: "lastSelectedSubject")
            }
        }
    }
    
    @Published var useTextExtraction: Bool = true {
        didSet {
            UserDefaults.standard.set(useTextExtraction, forKey: "useTextExtraction")
        }
    }
    
    @Published var selectedLanguage: Language = .auto {
        didSet {
            UserDefaults.standard.set(selectedLanguage.rawValue, forKey: "selectedLanguage")
        }
    }
    
    // TextExtraction 관련 상태들
    @Published var extractedTexts: [String: String] = [:]
    @Published var isLoadingTexts: [String: Bool] = [:]
    @Published var extractionStatus: [String: Bool] = [:]
    @Published private(set) var isCameraAuthorized = false
    @Published private(set) var isGalleryAuthorized = false
    @Published var availableSubjects: [SubjectType] = []
    
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private let totalMaximumQuestions = 10
    private var studyViewModel: StudyViewModel?
    // StoreService 추가
    private let storeService = StoreService.shared
    
    // MARK: - UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    private func loadAvailableSubjects() {
        // DefaultSubject를 직접 추가
        var subjects: [any SubjectType] = DefaultSubject.allCases
        
        // 활성화된 사용자 정의 과목 추가
        let activeUserSubjects = SubjectManager.shared.customSubjects
            .filter { $0.isActive }
        subjects.append(contentsOf: activeUserSubjects)
        
        availableSubjects = subjects
        
        // 현재 선택된 과목이 없거나 비활성화된 경우 기본 과목으로 설정
        if !subjects.contains(where: { $0.id == selectedSubject.id }) {
            selectedSubject = DefaultSubject.generalKnowledge  // 기본값으로 math 설정
        }
    }

    private var imageIds: [UIImage: String] = [:]
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView: Bool = false
    @Published var isGeneratingQuestions: Bool = false
    @Published var problemSetName: String = ""
    @Published var isLoading: Bool = false
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool = true
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool = false
    @Published var alertTitle: String = ""
    @Published var alertMessage: String = ""
    
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         }
     }
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
         }
     }
     
    let subject: DefaultSubject
    
     
     // MARK: - Initialization
    init(subject: any SubjectType, homeViewModel: HomeViewModel) {
        
        // 1. UserDefaults 기본값을 먼저 설정
        UserDefaults.standard.register(defaults: [
            "useTextExtraction": true,
            UserDefaultsKeys.lastMultipleChoiceCount: 5,
            UserDefaultsKeys.lastTrueFalseCount: 5
        ])

        
        // 1. OpenAIService 초기화
        self.openAIService = OpenAIService.shared
        
        // 2. 기본값이 필요한 프로퍼티들 초기화
        self.selectedSubject = subject
        self.subject = subject as? DefaultSubject ?? .generalKnowledge
        self.homeViewModel = homeViewModel
        self.studyViewModel = homeViewModel.studyViewModel
        
        // 3. @Published 프로퍼티들 초기화
        self.selectedLanguage = .auto
        self.useTextExtraction = UserDefaults.standard.bool(forKey: "useTextExtraction")
        self.educationLevel = EducationLevel(rawValue: UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel) ?? "") ?? .elementary
        self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
        self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
        self.isNetworkAvailable = networkMonitor.isReachable
        
        // 4. 그 외 나머지 @Published 프로퍼티들 초기화
        self.extractedTexts = [:]
        self.isLoadingTexts = [:]
        self.extractionStatus = [:]
        self.isCameraAuthorized = false
        self.isGalleryAuthorized = false
        self.availableSubjects = []
        self.selectedImages = []
        self.hasCameraImage = false
        self.hasGalleryImages = false
        self.questionText = ""
        self.isUsingTextInput = false
        self.isTextInputActive = false
        self.hasSelectedCamera = false
        self.hasSelectedGallery = false
        self.shouldCollapseQuestionTypes = false
        self.shouldShowStudyView = false
        self.isGeneratingQuestions = false
        self.problemSetName = ""
        self.isLoading = false
        self.showImagePicker = false
        self.showCamera = false
        self.selectedImage = nil
        self.showAlert = false
        self.alertTitle = ""
        self.alertMessage = ""
        

        
        // 6. Subject 관련 설정 업데이트
        if let savedSubjectID = UserDefaults.standard.string(forKey: "lastSelectedSubject") {
            if savedSubjectID.starts(with: "custom_") {
                let customID = String(savedSubjectID.dropFirst(7))
                self.selectedSubject = SubjectManager.shared.customSubjects.first { $0.id == customID } ?? subject
            } else {
                self.selectedSubject = DefaultSubject(rawValue: savedSubjectID) ?? subject
            }
        }
        
        // 7. 언어 설정 업데이트
        if let savedLanguage = UserDefaults.standard.string(forKey: "selectedLanguage"),
           let language = Language(rawValue: savedLanguage) {
            self.selectedLanguage = language
        }
    }
    // Add permission check methods
    func checkCameraPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .camera)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
    
    func checkGalleryPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .gallery)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
     
     // MARK: - Image Management
     private func generateImageId() -> String {
         return UUID().uuidString
     }
     
    func getImageId(for image: UIImage) -> String {
        if let existingId = imageIds[image] {
            return existingId
        }
        let newId = generateImageId()
        imageIds[image] = newId
        return newId
    }

    // 새로운 함수 추가
    private func sendExtractedTextToOpenAI(_ text: String) async throws {
        print("📤 Preparing to send extracted text to OpenAI")
        // OpenAIService는 이미 프로퍼티로 존재하므로 직접 사용
        let response = try await openAIService.sendTextExtractionResult(text)
        print("✅ OpenAI processing completed for extracted text")
        print("📥 OpenAI Response: \(response)")
    }

    private func sendImageToOpenAI(_ imageData: Data) async throws {
        print("📤 Preparing to send image to OpenAI")
        try await openAIService.sendImageDataToOpenAI(imageData)
        print("✅ Image successfully sent to OpenAI")
    }

    
    func removeImage(at index: Int) {
        guard index < selectedImages.count else { return }
        
        let imageToRemove = selectedImages[index]
        if let imageId = imageIds[imageToRemove] {
            // Remove extracted text for this image
            extractedTexts.removeValue(forKey: imageId)
            imageIds.removeValue(forKey: imageToRemove)
            print("🗑️ Removed text for image: \(imageId)")
        }
        
        selectedImages.remove(at: index)
        
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false
            hasSelectedGallery = false
        }
    }
    
    
    func saveProblemSetName() {
        if problemSetName.isEmpty {
            problemSetName = generateDefaultName()
        }
        
        // 이름이 저장되었음을 알리는 피드백 제공
        HapticManager.shared.impact(style: .medium)
        print("Problem Set name saved: \(problemSetName)")
        
        // 질문 생성이 완료되었고 이름이 저장되었을 때만 StudyView로 이동
        if !isGeneratingQuestions {
            shouldShowStudyView = true
        }
    }
    
    // 기본 이름 생성 메서드
    func generateDefaultName() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MM/dd_HH:mm"
        let dateString = dateFormatter.string(from: Date())
        let totalQuestions = multipleChoiceCount + trueFalseCount
        
        return "\(selectedSubject.displayName)_\(totalQuestions)Q_\(dateString)"
    }
     
     // 기존 resetCounts 메서드 수정
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults 완전 초기화가 필요한 경우를 위한 새로운 메서드
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         resetCounts()
     }
    
    // questionText가 비어있지 않으면 이미지 옵션을 숨기기 위한 계산 속성
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // 텍스트 입력을 리셋하는 메서드
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // 실제 선택된 이미지가 없을 때만 체크
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // 다음 상태 변경을 위해 리셋
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // 상태 리셋
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    // 계산 프로퍼티 추가
    var canCreateQuestions: Bool {
        storeService.subscriptionStatus.dailyQuestionsRemaining > 0
    }
    
    var isPremium: Bool {
        storeService.subscriptionStatus.isPremium
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }

    @MainActor
    func addImage(_ image: UIImage) async {
       print("📸 Starting addImage processing...")
        if useTextExtraction && selectedImages.count >= 3 {
            self.alertTitle = "Image Limit Reached"
            self.alertMessage = "Speed Up mode allows maximum 3 images at once."
            self.showAlert = true
            return
        }
        
        if !useTextExtraction && selectedImages.count >= 1 {
            self.alertTitle = "Image Limit Reached"
            self.alertMessage = "When Speed Up is disabled, you can process only one image at a time."
            self.showAlert = true
            return
        }
       do {
           let compressedData = try await Task {
               try ImageService.shared.compressForAPI(image)
           }.value

           if let compressedImage = UIImage(data: compressedData) {
               selectedImages.append(compressedImage)
               let imageId = getImageId(for: compressedImage)

               if useTextExtraction {
                   print("🔍 Text extraction enabled for image: \(imageId)")
                   isLoadingTexts[imageId] = true
                   
                   // FileProvider 에러와 상관없이 Vision API 사용
                   do {
                       // VisionService를 통한 텍스트 추출
                       print("📝 Starting Vision API text extraction...")
                       let extractedText = try await VisionService.shared.extractText(from: compressedImage)
                       
                       if !extractedText.isEmpty {
                           print("✅ Text extracted successfully: \(extractedText)")
                           await MainActor.run {
                               extractedTexts[imageId] = extractedText
                               extractionStatus[imageId] = true
                               isLoadingTexts[imageId] = false
                           }
                       } else {
                           print("⚠️ No text extracted from image")
                           await MainActor.run {
                               extractionStatus[imageId] = false
                               isLoadingTexts[imageId] = false
                           }
                       }
                   } catch {
                       print("❌ Text extraction failed: \(error.localizedDescription)")
                       await MainActor.run {
                           extractionStatus[imageId] = false
                           isLoadingTexts[imageId] = false
                       }
                   }
               } else {
                   print("ℹ️ Text extraction disabled - using image directly")
               }
           }
       } catch {
           print("❌ Error in image processing: \(error.localizedDescription)")
           self.error = error
           showError(error)
       }
    }
    
    
    @MainActor
    func sendAllImages() async {
       // 질문 생성 가능 여부 체크
       guard checkQuestionGenerationAvailability() else { return }

       print("🚀 Starting sendAllImages process...")
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("❌ No content to generate questions from")
           return
       }
       
       isLoading = true
       studyViewModel?.isGeneratingQuestions = true
       
       do {
           var allExtractedText = ""
           var imagesForDirectProcessing: [UIImage] = []
           
           // 이미지 처리
           for image in selectedImages {
               let imageId = getImageId(for: image)
               print("📸 Processing image: \(imageId)")
               
               if useTextExtraction {
                   print("🔍 Text extraction enabled - attempting to extract text...")
                   do {
                       let extractedText = try await VisionService.shared.extractText(from: image)
                       if !extractedText.isEmpty {
                           print("✅ Successfully extracted text: \(extractedText)")
                           allExtractedText += extractedText + "\n"
                       } else {
                           print("⚠️ No text extracted, adding to direct processing queue")
                           imagesForDirectProcessing.append(image)
                       }
                   } catch {
                       print("❌ Error extracting text from image: \(error)")
                       imagesForDirectProcessing.append(image)
                   }
               } else {
                   print("ℹ️ Text extraction disabled - adding to direct processing queue")
                   imagesForDirectProcessing.append(image)
               }
           }

           // 텍스트 입력 처리
           if !questionText.isEmpty {
               let textInput = OpenAIService.QuestionInput(
                   content: questionText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("📝 Processing text input")
               await generateQuestions(from: textInput, parameters: createParameters())
           }
           
           // 추출된 텍스트 처리
           if !allExtractedText.isEmpty {
               let input = OpenAIService.QuestionInput(
                   content: allExtractedText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("📤 Sending extracted text to OpenAI")
               await generateQuestions(from: input, parameters: createParameters())
           }
           
           // 직접 이미지 처리가 필요한 경우 처리
           if !imagesForDirectProcessing.isEmpty {
               print("📸 Processing \(imagesForDirectProcessing.count) images directly")
               for image in imagesForDirectProcessing {
                   print("🖼️ Direct processing image")
                   try await processImageDirectly(image)
               }
           }
           
           // 성공적으로 질문이 생성되면 남은 횟수 감소
           storeService.decrementRemainingQuestions()
           
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           showSuccess()
           shouldShowStudyView = true
           
       } catch {
           print("❌ Error in sendAllImages: \(error.localizedDescription)")
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           self.error = error
           showError(error)
       }
    }
    
    // 질문 생성 가능 여부 체크 함수 추가
    private func checkQuestionGenerationAvailability() -> Bool {
        if !canCreateQuestions {
            alertTitle = "Daily Limit Reached"
            alertMessage = isPremium ?
                "You've used all your daily questions. Please wait until tomorrow." :
                "You've reached your daily free limit. Upgrade to Premium to create up to 30 question sets per day!"
            showAlert = true
            return false
        }
        return true
    }
    
    // generateQuestions(from:parameters:) 보조 함수
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
        print("🔄 Starting question generation from input")
        
        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            print("✅ Successfully generated \(questions.count) questions")
            
            let name = problemSetName.isEmpty ? generateDefaultName() : problemSetName
            await processGeneratedQuestions(questions, name: name)
        } catch {
            print("❌ Error generating questions: \(error)")
            await MainActor.run {
                self.error = error
                showError(error)
            }
        }
    }

    // 직접 이미지 처리를 위한 함수도 수정
    private func processImageDirectly(_ image: UIImage) async throws {
        print("🖼️ Processing image directly...")
        let compressedData = try await imageService.compressForAPI(image)
        let input = OpenAIService.QuestionInput(
            content: compressedData,
            isImage: true
        )
        print("📤 Sending image to OpenAI")
        let questions = try await openAIService.generateQuestions(from: input, parameters: createParameters())
        await processGeneratedQuestions(questions, name: problemSetName)
    }

    private func createParameters() -> OpenAIService.QuestionParameters {
        let subjectToUse = (selectedSubject as? DefaultSubject) ?? .generalKnowledge  // DefaultSubject로 변환
        
        return OpenAIService.QuestionParameters(
            subject: subjectToUse,
            educationLevel: educationLevel,
            questionTypes: [
                QuestionType.multipleChoice: multipleChoiceCount,
                QuestionType.trueFalse: trueFalseCount
            ],
            language: selectedLanguage
        )
    }
    
    // Update image handling methods
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("📸 Processing camera image...")
        guard let image = image else {
            print("❌ No image captured")
            return
        }

        Task {
            do {
                let orientedImage = image.fixedOrientation()
                await addImage(orientedImage)
                hasCameraImage = true
                hasSelectedCamera = true
                hasSelectedGallery = false
                print("✅ Camera image added successfully")
            } catch {
                print("❌ Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }

    @MainActor
    func selectFromGallery() async {
        do {
            let hasPermission = try await imageService.requestPermission(for: .gallery)
            if hasPermission {
                hasSelectedCamera = false  // Reset camera selection
                hasSelectedGallery = true
                showImagePicker = true
                hasGalleryImages = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func takePhoto() async {
        print("📸 Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                hasSelectedGallery = false  // Reset gallery selection
                hasSelectedCamera = true
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func processGeneratedQuestions(_ questions: [Question], name: String) async {
        print("\n🔄 Processing Generated Questions for subject: \(selectedSubject.displayName)")
        
        // 1. Subject 정보 준비
        var subjectType = "default"
        var subjectId = ""
        var subjectName = ""
        var defaultSubject = DefaultSubject.generalKnowledge
        
        if let customSubject = selectedSubject as? CustomSubject {
            subjectType = "custom"
            subjectId = customSubject.id
            subjectName = customSubject.displayName
            defaultSubject = .generalKnowledge
            
            print("""
            📝 Preparing Custom Subject:
            • Name: \(customSubject.displayName)
            • ID: \(customSubject.id)
            • Type: \(subjectType)
            """)
        } else if let defaultSubject = selectedSubject as? DefaultSubject {
            subjectType = "default"
            subjectId = defaultSubject.rawValue
            subjectName = defaultSubject.displayName
            
            print("""
            📝 Preparing Default Subject:
            • Name: \(defaultSubject.displayName)
            • ID: \(defaultSubject.rawValue)
            • Type: \(subjectType)
            """)
        }
        
        // 2. 질문 업데이트
        let updatedQuestions = questions.map { question in
            var updatedQuestion = question
            if let customSubject = selectedSubject as? CustomSubject {
                // CustomSubject인 경우 generalKnowledge로 설정
                updatedQuestion = Question(
                    id: question.id,
                    type: question.type,
                    subject: .generalKnowledge,
                    question: question.question,
                    options: question.options,
                    correctAnswer: question.correctAnswer,
                    explanation: question.explanation,
                    hint: question.hint,
                    isSaved: question.isSaved,
                    createdAt: question.createdAt
                )
            }
            return updatedQuestion
        }
        
        // 3. ProblemSet 생성
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            subject: selectedSubject,  // 선택된 subject 그대로 사용
            subjectType: selectedSubject is DefaultSubject ? "default" : "custom",
            subjectId: selectedSubject.id,
            subjectName: selectedSubject.displayName,
            questions: questions,  // 질문들을 수정하지 않고 그대로 사용
            createdAt: Date(),
            educationLevel: self.educationLevel,
            name: name
        )
        
        print("""
        📦 Created ProblemSet:
        • ID: \(problemSet.id)
        • Subject Type: \(problemSet.subjectType)
        • Subject ID: \(problemSet.subjectId)
        • Subject Name: \(problemSet.subjectName)
        • Questions Count: \(problemSet.questions.count)
        • Education Level: \(problemSet.educationLevel.rawValue)
        """)
        
        // 4. ProblemSet 저장 및 선택
        await homeViewModel.saveProblemSet(problemSet)
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // 5. 알림 발송
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
        
        print("✅ Problem Set processing completed")
    }

    @MainActor
    private func showSuccess() {
        alertTitle = "Success"
        alertMessage = """
            Questions have been successfully generated.
            You have \(remainingQuestions) question sets remaining today.
            """
        showAlert = true
    }
    
    // 업그레이드 상태 표시를 위한 함수 추가
    var subscriptionStatusText: String {
        if isPremium {
            return "Premium • \(remainingQuestions) sets remaining today"
        } else {
            return "Free • \(remainingQuestions) set remaining today"
        }
    }

    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


// ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    @Published var streak: Int = 0
    @Published var correctAnswers: Int = 0 {
        didSet {
            // 점수가 변경될 때마다 출력되는 디버그 로그
            print("📊 StatViewModel score updated: \(correctAnswers * 10) points")
        }
    }
    private var isResetting: Bool = false
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var isLoading = false
    @Published var monthlyProgress: [DailyProgress] = []
    @Published var yearlyProgress: [DailyProgress] = []
    
    private var todaysSessionStats: (questions: Int, correct: Int) = (0, 0)
    private var existingStats: (questions: Int, correct: Int) = (0, 0)
    
    private weak var studyViewModel: StudyViewModel?
    private weak var homeViewModel: HomeViewModel?
    private var todayTotalQuestions: Int = 0
    private var todayCorrectAnswers: Int = 0

    
    @Published var totalPoints: Int = 0      // 현재 세션의 점수
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    
    private var sessionStats: SessionStats = .init() // 새로 추가

    struct SessionStats {
        var completedQuestions: Int = 0
        var correctAnswers: Int = 0
        var startTime: Date = Date()
    }
    

    
    init(context: NSManagedObjectContext,
         homeViewModel: HomeViewModel? = nil,
         studyViewModel: StudyViewModel? = nil) {
        self.context = context
        self.homeViewModel = homeViewModel
        self.studyViewModel = studyViewModel
        
        // Move the loadStats() call to the end of the init method
        loadStats()
        setupObservers()
    }
    private func setupObservers() {
        // 기존 observer 제거
        NotificationCenter.default.removeObserver(self)
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleStudyProgressUpdate),
            name: .studyProgressDidUpdate,
            object: nil
        )
    }
    
    @MainActor
    func loadStatsByPeriod(_ period: StatsPeriod) async {
        isLoading = true
        
        do {
            let stats = try await CoreDataService.shared.fetchStatsByPeriod(period)
            await MainActor.run {
                switch period {
                case .day:
                    weeklyProgress = processStats(stats)
                case .month:
                    monthlyProgress = processStats(stats)
                case .year:
                    yearlyProgress = processStats(stats)
                }
                objectWillChange.send()
            }
        } catch {
            print("❌ Failed to load \(period) stats: \(error)")
        }
        
        isLoading = false
    }
    
    private func processStats(_ stats: [DailyStats]) -> [DailyProgress] {
        return stats.map { stat in
            DailyProgress(
                date: stat.date,
                questionsCompleted: stat.totalQuestions,
                correctAnswers: stat.correctAnswers,
                totalTime: 0
            )
        }
    }
    
    @objc private func handleStudyProgressUpdate(_ notification: Notification) {
        guard let currentIndex = notification.userInfo?["currentIndex"] as? Int,
              let correctAnswers = notification.userInfo?["correctAnswers"] as? Int else {
            return
        }
        
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            let addedCorrect = correctAnswers - self.correctAnswers
            
            self.updateStats(
                correctAnswers: addedCorrect,
                totalQuestions: 1,
                isNewSession: false
            )
            
            self.correctAnswers = correctAnswers
        }
    }
    var currentSessionScore: Int {
        return correctAnswers * 10  // 계산 속성으로 변경
    }
    
    // StudyViewModel 설정 메서드
    func setStudyViewModel(_ viewModel: StudyViewModel?) {
        self.studyViewModel = viewModel
        print("📱 StudyViewModel connected to StatViewModel")
    }

    
    func updateScore() {
        if let studyVM = studyViewModel {
            // correctAnswers 값을 업데이트
            self.correctAnswers = studyVM.correctAnswers
            self.totalQuestions = studyVM.totalQuestions
            // 디버그를 위한 로그
            print("📊 Score Updated - Correct: \(correctAnswers), Total: \(totalQuestions), Score: \(currentSessionScore)")
        }
    }
    
    func updateStats(correctAnswers: Int, totalQuestions: Int, isNewSession: Bool = false) {
        // 리셋 중이면 통계 업데이트 건너뛰기
        guard !isResetting else { return }
        
        let today = Date()
        
        do {
            // 1. 현재 저장된 통계 가져오기
            let currentStats = try CoreDataService.shared.fetchDailyStats() ?? DailyStats(
                id: UUID(),
                date: today,
                totalQuestions: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                timeSpent: 0
            )
            
            // 2. 단일 문제에 대한 통계 누적
            let updatedStats = DailyStats(
                id: currentStats.id,
                date: today,
                totalQuestions: currentStats.totalQuestions + 1,  // 현재 통계에 1 추가
                correctAnswers: currentStats.correctAnswers + (correctAnswers > 0 ? 1 : 0),
                wrongAnswers: currentStats.wrongAnswers + (correctAnswers > 0 ? 0 : 1),
                timeSpent: currentStats.timeSpent
            )
            
            // 3. 통계 저장
            try CoreDataService.shared.saveDailyStats(updatedStats)
            
            print("""
            📊 Stats updated:
            • Previous Total: \(currentStats.totalQuestions)
            • Added Questions: 1
            • New Total: \(updatedStats.totalQuestions)
            • Previous Correct: \(currentStats.correctAnswers)
            • Added Correct: \(correctAnswers > 0 ? 1 : 0)
            • New Correct: \(updatedStats.correctAnswers)
            """)
            
            // 4. UI 업데이트
            weeklyProgress = weeklyProgress.map { progress in
                if Calendar.current.isDate(progress.date, inSameDayAs: today) {
                    return DailyProgress(
                        date: today,
                        questionsCompleted: updatedStats.totalQuestions,
                        correctAnswers: updatedStats.correctAnswers,
                        totalTime: progress.totalTime
                    )
                }
                return progress
            }
            
            objectWillChange.send()
            
        } catch {
            print("❌ Failed to update stats: \(error)")
        }
    }
    
    private func updateWeeklyProgress() {
        let today = Date()
        if let index = weeklyProgress.firstIndex(where: { Calendar.current.isDate($0.date, inSameDayAs: today) }) {
            let updatedProgress = DailyProgress(
                date: today,
                questionsCompleted: completedQuestions,
                correctAnswers: correctAnswers,
                totalTime: weeklyProgress[index].totalTime
            )
            weeklyProgress[index] = updatedProgress
        } else {
            let newProgress = DailyProgress(
                date: today,
                questionsCompleted: completedQuestions,
                correctAnswers: correctAnswers,
                totalTime: 0.0  // New entry starts with 0 time
            )
            weeklyProgress.append(newProgress)
        }
        
        objectWillChange.send()
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("🔄 Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("🔄 Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    private func loadStats() {
        print("📊 Starting stats loading...")
        isLoading = true
        
        do {
            // 1. CoreData에서 오늘의 통계 불러오기
            if let todayStats = try CoreDataService.shared.fetchDailyStats(for: Date()) {
                existingStats = (todayStats.totalQuestions, todayStats.correctAnswers)
                
                DispatchQueue.main.async { [weak self] in
                    self?.completedQuestions = todayStats.totalQuestions
                    self?.correctAnswers = todayStats.correctAnswers
                    self?.accuracyRate = todayStats.accuracy
                    print("""
                    📊 Stats loaded from CoreData:
                    • Questions: \(todayStats.totalQuestions)
                    • Correct: \(todayStats.correctAnswers)
                    • Accuracy: \(todayStats.accuracy)%
                    """)
                }
            }
            
            // 2. 주간 진행 상황 계산
            let calendar = Calendar.current
            let today = Date()
            let weekAgo = calendar.date(byAdding: .day, value: -6, to: today)!
            
            var weekProgress: [DailyProgress] = []
            
            // 지난 7일간의 통계 불러오기
            for dayOffset in 0...6 {
                let date = calendar.date(byAdding: .day, value: dayOffset, to: weekAgo)!
                if let stats = try CoreDataService.shared.fetchDailyStats(for: date) {
                    weekProgress.append(DailyProgress(
                        date: date,
                        questionsCompleted: stats.totalQuestions,
                        correctAnswers: stats.correctAnswers,
                        totalTime: 0.0  // 시간 tracking이 필요하다면 나중에 추가
                    ))
                } else {
                    // 해당 날짜의 데이터가 없으면 0으로 초기화
                    weekProgress.append(DailyProgress(
                        date: date,
                        questionsCompleted: 0,
                        correctAnswers: 0,
                        totalTime: 0.0
                    ))
                }
            }
            
            weeklyProgress = weekProgress
            
            print("""
            📊 Weekly progress loaded:
            • Total days: \(weekProgress.count)
            • Total questions: \(weekProgress.reduce(0) { $0 + $1.questionsCompleted })
            • Total correct: \(weekProgress.reduce(0) { $0 + $1.correctAnswers })
            """)
            
        } catch {
            print("❌ Failed to load stats: \(error)")
        }
        
        isLoading = false
    }
    
    
    private func calculateWeeklyProgress(from sessions: [CDStudySession]) {
        print("📊 Starting weekly progress calculation...")
        let calendar = Calendar.current
        let today = Date()
        let weekAgo = calendar.date(byAdding: .day, value: -6, to: today)!
        
        var progress: [DailyProgress] = []
        
        for dayOffset in 0...6 {
            let date = calendar.date(byAdding: .day, value: dayOffset, to: weekAgo)!
            let dayStart = calendar.startOfDay(for: date)
            let dayEnd = calendar.date(byAdding: .day, value: 1, to: dayStart)!
            
            // Filter sessions for current day
            let daysSessions = sessions.filter { session in
                guard let sessionTime = session.startTime else { return false }
                return calendar.isDate(sessionTime, inSameDayAs: date)
            }
            
            let questionsCompleted = daysSessions.reduce(0) { sum, session in
                sum + (session.questions?.count ?? 0)
            }
            
            let correctAnswers = daysSessions.reduce(0) { sum, session in
                sum + ((session.questions?.allObjects as? [CDQuestion])?.filter { $0.isCorrect }.count ?? 0)
            }
            
            let totalTime = daysSessions.reduce(0.0) { sum, session in
                guard let start = session.startTime,
                      let end = session.endTime else { return sum }
                return sum + end.timeIntervalSince(start)
            }
            
            progress.append(DailyProgress(
                date: date,
                questionsCompleted: questionsCompleted,
                correctAnswers: correctAnswers,
                totalTime: totalTime
            ))
            
            // Log daily statistics
            print("""
            📊 Daily Stats for \(date):
            • Sessions: \(daysSessions.count)
            • Questions: \(questionsCompleted)
            • Correct: \(correctAnswers)
            """)
        }
        
        weeklyProgress = progress
    }
    

    private func calculateStats(from sessions: [CDStudySession]) {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        
        let todaySessions = sessions.filter { session in
            guard let sessionTime = session.startTime else { return false }
            return calendar.isDate(sessionTime, inSameDayAs: today)
        }
        
        // 이전 세션 통계에 새로운 세션 통계 추가
        let newCompletedQuestions = todaySessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        let newCorrectAnswers = todaySessions.reduce(0) { total, session in
            total + ((session.questions?.allObjects as? [CDQuestion])?.filter { $0.isCorrect }.count ?? 0)
        }
        
        // Calculate today's statistics
        let totalCompletedQuestions = todaySessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrectAnswers = todaySessions.reduce(0) { total, session in
            total + ((session.questions?.allObjects as? [CDQuestion])?.filter { $0.isCorrect }.count ?? 0)
        }
        
        // Calculate accuracy rate
        let calculatedAccuracyRate = totalCompletedQuestions > 0 ?
            (Double(totalCorrectAnswers) / Double(totalCompletedQuestions)) * 100 : 0
        
        // 값 업데이트 후 명시적으로 UI 업데이트
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            self.objectWillChange.send()
            self.completedQuestions = newCompletedQuestions
            self.correctAnswers = newCorrectAnswers
            self.accuracyRate = self.completedQuestions > 0 ?
                (Double(self.correctAnswers) / Double(self.completedQuestions)) * 100 : 0
        }
        
        print("""
        📊 Today's Stats Calculated:
        • Previous Questions: \(todaysSessionStats.questions)
        • New Total Questions: \(completedQuestions)
        • Correct Answers: \(correctAnswers)
        • Accuracy Rate: \(accuracyRate)%
        """)
    }
    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
        print("🔄 Starting resetProgress...")
        isResetting = true  // 리셋 시작
    
        
        // 현재까지의 통계를 저장
        let previousStats = (
            questions: completedQuestions,
            correct: correctAnswers
        )
        
        guard let homeVM = homeViewModel,
              let studyVM = homeVM.studyViewModel,
              let currentProblemSet = homeVM.selectedProblemSet else {
            print("❌ Required view models not found")
            return
        }
        
        Task {
            print("🔄 Resetting study state...")
            await studyVM.resetState()
            
            // 통계를 누적하여 업데이트
            updateStats(
                correctAnswers: previousStats.correct,
                totalQuestions: previousStats.questions,
                isNewSession: true  // 새로운 세션임을 표시
            )
            
            await MainActor.run {
                studyVM.loadQuestions(currentProblemSet.questions)
                
                print("""
                ✅ Reset complete:
                • Previous Questions: \(previousStats.questions)
                • Previous Correct: \(previousStats.correct)
                • Total Questions: \(completedQuestions)
                • New Session Questions: \(currentProblemSet.questions.count)
                """)
            }
            
            isResetting = false  // 리셋 완료
        }
    }
}

extension Notification.Name {
    static let studyProgressDidUpdate = Notification.Name("studyProgressDidUpdate")
}


enum StatsPeriod {
   case day, month, year
}


// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    @Published var studyViewModel: StudyViewModel?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var selectedProblemSet: ProblemSet?
    @Published var totalQuestions: Int = 0
    private let remoteService = RemoteQuestionService.shared
    @Published private(set) var remoteSets: [RemoteQuestionSet] = []  // 추가
    @Published private(set) var isLoadingRemote = false  // 추가
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()
//    @Published private(set) var favoriteProblemSets: [ProblemSet] = []
    
    init() {
        Task {
            await loadInitialData()
        }
    }
    
    @MainActor
    func toggleFavorite(_ problemSet: ProblemSet) async {
        do {
            problemSet.isFavorite.toggle()
            
            try await coreDataService.updateProblemSetFavorite(
                problemSetId: problemSet.id,
                isFavorite: problemSet.isFavorite
            )
            
            // UI 업데이트
            objectWillChange.send()
            
            print("⭐️ Problem Set favorite toggled: \(problemSet.id) - \(problemSet.name) - isFavorite: \(problemSet.isFavorite)")
        } catch {
            print("❌ Failed to toggle favorite: \(error)")
        }
    }

    @MainActor
    public func fetchUpdatedProblemSet(_ id: String) async throws -> ProblemSet? {
        let problemSets = try await coreDataService.fetchProblemSets()
        return problemSets.first(where: { $0.id == id })
    }
    
    // 즐겨찾기된 문제 세트 가져오기
    var favoriteProblemSets: [ProblemSet] {
        problemSets.filter { $0.isFavorite }
    }
    
    // 질문 북마크 토글 메서드 추가
    func toggleQuestionBookmark(_ question: Question) async {
        var updatedQuestion = question
        updatedQuestion.isSaved.toggle()
        
        if updatedQuestion.isSaved {
            await saveQuestion(updatedQuestion)
        } else {
            await deleteQuestion(updatedQuestion)
        }
    }

    

    // 현재 세션의 점수 관련 속성 추가
    var currentSessionScore: Int {
        return studyViewModel?.correctAnswers ?? 0
    }
    
    var currentSessionTotalQuestions: Int {
        return selectedProblemSet?.questions.count ?? 0
    }
    
    func setStudyViewModel(_ viewModel: StudyViewModel) {
        print("📱 Setting StudyViewModel in HomeViewModel")
        self.studyViewModel = viewModel
    }
    
    @MainActor
    func resetAndSetProblemSet(_ problemSet: ProblemSet) async {
        print("🔄 Starting complete ProblemSet reset")
        
        // 새로운 ProblemSet 설정
        self.selectedProblemSet = problemSet
        
        // StudyViewModel이 nil이 아닌지 확인
        guard let studyVM = studyViewModel else {
            print("❌ StudyViewModel is nil")
            return
        }
        
        // 상태 리셋 및 문제 다시 로드
        await studyVM.resetState()
        studyVM.loadQuestions(problemSet.questions)
        
        print("""
        ✅ ProblemSet reset complete:
        • ID: \(problemSet.id)
        • Questions: \(problemSet.questions.count)
        • Index reset to 0
        • Current Question: \(studyVM.currentQuestion?.question ?? "none")
        """)
    }
    
    func updateProblemSetSubject(_ problemSet: ProblemSet, to newSubject: SubjectType) async {
        do {
            // 1. 새로운 ProblemSet 인스턴스 생성
            let updatedSet = ProblemSet(
                id: UUID().uuidString,  // 새로운 ID 생성
                subject: newSubject,
                subjectType: newSubject is DefaultSubject ? "default" : "custom",
                subjectId: newSubject.id,
                subjectName: newSubject.displayName,
                questions: problemSet.questions,
                createdAt: problemSet.createdAt,
                educationLevel: problemSet.educationLevel,
                name: problemSet.name
            )
            
            // 2. 기존 ProblemSet 삭제
            try await coreDataService.deleteProblemSet(problemSet)
            
            // 3. 메모리에서 기존 ProblemSet 제거
            problemSets.removeAll { $0.id == problemSet.id }
            
            // 4. 새로운 ProblemSet 저장
            try await coreDataService.saveProblemSet(updatedSet)
            problemSets.append(updatedSet)
            
            // 5. selectedProblemSet 업데이트
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = updatedSet
            }
            
            // 6. UI 업데이트
            objectWillChange.send()
            
            print("""
            ✅ Problem Set subject updated:
            • Old Subject: \(problemSet.subjectName)
            • New Subject: \(newSubject.displayName)
            • Old ID: \(problemSet.id)
            • New ID: \(updatedSet.id)
            """)
        } catch {
            print("❌ Failed to update problem set subject: \(error)")
        }
    }
    
    @MainActor
    func removeQuestionFromProblemSet(_ questionId: String, from problemSet: ProblemSet) async {
        let updatedProblemSet = problemSet.removeQuestion(questionId)
        
        do {
            try await coreDataService.saveProblemSet(updatedProblemSet)
            
            // UI 업데이트를 MainActor에서 한번에 처리
            await MainActor.run {
                if let index = problemSets.firstIndex(where: { $0.id == problemSet.id }) {
                    problemSets[index] = updatedProblemSet
                }
                
                if selectedProblemSet?.id == problemSet.id {
                    selectedProblemSet = updatedProblemSet
                }
                
                // 명시적으로 UI 업데이트 알림
                objectWillChange.send()
            }
            
            print("""
            ✅ Question removed successfully:
            • Problem Set: \(problemSet.id)
            • Updated question count: \(updatedProblemSet.questions.count)
            """)
        } catch {
            print("❌ Failed to remove question: \(error)")
        }
    }
    
    @MainActor
    func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("🔵 HomeViewModel - Initial data loading")
            // 로컬 데이터 로드
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            // 원격 메타데이터 로드
            isLoadingRemote = true
            do {
                self.remoteSets = try await remoteService.fetchQuestionSets()
                print("✅ Successfully loaded remote sets: \(remoteSets.count)")
            } catch {
                print("⚠️ Remote data loading failed: \(error.localizedDescription)")
                self.remoteSets = []
            }
            isLoadingRemote = false
            
            hasLoadedData = true
            print("✅ Initial data loaded - Local sets: \(loadedProblemSets.count), Remote sets: \(remoteSets.count)")
            
        } catch {
            isLoadingRemote = false
            print("❌ Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("🔵 HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // 최근 ProblemSet을 selectedProblemSet으로 설정
            if selectedProblemSet == nil && !problemSets.isEmpty {
                await setSelectedProblemSet(problemSets[0])  // await 추가
            }
            
            print("✅ Loaded problem sets: \(problemSets.count)")
            print("✅ Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("❌ Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // 원격 세트 다운로드 메서드 추가
    @MainActor
    func downloadQuestionSet(_ remoteSet: RemoteQuestionSet) async {
        do {
            print("🌐 Downloading question set: \(remoteSet.id)")
            
            // 상세 데이터 가져오기
            let detailedSet = try await remoteService.fetchQuestionSet(remoteSet.id)
            
            // ProblemSet으로 변환
            let problemSet = ProblemSet(
                subject: DefaultSubject.download,
                subjectType: "default",
                subjectId: DefaultSubject.download.rawValue,
                subjectName: "Downloaded Sets",
                questions: detailedSet.questions,
                createdAt: remoteSet.createdAt,
                educationLevel: determineEducationLevel(from: remoteSet.difficulty),
                name: remoteSet.title
            )
            
            // CoreData에 저장
            await saveProblemSet(problemSet)
            
            print("✅ Successfully downloaded and saved question set: \(remoteSet.title)")
            
            // 다운로드 상태 업데이트
            if let index = remoteSets.firstIndex(where: { $0.id == remoteSet.id }) {
                remoteSets[index].isDownloaded = true
            }
            
        } catch {
            print("❌ Failed to download question set: \(error)")
        }
    }
    
    private func determineEducationLevel(from difficulty: String) -> EducationLevel {
        switch difficulty.lowercased() {
        case "elementary": return .elementary
        case "middle": return .middle
        case "high": return .high
        case "college": return .college
        default: return .elementary
        }
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            // 1. 기존 ProblemSet 찾기
            if let existingSet = problemSets.first(where: {
                $0.questions == problemSet.questions && $0.id != problemSet.id
            }) {
                // 2. 기존 ProblemSet 삭제
                try await coreDataService.deleteProblemSet(existingSet)
                problemSets.removeAll { $0.id == existingSet.id }
            }

            // 3. 새로운 ProblemSet 저장
            try await coreDataService.saveProblemSet(problemSet)
            problemSets.insert(problemSet, at: 0)
            
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = problemSet
            }
            
            print("✅ Successfully updated ProblemSet with new subject: \(problemSet.subjectName)")
        } catch {
            self.error = error
            print("❌ Failed to update ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) async {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("🔵 HomeViewModel - Setting selected problem set")
        
        if let problemSet = problemSet {
            let updatedProblemSets = try? await coreDataService.fetchProblemSets()
            if let updatedSet = updatedProblemSets?.first(where: { $0.id == problemSet.id }) {
                self.selectedProblemSet = updatedSet
                if let studyVM = studyViewModel {
                    await studyVM.resetState()
                    await studyVM.loadUpdatedQuestions(updatedSet.id)
                }
                print("✅ ProblemSet set successfully with latest data:")
                print("• ID: \(updatedSet.id)")
                print("• Questions: \(updatedSet.questions.count)")
            }
        } else {
            self.selectedProblemSet = nil
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("❌ Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("❌ Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                📝 Stored ProblemSets:
                • Count: \(storedSets.count)
                • Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("❌ Failed to verify storage: \(error)")
            }
        }
    }
}

extension HomeViewModel {
    @MainActor
    func renameProblemSet(_ problemSet: ProblemSet, newName: String) async {
        // 빈 이름이나 공백만 있는 경우 처리 방지
        let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else {
            print("❌ Cannot rename problem set: Name is empty")
            return
        }

        do {
            // 1. CoreData 업데이트
            try await coreDataService.updateProblemSet(problemSet, newName: trimmedName)
            
            await MainActor.run {
                // 2. 새로운 ProblemSet 인스턴스 생성
                let updatedSet = ProblemSet(
                    id: problemSet.id,
                    subject: problemSet.subject,
                    subjectType: problemSet.subjectType,
                    subjectId: problemSet.subjectId,
                    subjectName: problemSet.subjectName,
                    questions: problemSet.questions,
                    createdAt: problemSet.createdAt,
                    educationLevel: problemSet.educationLevel,
                    name: trimmedName  // trimmed된 이름 사용
                )
                
                // 3. problemSets 배열 업데이트
                if let index = self.problemSets.firstIndex(where: { $0.id == problemSet.id }) {
                    self.problemSets[index] = updatedSet
                }
                
                // 4. selectedProblemSet 업데이트
                if self.selectedProblemSet?.id == problemSet.id {
                    self.selectedProblemSet = updatedSet
                }
            }
            
            print("""
            ✅ Problem Set renamed successfully:
            • ID: \(problemSet.id)
            • Old Name: \(problemSet.name)
            • New Name: \(trimmedName)
            • Memory Update: Success
            """)
        } catch {
            print("❌ Failed to rename problem set: \(error)")
        }
    }
    
    @MainActor
    func deleteProblemSet(_ problemSet: ProblemSet) async {
        do {
            try await coreDataService.deleteProblemSet(problemSet)
            problemSets.removeAll { $0.id == problemSet.id }
            
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = nil
            }
            
            print("""
            ✅ Problem Set deleted:
            • ID: \(problemSet.id)
            • Name: \(problemSet.name)
            """)
        } catch {
            self.error = error
            print("❌ Failed to delete problem set: \(error)")
        }
    }
}


// ./AISnapStudy/ViewModels/ReviewViewModel.swift


import Foundation

@MainActor
class ReviewViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            📚 Review Data Loaded:
            • Study Sessions: \(studySessions.count)
            • Problem Sets: \(problemSets.count)
            • Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("❌ Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("✅ Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("❌ Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("📱 HomeViewModel reference set in ReviewViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


// ./AISnapStudy/ViewModels/DetailedStatsViewModel.swift


import Foundation
import SwiftUI
import Combine

@MainActor
class DetailedStatsViewModel: ObservableObject {
    @Published private(set) var dailyStats: [DailyStats] = []
    @Published private(set) var streakInfo: StreakInfo
    @Published private(set) var monthlyData: [Date: [DailyStats]] = [:]
    
    private let calendar = Calendar.current
    
    init() {
        self.streakInfo = StreakInfo(currentStreak: 0, longestStreak: 0, lastActiveDate: Date())
        loadStats()
    }
    
    func loadStats() {
        // Load saved stats from UserDefaults or CoreData
    }
    
    func updateDailyStats(correctAnswers: Int, totalQuestions: Int) {
        let today = Date()
        let newStats = DailyStats(
            id: UUID(), // UUID().uuidString 대신 UUID() 사용
            date: today,
            totalQuestions: totalQuestions,
            correctAnswers: correctAnswers,
            wrongAnswers: totalQuestions - correctAnswers,
            timeSpent: 0  // 기본값 사용
        )
        
        dailyStats.append(newStats)
        updateStreak(date: today)
        updateMonthlyData()
    }
    
    private func updateStreak(date: Date) {
        let yesterday = calendar.date(byAdding: .day, value: -1, to: date)!
        
        if calendar.isDate(date, inSameDayAs: streakInfo.lastActiveDate) {
            // Same day, no streak update needed
            return
        } else if calendar.isDate(yesterday, inSameDayAs: streakInfo.lastActiveDate) {
            // Consecutive day
            let newStreak = streakInfo.currentStreak + 1
            streakInfo = StreakInfo(
                currentStreak: newStreak,
                longestStreak: max(newStreak, streakInfo.longestStreak),
                lastActiveDate: date
            )
        } else {
            // Streak broken
            streakInfo = StreakInfo(
                currentStreak: 1,
                longestStreak: streakInfo.longestStreak,
                lastActiveDate: date
            )
        }
    }
    
    private func updateMonthlyData() {
        monthlyData = Dictionary(grouping: dailyStats) { stats in
            calendar.startOfMonth(for: stats.date)
        }
    }
}



// ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
    // OpenAIService 타입 참조 추가
    typealias QuestionInput = OpenAIService.QuestionInput
    typealias QuestionParameters = OpenAIService.QuestionParameters
    private weak var statViewModel: StatViewModel?

    @Published private(set) var loadedQuestions: [Question] = []
    @Published private(set) var loadingProgress = 0

    private let openAIService: OpenAIService

    @Published private(set) var currentQuestion: Question?
    @Published var selectedAnswer: String?
    @Published var showExplanation = false
    private var questions: [Question] = []
    private var cancellables = Set<AnyCancellable>()
    @Published private(set) var currentIndex = 0
    @Published var correctAnswers: Int = 0

    // 질문 생성 관련 프로퍼티 추가
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    
    func setStatViewModel(_ viewModel: StatViewModel) {
        self.statViewModel = viewModel
        print("StatViewModel connected: \(viewModel)")  // 연결 확인 로그
    }

    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }

    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }

    var totalQuestions: Int {
        questions.count
    }

    private let context: NSManagedObjectContext
    private var currentSession: CDStudySession?
    private let homeViewModel: HomeViewModel

    private var hasInitialized = false

    init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
        self.context = context
        self.homeViewModel = homeViewModel
        
        // OpenAIService 싱글톤 인스턴스 사용
        self.openAIService = OpenAIService.shared

        Task { @MainActor in
            homeViewModel.$selectedProblemSet
                .compactMap { $0 }
                .removeDuplicates(by: { $0.id == $1.id })
                .receive(on: RunLoop.main)
                .sink { [weak self] problemSet in
                    guard let self = self else { return }
                    Task {
                        await self.resetState()
                        await MainActor.run {
                            self.loadQuestions(problemSet.questions)
                        }
                    }
                }
                .store(in: &self.cancellables)
        }

        setupCurrentSession()
    }


    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []

        // 예상되는 총 질문 수 계산
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)

        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            await MainActor.run {
                questions.forEach { question in
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }

        await MainActor.run {
            isGeneratingQuestions = false
            loadedQuestions = generatedQuestions
            loadingProgress = 100
            isLoadingQuestions = false
        }
    }
    
    @MainActor
    func loadUpdatedQuestions(_ problemSetId: String) async {
        if let updatedSet = try? await homeViewModel.fetchUpdatedProblemSet(problemSetId) {
            questions = updatedSet.questions
            currentQuestion = questions.first
            print("📝 Loaded updated questions from CoreData - count: \(updatedSet.questions.count)")
        }
    }
    
   
    @MainActor
    func resetState() async {
        print("🔄 Performing complete state reset")
        currentIndex = 0
        selectedAnswer = nil
        showExplanation = false
        correctAnswers = 0
        
        questions.removeAll()
        
        if let problemSet = homeViewModel.selectedProblemSet {
            // CoreData에서 최신 상태 가져오기 시도
            if let updatedSet = try? await homeViewModel.fetchUpdatedProblemSet(problemSet.id) {
                questions = updatedSet.questions
                currentQuestion = updatedSet.questions.first
                print("📝 Updated questions loaded from CoreData - count: \(updatedSet.questions.count)")
            } else {
                // 실패 시 메모리의 문제 세트 사용
                questions = problemSet.questions
                currentQuestion = problemSet.questions.first
                print("⚠️ Using memory cached questions - count: \(problemSet.questions.count)")
            }
        }
        
        print("""
        ✅ State reset complete:
        • Questions count: \(questions.count)
        • Current index: \(currentIndex)
        • Current question: \(currentQuestion?.question ?? "No question loaded")
        """)
    }
   
    @MainActor
    func loadQuestions(_ newQuestions: [Question]) {
        guard questions != newQuestions else {
            print("⚠️ Same questions already loaded, skipping")
            return
        }
        
        print("📝 Loading fresh set of \(newQuestions.count) questions")
        questions = newQuestions
        currentIndex = 0
        currentQuestion = questions.isEmpty ? nil : questions[0]
        
        print("✅ Questions loaded: \(currentQuestion?.question ?? "No question loaded")")
    }
   
    private func setupCurrentSession() {
        let session = CDStudySession(context: context)
        session.startTime = Date()
        session.questions = NSSet() // Initialize empty questions set
        currentSession = session
        saveContext()
        print("📝 New study session created at: \(session.startTime?.description ?? "unknown")")
    }
   
    func submitAnswer() {
        guard let currentQuestion = currentQuestion else { return }
        
        let trimmedSelected = selectedAnswer?.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedCorrect = currentQuestion.correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let isCorrect = trimmedSelected == trimmedCorrect
        
        if isCorrect {
            correctAnswers += 1
        }
        
        // StatViewModel 업데이트 및 CoreData 저장
        NotificationCenter.default.post(
            name: .studyProgressDidUpdate,
            object: nil,
            userInfo: [
                "currentIndex": currentIndex + 1,
                "correctAnswers": correctAnswers
            ]
        )
        
        showExplanation = true
    }
    
    
   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
    private func saveContext() {
        do {
            if context.hasChanges {
                try context.save()
                print("✅ Context saved successfully")
            }
        } catch {
            print("❌ Failed to save context: \(error)")
        }
    }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("✅ Question save state toggled successfully")
       } catch {
           print("❌ Failed to toggle question save state: \(error)")
       }
   }
}


// ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @State private var isLoading = true

    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
        setupMetal()
    }

    var body: some Scene {
        WindowGroup {
            if isLoading {
                AnimatedSplashScreen()
                    .onAppear {
                        // 애니메이션 완료 후 메인 화면으로 전환
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                            withAnimation(.easeOut(duration: 0.3)) {
                                isLoading = false
                            }
                        }
                    }
            } else {
                MainTabView()
                    .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
            }
        }
    }
    
    private func setupMetal() {
        // Metal 디바이스 체크
        guard MTLCreateSystemDefaultDevice() != nil else {
            print("Metal is not supported on this device")
            return
        }
        
        // MetalTools 프레임워크 초기화 지연
        DispatchQueue.main.async {
            // MetalTools 관련 작업
        }
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        
        // OpenAI API Key 초기 설정
        Task {
            do {
                try await OpenAIService.shared.fetchAPIKey()
                print("✅ Successfully initialized OpenAI API Key")
            } catch {
                print("❌ Failed to fetch OpenAI API Key: \(error)")
            }
        }
        
        return true
    }
    
    // 앱 종료 시 API Key 정리
    func applicationWillTerminate(_ application: UIApplication) {
        OpenAIService.shared.cleanup()
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        📊 CoreData Configuration:
        • Store Descriptions: \(container.persistentStoreDescriptions.count)
        • View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("❌ No store URL found")
            return
        }
        
        print("• Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("✅ Created CoreData directory")
        } catch {
            print("❌ Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData 옵션 설정
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // 성능 최적화 설정
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


struct AnimatedSplashScreen: View {
    @State private var isAnimating = false
    @State private var iconScale: CGFloat = 0.3
    @State private var titleOpacity = 0.0
    @State private var subtitleOpacity = 0.0
    
    var body: some View {
        ZStack {
            // 배경 그라데이션
            LinearGradient(
                gradient: Gradient(colors: [Color.blue, Color.blue.opacity(0.8)]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
            
            VStack(spacing: 20) {
                // 아이콘 애니메이션
                Image(systemName: "doc.text.viewfinder")
                    .font(.system(size: 80))
                    .foregroundColor(.white)
                    .scaleEffect(iconScale)
                    .rotationEffect(.degrees(isAnimating ? 360 : 0))
                
                // 앱 타이틀
                Text("AISnapStudy")
                    .font(.system(size: 36, weight: .bold))
                    .foregroundColor(.white)
                    .opacity(titleOpacity)
                
                // 서브타이틀
                Text("Learn Smarter with AI")
                    .font(.title3)
                    .foregroundColor(.white.opacity(0.8))
                    .opacity(subtitleOpacity)
                
                // 로딩 인디케이터
                if isAnimating {
                    LoadingDots()
                        .frame(height: 40)
                }
            }
        }
        .onAppear {
            withAnimation(.spring(response: 0.8, dampingFraction: 0.5)) {
                iconScale = 1.0
                isAnimating = true
            }
            
            withAnimation(.easeIn(duration: 0.4).delay(0.3)) {
                titleOpacity = 1.0
            }
            
            withAnimation(.easeIn(duration: 0.4).delay(0.5)) {
                subtitleOpacity = 1.0
            }
        }
    }
}

// 로딩 닷 애니메이션
struct LoadingDots: View {
    @State private var animationStage = 0
    
    var body: some View {
        HStack(spacing: 8) {
            ForEach(0..<3) { index in
                Circle()
                    .fill(Color.white)
                    .frame(width: 8, height: 8)
                    .scaleEffect(animationStage == index ? 1.5 : 1)
                    .opacity(animationStage == index ? 1 : 0.5)
            }
        }
        .onAppear {
            Timer.scheduledTimer(withTimeInterval: 0.4, repeats: true) { timer in
                withAnimation(.spring()) {
                    animationStage = (animationStage + 1) % 3
                }
            }
        }
    }
}

// 앱 스타일 설정
extension AISnapStudyApp {
    private func setupAppearance() {
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = UIColor.systemBackground
        appearance.titleTextAttributes = [.foregroundColor: UIColor.label]
        appearance.largeTitleTextAttributes = [.foregroundColor: UIColor.label]
        
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        UINavigationBar.appearance().compactAppearance = appearance
        
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        tabBarAppearance.backgroundColor = UIColor.systemBackground
        
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}


// ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


// ./AISnapStudy/Utils/Extensions/Calendar+Extension.swift

import Foundation

extension Calendar {
    
    func monthDateRange(for date: Date) -> (start: Date, end: Date) {
        let components = dateComponents([.year, .month], from: date)
        let startOfMonth = self.date(from: components)!
        
        var nextMonthComponents = DateComponents()
        nextMonthComponents.month = 1
        let endOfMonth = self.date(
            byAdding: nextMonthComponents,
            to: startOfMonth
        )!
        
        return (startOfMonth, endOfMonth)
    }
    
    func startOfMonth(for date: Date) -> Date {
        let components = dateComponents([.year, .month], from: date)
        return self.date(from: components) ?? date
    }
    
    func endOfMonth(for date: Date) -> Date {
        guard let startOfNextMonth = self.date(
            byAdding: DateComponents(month: 1),
            to: startOfMonth(for: date)
        ) else { return date }
        
        return self.date(
            byAdding: DateComponents(second: -1),
            to: startOfNextMonth
        ) ?? date
    }
}


// ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


// ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


// ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



// ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


// ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


// ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    var questionsCompleted: Int
    var correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    var week: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd" // 월/일 형식
        return formatter.string(from: date)
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


// ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // 추가: Structured Outputs의 refusal 처리를 위해
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


// ./AISnapStudy/Models/ProblemSet.swift

import Foundation
import SwiftUI
import UniformTypeIdentifiers

public final class ProblemSet: Identifiable, Codable, Equatable {
    // Core properties
    public var isFavorite: Bool
    public let id: String
    public let subject: SubjectType
    public let subjectType: String
    public let subjectId: String
    public let subjectName: String
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?

    public var questionCount: Int {
        questions.count
    }
    
    // Equatable 프로토콜 구현
    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id && lhs.createdAt == rhs.createdAt
    }
    
    // Hashable 프로토콜 구현
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(createdAt)
    }

    public var resolvedSubject: SubjectType {
        if subjectType == "default" {
            return DefaultSubject(rawValue: subjectId) ?? .generalKnowledge
        } else {
            return SubjectManager.shared.customSubjects.first(where: { $0.id == subjectId }) ?? DefaultSubject.generalKnowledge
        }
    }
    

    // CustomSubject를 위한 생성자
    public init(
        id: String = UUID().uuidString,
        subject: SubjectType,
        subjectType: String,
        subjectId: String,
        subjectName: String,
        questions: [Question],
        createdAt: Date = Date(),
        educationLevel: EducationLevel,
        name: String,
        isFavorite: Bool = false  // 기본값 false로 설정
    ) {
        self.id = id
        self.subject = subject
        self.subjectType = subjectType
        self.subjectId = subjectId
        self.subjectName = subjectName
        self.questions = questions
        self.createdAt = createdAt
        self.educationLevel = educationLevel
        self.name = name
        self.tags = []
        self.problemSetDescription = nil
        self.isFavorite = isFavorite
    }
    
    // toggleFavorite 메서드 추가
    public func toggleFavorite() -> ProblemSet {
        return ProblemSet(
            id: self.id,
            subject: self.subject,
            subjectType: self.subjectType,
            subjectId: self.subjectId,
            subjectName: self.subjectName,
            questions: self.questions,
            createdAt: self.createdAt,
            educationLevel: self.educationLevel,
            name: self.name,
            isFavorite: !self.isFavorite  // toggle the favorite status
        )
    }
    

    private enum CodingKeys: String, CodingKey {
        case id, subject, subjectType, subjectId, subjectName
        case questions, createdAt, lastAttempted
        case educationLevel, name, tags
        case problemSetDescription, isFavorite
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        
        // Properly decode subject based on subjectType
        subjectType = try container.decode(String.self, forKey: .subjectType)
        subjectId = try container.decode(String.self, forKey: .subjectId)
        subjectName = try container.decode(String.self, forKey: .subjectName)
        
        if subjectType == "custom" {
            subject = CustomSubject(id: subjectId, name: subjectName, icon: "book.fill")
        } else {
            subject = try container.decode(DefaultSubject.self, forKey: .subject)
        }
        
        // Decode remaining properties
        questions = try container.decode([Question].self, forKey: .questions)
        createdAt = try container.decode(Date.self, forKey: .createdAt)
        lastAttempted = try container.decodeIfPresent(Date.self, forKey: .lastAttempted)
        educationLevel = try container.decode(EducationLevel.self, forKey: .educationLevel)
        name = try container.decode(String.self, forKey: .name)
        tags = try container.decode([String].self, forKey: .tags)
        problemSetDescription = try container.decodeIfPresent(String.self, forKey: .problemSetDescription)
        isFavorite = try container.decode(Bool.self, forKey: .isFavorite)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(subject, forKey: .subject)
        try container.encode(subjectType, forKey: .subjectType)
        try container.encode(subjectId, forKey: .subjectId)
        try container.encode(subjectName, forKey: .subjectName)
        try container.encode(questions, forKey: .questions)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(lastAttempted, forKey: .lastAttempted)
        try container.encode(educationLevel, forKey: .educationLevel)
        try container.encode(name, forKey: .name)
        try container.encode(tags, forKey: .tags)
        try container.encodeIfPresent(problemSetDescription, forKey: .problemSetDescription)
        try container.encode(isFavorite, forKey: .isFavorite)
    }
    
    // 질문 삭제 메소드 추가
    public func removeQuestion(_ questionId: String) -> ProblemSet {
        let updatedQuestions = questions.filter { $0.id != questionId }
        return ProblemSet(
            id: self.id,
            subject: self.subject,
            subjectType: self.subjectType,
            subjectId: self.subjectId,
            subjectName: self.subjectName,
            questions: updatedQuestions,
            createdAt: self.createdAt,
            educationLevel: self.educationLevel,
            name: self.name
        )
    }
    
    static func merge(problemSets: [ProblemSet], name: String) -> ProblemSet {
        let mergedQuestions = problemSets.flatMap { $0.questions }
        let firstSet = problemSets[0]
        
        return ProblemSet(
            id: UUID().uuidString,
            subject: firstSet.subject,
            subjectType: firstSet.subjectType,
            subjectId: firstSet.subjectId,
            subjectName: firstSet.subjectName,
            questions: mergedQuestions,
            createdAt: Date(),
            educationLevel: firstSet.educationLevel,
            name: name
        )
    }
}

// ProblemSet extension 추가
extension ProblemSet: Transferable {
    public static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .problemSet)
    }
}

// UTType extension 추가
extension UTType {
    static var problemSet: UTType {
        UTType(exportedAs: "com.aisnapquiz.problemset")
    }
}

extension ProblemSet {
    static func merge(_ sets: [ProblemSet], name: String) -> ProblemSet {
        let allQuestions = sets.flatMap { $0.questions }
        // 첫 번째 세트의 속성들을 기본값으로 사용
        let firstSet = sets[0]
        
        return ProblemSet(
            id: UUID().uuidString,
            subject: firstSet.subject,
            subjectType: firstSet.subjectType,
            subjectId: firstSet.subjectId,
            subjectName: firstSet.subjectName,
            questions: allQuestions,
            createdAt: Date(),
            educationLevel: firstSet.educationLevel,
            name: name,
            isFavorite: firstSet.isFavorite  // 즐겨찾기 상태 유지
        )
    }
}


// ./AISnapStudy/Models/ReviewFilter.swift


import Foundation

enum ReviewFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



// ./AISnapStudy/Models/PurchaseProduct.swift


import Foundation


struct UserSubscriptionStatus: Codable {
    var isPremium: Bool
    var dailyQuestionsRemaining: Int
    var lastResetDate: Date?
    
    static let defaultStatus = UserSubscriptionStatus(
        isPremium: false,
        dailyQuestionsRemaining: 1,
        lastResetDate: nil
    )
}


// ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
   case multipleChoice = "multiple_choice"
   case trueFalse = "true_false"
}

public struct Question: Identifiable, Codable, Hashable {
   public let id: String
   public let type: QuestionType
   public let subject: DefaultSubject  // Subject를 DefaultSubject로 변경
   public let question: String
   public let options: [String]
   public let correctAnswer: String
   public let explanation: String
   public let hint: String?
   public var isSaved: Bool
   public let createdAt: Date
   
   private enum CodingKeys: String, CodingKey {
       case id, type, subject, question, options
       case correctAnswer, explanation, hint
       case isSaved, createdAt
   }
   
   public init(
       id: String,
       type: QuestionType,
       subject: DefaultSubject,  // Subject를 DefaultSubject로 변경
       question: String,
       options: [String] = [],
       correctAnswer: String,
       explanation: String,
       hint: String? = nil,
       isSaved: Bool = false,
       createdAt: Date = Date()
   ) {
       self.id = id
       self.type = type
       self.subject = subject
       self.question = question
       self.options = options
       self.correctAnswer = correctAnswer
       self.explanation = explanation
       self.hint = hint
       self.isSaved = isSaved
       self.createdAt = createdAt
   }
   
   // Decodable 구현
   public init(from decoder: Decoder) throws {
       let container = try decoder.container(keyedBy: CodingKeys.self)
       
       id = try container.decode(String.self, forKey: .id)
       type = try container.decode(QuestionType.self, forKey: .type)
       subject = try container.decode(DefaultSubject.self, forKey: .subject)
       question = try container.decode(String.self, forKey: .question)
       options = try container.decode([String].self, forKey: .options)
       correctAnswer = try container.decode(String.self, forKey: .correctAnswer)
       explanation = try container.decode(String.self, forKey: .explanation)
       hint = try container.decodeIfPresent(String.self, forKey: .hint)
       isSaved = try container.decode(Bool.self, forKey: .isSaved)
       createdAt = try container.decode(Date.self, forKey: .createdAt)
   }
    // Hashable 프로토콜 요구사항을 여기에 직접 구현
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
   
   // Encodable 구현
   public func encode(to encoder: Encoder) throws {
       var container = encoder.container(keyedBy: CodingKeys.self)
       
       try container.encode(id, forKey: .id)
       try container.encode(type, forKey: .type)
       try container.encode(subject, forKey: .subject)
       try container.encode(question, forKey: .question)
       try container.encode(options, forKey: .options)
       try container.encode(correctAnswer, forKey: .correctAnswer)
       try container.encode(explanation, forKey: .explanation)
       try container.encodeIfPresent(hint, forKey: .hint)
       try container.encode(isSaved, forKey: .isSaved)
       try container.encode(createdAt, forKey: .createdAt)
   }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
   public static var supportsSecureCoding: Bool {
       return true
   }
   
   let question: Question
   
   init(question: Question) {
       self.question = question
       super.init()
   }
   
   public func encode(with coder: NSCoder) {
       coder.encode(question.id, forKey: "id")
       coder.encode(question.type.rawValue, forKey: "type")
       coder.encode(question.subject.rawValue, forKey: "subject")
       coder.encode(question.question, forKey: "question")
       coder.encode(question.options, forKey: "options")
       coder.encode(question.correctAnswer, forKey: "correctAnswer")
       coder.encode(question.explanation, forKey: "explanation")
       coder.encode(question.hint, forKey: "hint")
       coder.encode(question.isSaved, forKey: "isSaved")
       coder.encode(question.createdAt, forKey: "createdAt")
   }
   
   public required init?(coder: NSCoder) {
       guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
             let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
             let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
             let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
             let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
             let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
             let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
           return nil
       }
       
       let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
       let isSaved = coder.decodeBool(forKey: "isSaved")
       let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
       
       let question = Question(
           id: id,
           type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
           subject: DefaultSubject(rawValue: subjectRaw) ?? .generalKnowledge,  // Subject를 DefaultSubject로 변경
           question: questionText,
           options: options,
           correctAnswer: correctAnswer,
           explanation: explanation,
           hint: hint,
           isSaved: isSaved,
           createdAt: createdAt
       )
       
       self.question = question
       super.init()
   }
}

extension Question {
    var processedCorrectAnswer: String {
        switch type {
        case .trueFalse:
            return correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        case .multipleChoice:
            return correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines)
        }
    }
}


// ./AISnapStudy/Models/UserStats.swift

import Foundation

struct StreakInfo: Codable {
    let currentStreak: Int
    let longestStreak: Int
    let lastActiveDate: Date
}


// ./AISnapStudy/Models/Subject.swift


import SwiftUI

// MARK: - Basic Subject Protocol
public protocol SubjectType: Codable {
   var id: String { get }
   var displayName: String { get }
   var color: Color { get }
   var icon: String { get }
   var rawValue: String { get }  // 추가
}



// MARK: - Default System Subjects
public enum DefaultSubject: String, Codable, CaseIterable, SubjectType {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    case download = "download"  // 새로운 case 추가
    
    public var id: String {
        self.rawValue
    }
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        case .download:
            return .blue  // 다운로드 섹션을 위한 새로운 색상
        }
    }
    
    static var defaultSubject: DefaultSubject {
        return .generalKnowledge
    }
    
    public var displayName: String {
        SubjectManager.shared.modifiedDefaultSubjects[self.id] ?? defaultDisplayName
    }
    
    private var defaultDisplayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        case .download:
            return "Downloaded Sets"  // 다운로드된 세트를 위한 표시 이름
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        case .download:
            return "square.and.arrow.down.fill"  // 다운로드 아이콘
        }
    }
}

// CustomSubject 구조체 추가
public struct CustomSubject: SubjectType, Codable, Identifiable {
    public let id: String
    public var name: String  // let을 var로 변경
    public let icon: String
    public var isActive: Bool
    
    // SubjectType 프로토콜 요구사항
    public var displayName: String { name }
    public var color: Color { .green }  // 계산 프로퍼티로 변경
    public var rawValue: String { id }  // 추가: id를 rawValue로 사용
    
    // 기본 초기화자
    public init(id: String = UUID().uuidString,
                name: String,
                icon: String,
                isActive: Bool = true) {
        self.id = id
        self.name = name
        self.icon = icon
        self.isActive = isActive
    }
    
    // Codable 구현
    enum CodingKeys: String, CodingKey {
        case id, name, icon, isActive
        // color는 제외 - 항상 .green을 사용할 것이므로
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        icon = try container.decode(String.self, forKey: .icon)
        isActive = try container.decode(Bool.self, forKey: .isActive)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(icon, forKey: .icon)
        try container.encode(isActive, forKey: .isActive)
    }
}



// MARK: - Custom User Subject
public struct UserSubject: Identifiable, Codable, Hashable, SubjectType {
   public let id: String
   public var name: String
   public var colorHex: String
   public var iconName: String
   public var createdAt: Date
   public var isActive: Bool
   
   public var displayName: String {
       name
   }
   
   public var color: Color {
       Color(hex: colorHex) ?? .gray
   }
   
   public var icon: String {
       iconName
   }
    
    public var rawValue: String { id }  // 추가: id를 rawValue로 사용
}

// MARK: - Education Level
public enum EducationLevel: String, Codable, CaseIterable {
   case elementary = "elementary"
   case middle = "middle"
   case high = "high"
   case college = "college"
   
   public var displayName: String {
       switch self {
       case .elementary:
           return "Elementary"
       case .middle:
           return "Middle"
       case .high:
           return "High"
       case .college:
           return "College"
       }
   }
   
   public var color: Color {
       switch self {
       case .elementary:
           return .green
       case .middle:
           return .green
       case .high:
           return .green
       case .college:
           return .green
       }
   }
}

public class SubjectManager: ObservableObject {
    public static let shared = SubjectManager()
    
    private init() {
        loadSettings()
        loadCustomSubjects()
    }
    
    @Published private(set) var customSubjects: [CustomSubject] = []
    @Published private(set) var hiddenDefaultSubjects: Set<String> = []
    @Published private(set) var modifiedDefaultSubjects: [String: String] = [:]
    
    // 새로운 과목 추가
    func addCustomSubject(name: String, icon: String = "book.circle") {
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveCustomSubjects()
    }
    
    // 과목 제거
    func removeCustomSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveCustomSubjects()
    }
    
    // UserDefaults를 사용한 저장 및 로드
    private func saveCustomSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    private func loadCustomSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            self.customSubjects = decoded
        }
    }
    
    // "삭제된" 과목 복원을 위한 백업 저장
    private var deletedSubjectsBackup: Set<String> = []
    
    func isDeleted(_ subjectId: String) -> Bool {
            return hiddenDefaultSubjects.contains(subjectId)
        }
        
    func toggleDefaultSubject(_ subject: DefaultSubject) {
        print("🔄 Toggling subject visibility: \(subject.displayName)")
        if hiddenDefaultSubjects.contains(subject.id) {
            print("➖ Removing from hidden: \(subject.id)")
            hiddenDefaultSubjects.remove(subject.id)
        } else {
            print("➕ Adding to hidden: \(subject.id)")
            hiddenDefaultSubjects.insert(subject.id)
        }
        saveAndNotify()
        print("📊 Current hidden subjects: \(hiddenDefaultSubjects)")
    }
        
    private func saveAndNotify() {
        saveSettings()
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    // 로드 시 UserDefaults에서 설정 불러오기
    private func loadSettings() {
        if let hidden = UserDefaults.standard.array(forKey: "hiddenDefaultSubjects") as? [String] {
            hiddenDefaultSubjects = Set(hidden)
        }
        modifiedDefaultSubjects = UserDefaults.standard.dictionary(forKey: "modifiedDefaultSubjects") as? [String: String] ?? [:]
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
        }
        // 변경사항을 알림
        notifySubjectsChange()
    }

    
    // 과목 이름 업데이트 함수 수정
    func updateDefaultSubjectName(_ subject: DefaultSubject, newName: String) {
        print("✏️ Updating name for subject: \(subject.displayName) to: \(newName)")
        modifiedDefaultSubjects[subject.id] = newName
        print("💾 Current modified names: \(modifiedDefaultSubjects)")
        saveAndNotify()
    }
    
    // 과목 이름 초기화 함수 수정
    func resetDefaultSubjectName(_ subject: DefaultSubject) {
        modifiedDefaultSubjects.removeValue(forKey: subject.id)
        saveAndNotify()
    }
    
    // 변경사항 알림을 위한 NotificationCenter 키
    static let subjectsDidChangeNotification = Notification.Name("SubjectsDidChange")
    
    private func notifySubjectsChange() {
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    
    // 과목 "삭제" (실제로는 숨김)
    func deleteDefaultSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.insert(subject.id)
        deletedSubjectsBackup.insert(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // 삭제된 과목 복원
    func restoreDeletedSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.remove(subject.id)
        deletedSubjectsBackup.remove(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // 과목이 "삭제"되었는지 확인
    func isDeleted(_ subject: DefaultSubject) -> Bool {
        hiddenDefaultSubjects.contains(subject.id)
    }
    
    // 사용 가능한(삭제되지 않은) 과목들 가져오기
    var availableSubjects: [any SubjectType] {
        let visibleDefaultSubjects = DefaultSubject.allCases.filter { !hiddenDefaultSubjects.contains($0.id) }
        let activeCustomSubjects = customSubjects.filter { $0.isActive }
        return visibleDefaultSubjects + activeCustomSubjects
    }
    
    // 저장된 설정에 삭제된 과목 정보 포함
    private func saveSettings() {
        UserDefaults.standard.set(Array(hiddenDefaultSubjects), forKey: "hiddenDefaultSubjects")
        UserDefaults.standard.set(Array(deletedSubjectsBackup), forKey: "deletedSubjectsBackup")
        UserDefaults.standard.set(modifiedDefaultSubjects, forKey: "modifiedDefaultSubjects")
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    
    

    
    // 기본 과목 이름 관리 메서드 추가
    func getDisplayName(for subject: DefaultSubject) -> String {
        return modifiedDefaultSubjects[subject.id] ?? subject.displayName
    }
    

    
    // CustomSubject 관리 메서드
    func updateSubject(_ subject: CustomSubject, newName: String) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].name = newName
            saveSettings()
        }
    }
    
    func toggleSubjectActive(_ subject: CustomSubject) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].isActive.toggle()
            saveSettings()
        }
    }
    
    func deleteSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveSettings()
    }
    

    
    // 기본 과목 숨김 상태 관리
        func toggleSubjectVisibility(_ subject: DefaultSubject) {
            if hiddenDefaultSubjects.contains(subject.id) {
                hiddenDefaultSubjects.remove(subject.id)
            } else {
                hiddenDefaultSubjects.insert(subject.id)
            }
            saveSettings()
        }
        
        // 과목이 숨겨져 있는지 확인
        func isHidden(_ subject: DefaultSubject) -> Bool {
            hiddenDefaultSubjects.contains(subject.id)
        }
        
        
        // 모든 활성화된 과목 가져오기 (숨겨지지 않은 기본 과목 + 활성화된 사용자 정의 과목)
    var allSubjects: [SubjectType] {
        var subjects: [SubjectType] = Array(DefaultSubject.allCases)
        subjects.append(contentsOf: customSubjects.filter { $0.isActive })
        return subjects
    }
    
    
    // 과목 추가 메서드 수정
    func addSubject(name: String, icon: String) {  // color 매개변수 제거
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveSubjects()
        
        print("""
        ✅ Added new custom subject:
        • Name: \(name)
        • ID: \(newSubject.id)
        • Total custom subjects: \(customSubjects.count)
        """)
    }
    
    // 저장 메서드 수정
    private func saveSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
            print("💾 Saved \(customSubjects.count) custom subjects to UserDefaults")
        }
    }
    
    // 로드 메서드 수정
    private func loadSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
            print("📤 Loaded \(customSubjects.count) custom subjects from UserDefaults")
            print("📚 Custom Subjects: \(customSubjects.map { $0.displayName })")
        }
    }
    
}



// MARK: - Color Extension for Hex
extension Color {
    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components else { return nil }
        
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        let hex = String(format: "%02lX%02lX%02lX",
                        lroundf(r * 255),
                        lroundf(g * 255),
                        lroundf(b * 255))
        
        return hex
    }
    
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        
        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else {
            return nil
        }
        
        let r = Double((rgb & 0xFF0000) >> 16) / 255.0
        let g = Double((rgb & 0x00FF00) >> 8) / 255.0
        let b = Double(rgb & 0x0000FF) / 255.0
        
        self.init(red: r, green: g, blue: b)
    }
}


// ./AISnapStudy/Models/DailyStats.swift



import Foundation

struct DailyStats: Identifiable, Codable {
    let id: UUID
    let date: Date
    let totalQuestions: Int
    let correctAnswers: Int
    let wrongAnswers: Int
    let timeSpent: TimeInterval
    
    var accuracy: Double {
        guard totalQuestions > 0 else { return 0 }
        return Double(correctAnswers) / Double(totalQuestions) * 100
    }
    
    // 초기화자를 수정
    init(
        id: UUID = UUID(),
        date: Date,
        totalQuestions: Int,
        correctAnswers: Int,
        wrongAnswers: Int,
        timeSpent: TimeInterval = 0
    ) {
        self.id = id
        self.date = date
        self.totalQuestions = totalQuestions
        self.correctAnswers = correctAnswers
        self.wrongAnswers = wrongAnswers
        self.timeSpent = timeSpent
    }
}


// ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // 실제 구현에서는 저장 상태를 확인하는 로직 추가
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/RemoteQuestionSet.swift

import Foundation

// MARK: - Models
struct RemoteQuestionSet: Codable, Identifiable {
    let id: String
    let title: String
    let description: String
    let category: String
    let difficulty: String
    let questionCount: Int
    let downloadCount: Int
    let createdAt: Date
    let updatedAt: Date
    var isDownloaded: Bool = false  // 기본값 설정
    
    // CodingKeys를 명시적으로 정의하여 isDownloaded를 디코딩에서 제외
    private enum CodingKeys: String, CodingKey {
        case id, title, description, category
        case difficulty, questionCount, downloadCount
        case createdAt, updatedAt
        // isDownloaded는 CodingKeys에서 제외
    }
}


// ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


// ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


// ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    let onDelete: () -> Void // 추가
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text(question.question)
                    .font(.title3)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button(action: onDelete) {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
            
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


// ./AISnapStudy/Views/Question/QuestionSettingsView.swift



import SwiftUI
import PhotosUI
import UIKit
import AVFoundation

struct QuestionSettingsView: View {
    @FocusState private var isTextFieldFocused: Bool // 추가
    @StateObject private var viewModel: QuestionSettingsViewModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedTab: Int
    @State private var expandedSections: Set<SectionType> = []
    @State private var isTextInputSelected = false
    @State private var showNamePopup = false
    @State private var isGeneratingQuestions = false
    @State private var activeSheet: ActiveSheet?
    
    // 여기를 Subject에서 DefaultSubject로 변경
    let subject: DefaultSubject  // Subject를 DefaultSubject로 변경
    
    public enum SectionType: Hashable {
        case questionAbout
        case learningSubject
        case questionTypes
        case educationLevel
    }
    
    private enum ActiveSheet: Identifiable {
        case camera, gallery
        
        var id: Int {
            switch self {
            case .camera: return 1
            case .gallery: return 2
            }
        }
    }
    
    
    init(subject: DefaultSubject, homeViewModel: HomeViewModel, selectedTab: Binding<Int>) {
        self.subject = subject
        self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
            subject: subject,
            homeViewModel: homeViewModel
        ))
        self._selectedTab = selectedTab
    }
    
    var body: some View {
        ScrollViewReader { proxy in
            VStack(spacing: 0) {
                // Instructions Card
                Form {
                    // Speed Up and Language Selection Section
                    Section {
                        SpeedUpSection(useTextExtraction: $viewModel.useTextExtraction)
                    }
                    .listRowSpacing(0)
                    
                    Section {
                        LanguageSection(selectedLanguage: $viewModel.selectedLanguage)
                    }
                    .listRowSpacing(0)
                    
                    VStack(alignment: .leading, spacing: 10) {
                        Text("How to Generate Questions")
                            .font(.headline)
                            .padding(.bottom, 4)
                        
                        Text("Select one of these methods here and then choose Subject and Type to create questions:")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        // Input Methods with descriptions
                        HStack(spacing: 12) {
                            Group {
                                InputMethodCard(
                                    icon: "camera.fill",
                                    title: "Camera",
                                    isUsed: viewModel.hasSelectedCamera,
                                    isDisabled: !viewModel.canUseImageInput,
                                    action: {
                                        if viewModel.canUseImageInput {
                                            viewModel.isTextInputActive = false
                                            Task {
                                                if await viewModel.checkCameraPermission() {
                                                    activeSheet = .camera
                                                }
                                            }
                                        }
                                    }
                                )
                                .frame(maxWidth: .infinity)
                            }
                            
                            Group {
                                InputMethodCard(
                                    icon: "photo.fill",
                                    title: "Gallery",
                                    isUsed: viewModel.hasSelectedGallery,
                                    isDisabled: !viewModel.canUseImageInput,
                                    action: {
                                        if viewModel.canUseImageInput {
                                            viewModel.isTextInputActive = false
                                            Task {
                                                if await viewModel.checkGalleryPermission() {
                                                    activeSheet = .gallery
                                                }
                                            }
                                        }
                                    }
                                )
                                .frame(maxWidth: .infinity)
                            }
                            
                            Group {
                                InputMethodCard(
                                    icon: "text.bubble.fill",
                                    title: "Text",
                                    isUsed: viewModel.isTextInputActive,
                                    isDisabled: !viewModel.canUseTextInput,
                                    action: {
                                        viewModel.toggleTextInput()
                                        isTextFieldFocused = viewModel.isTextInputActive
                                    }
                                )
                                .frame(maxWidth: .infinity)
                            }
                        }
                    }
                    .padding()
                    .background(Color(.systemBackground))
                    .cornerRadius(12)
                    
                    // Text Input Field
                    if viewModel.isTextInputActive {
                        TextField("Enter your question here...", text: $viewModel.questionText)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .focused($isTextFieldFocused)
                            .padding(.horizontal)
                    }
                    
                    // Selected Images Display
                    if !viewModel.selectedImages.isEmpty {
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 12) {
                                ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                    SelectedImageCell(
                                        image: viewModel.selectedImages[index],
                                        onDelete: {
                                            viewModel.removeImage(at: index)
                                        }
                                    )
                                }
                            }
                            .padding(.vertical, 8)
                        }
                    }
                    
                    // Subject Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .learningSubject)
                        ) {
                            LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                        } label: {
                            HStack {
                                Text("Subject")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.selectedSubject.displayName)
                                    .foregroundColor(.gray)
                            }
                        }.id(SectionType.learningSubject) // ID 추가
                    }.listRowSpacing(0)
                    
                    if viewModel.isTextInputActive {
                        Section {
                            DisclosureGroup(
                                isExpanded: isExpandedBinding(for: .educationLevel)
                            ) {
                                EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                            } label: {
                                HStack {
                                    Text("Education")
                                        .font(.headline)
                                    Spacer()
                                    Text(viewModel.educationLevel.displayName)
                                        .foregroundColor(.gray)
                                }
                            }.id(SectionType.educationLevel) // ID 추가
                        }.listRowSpacing(0)
                    }
                    
                    // Question Types Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .questionTypes)
                        ) {
                            QuestionTypesSelectionSection(viewModel: viewModel)
                        } label: {
                            HStack {
                                Text("Type")
                                    .font(.headline)
                                Spacer()
                                Text("\(viewModel.totalQuestionCount) questions")
                                    .foregroundColor(.gray)
                            }
                        }.id(SectionType.questionTypes)
                    }.listRowSpacing(0)
                }
                .listSectionSpacing(4)
                
                // Generate Questions Button and Keyboard Dismiss Button
                VStack {
                    HStack {
                        Button(action: {
                            showNamePopup = true
                            isGeneratingQuestions = true
                            isTextFieldFocused = false  // 키보드 내리기
                            Task {
                                await viewModel.sendAllImages()
                            }
                        }) {
                            Text("Generate Questions")
                                .font(.headline)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                                .cornerRadius(10)
                        }
                        .disabled(!isGenerateButtonEnabled)
                        
                        // 텍스트 입력이 활성화되어 있을 때만 키보드 내리기 버튼 표시
                        if viewModel.isTextInputActive {
                            Button(action: {
                                isTextFieldFocused = false  // 키보드 내리기
                            }) {
                                Image(systemName: "keyboard.chevron.compact.down")
                                    .font(.title2)
                                    .foregroundColor(.blue)
                                    .padding(12)
                                    .background(Color.gray.opacity(0.1))
                                    .cornerRadius(10)
                            }
                        }
                    }
                    .padding()
                }
                .background(Color(UIColor.systemGroupedBackground))
            }
            .overlay(popupOverlay)
            .navigationBarItems(leading: cancelButton)
            .navigationBarTitleDisplayMode(.inline)
            .sheet(item: $activeSheet) { sheet in
                switch sheet {
                case .camera:
                    ImagePicker(
                        image: $viewModel.selectedImage,
                        sourceType: .camera,
                        onImageSelected: { image in
                            Task {
                                await viewModel.handleCameraImage(image)
                            }
                        }
                    )
                    .interactiveDismissDisabled()
                    
                case .gallery:
                    PhotoPicker(
                        selectedImages: $viewModel.selectedImages,
                        useSpeedUp: viewModel.useTextExtraction
                    )
                    .interactiveDismissDisabled()
                    
                }
            }
            .alert(isPresented: $viewModel.showAlert) {
                Alert(
                    title: Text(viewModel.alertTitle),
                    message: Text(viewModel.alertMessage),
                    dismissButton: .default(Text("OK")) {
                        if viewModel.alertTitle == "Success" {
                            dismiss()
                        }
                    }
                )
            }
            .onChange(of: viewModel.shouldShowStudyView) { show in
                if show {
                    dismiss()
                    selectedTab = 1
                }
            }
                    .background(Color(UIColor.systemGroupedBackground))
                    .overlay(popupOverlay)
                    .navigationBarItems(leading: cancelButton)
                    .navigationBarTitleDisplayMode(.inline)
                    .onChange(of: expandedSections) { _ in
                        scrollToActiveSection(using: proxy)
                    }
            }
        }
    
    private func scrollToActiveSection(using proxy: ScrollViewProxy) {
        if let activeSection = expandedSections.first {
            withAnimation {
                proxy.scrollTo(activeSection, anchor: .top) // 화면 상단에 고정
            }
        }
    }
    
        private var cancelButton: some View {
            Button("Cancel") {
                viewModel.resetCounts()
                dismiss()
            }
        }
        
        private var popupOverlay: some View {
            Group {
                if showNamePopup {
                    ProblemSetNamePopup(
                        isPresented: $showNamePopup,
                        problemSetName: $viewModel.problemSetName,
                        isGeneratingQuestions: $viewModel.isGeneratingQuestions,
                        defaultName: viewModel.generateDefaultName()
                    ) {
                        viewModel.saveProblemSetName()
                        showNamePopup = false
                        viewModel.shouldShowStudyView = true
                    }
                    .transition(.opacity)
                    .animation(.easeInOut, value: showNamePopup)
                }
            }
        }
        
        private var isGenerateButtonEnabled: Bool {
            let hasInput = !viewModel.selectedImages.isEmpty ||
            (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
            let hasQuestionType = viewModel.totalQuestionCount > 0
            return hasInput && hasQuestionType
        }
        
    private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
        Binding(
            get: { expandedSections.contains(section) },
            set: { isExpanded in
                withAnimation {
                    if isExpanded {
                        expandedSections.insert(section)
                    } else {
                        expandedSections.remove(section)
                    }
                }
            }
        )
    }


}




import SwiftUI

struct ProblemSetNamePopup: View {
    @Binding var isPresented: Bool
    @Binding var problemSetName: String
    @Binding var isGeneratingQuestions: Bool
    let defaultName: String
    let onSubmit: () -> Void

    var body: some View {
        ZStack {
            // 반투명 배경
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)

            VStack(spacing: 20) {
                // 팝업 제목
                Text("Name Your Question Set")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)

                // 텍스트 입력 필드
                VStack(alignment: .leading, spacing: 8) {
                    Text("Enter a name for your question set:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    ZStack(alignment: .leading) {
                        // Placeholder 텍스트
                        if problemSetName.isEmpty {
                            Text(defaultName)
                                .foregroundColor(.gray)
                                .padding(.leading, 8)
                        }

                        // 실제 TextField
                        TextField("", text: $problemSetName)
                            .textFieldStyle(PlainTextFieldStyle())
                            .padding(10)
                            .background(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(Color.gray, lineWidth: 1)
                            )
                            .font(.body)
                    }
                }

                // 버튼 섹션
                Button(action: {
                    if problemSetName.isEmpty {
                        problemSetName = defaultName
                    }
                    if !isGeneratingQuestions {
                        onSubmit()
                    }
                }) {
                    Text(isGeneratingQuestions ? "Generating Questions..." : "Save Name")
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(isGeneratingQuestions ? Color.gray : Color.blue)
                        .cornerRadius(8)
                        .shadow(radius: 5)
                }
                .disabled(isGeneratingQuestions)
            }
            .padding(20)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(.systemBackground))
                    .shadow(color: Color.black.opacity(0.2), radius: 10, x: 0, y: 5)
            )
            .padding(.horizontal, 32)
        }
    }
}





struct SubjectSelectionButton: View {
    let subject: any SubjectType
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.caption)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .padding(.horizontal, 8)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .foregroundColor(isSelected ? subject.color : .gray)
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}



struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // 추가
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSection도 수정
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // 총 문제 수 표시
                HStack {
                    Text("Type")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/10")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    var body: some View {
        Section("Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    // 기본 과목
                    ForEach(DefaultSubject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected subject: \(subject.rawValue)")
                        }
                    }
                    
                    // 사용자 정의 과목
                    ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected custom subject: \(subject.name)")
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// ImagePicker, PhotoPicker, LoadingView 도 추가
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    let useSpeedUp: Bool // 추가
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = useSpeedUp ? 3 : 1 // Speed Up 설정에 따라 제한
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

class CustomImagePickerController: UIImagePickerController {
    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .all // 모든 방향 지원
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)?
    
    class CustomImagePickerController: UIImagePickerController {
        override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
            return .portrait // 카메라 UI는 항상 세로 모드로 유지
        }
    }
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = CustomImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        
        if sourceType == .camera {
            picker.cameraDevice = .rear
            picker.cameraCaptureMode = .photo
            picker.allowsEditing = false
            
            // 전체 화면 모드로 설정
            picker.modalPresentationStyle = .fullScreen
            
            // 카메라 UI를 세로 모드로 고정
            picker.navigationController?.navigationBar.isHidden = false
            picker.navigationController?.interactivePopGestureRecognizer?.isEnabled = false
        }
        
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController,
                                 didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                // 이미지는 원래 방향 그대로 유지
                parent.image = image
                parent.onImageSelected?(image)
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

// UIImage extension for orientation fixing
extension UIImage {
    func fixedOrientation() -> UIImage {
        if imageOrientation == .up { return self }
        
        var transform = CGAffineTransform.identity
        
        switch imageOrientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: .pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: .pi/2)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: -.pi/2)
        case .up, .upMirrored:
            break
        @unknown default:
            break
        }
        
        guard let cgImage = self.cgImage else { return self }
        
        let context = CGContext(data: nil,
                              width: Int(size.width),
                              height: Int(size.height),
                              bitsPerComponent: cgImage.bitsPerComponent,
                              bytesPerRow: 0,
                              space: cgImage.colorSpace!,
                              bitmapInfo: cgImage.bitmapInfo.rawValue)!
        
        context.concatenate(transform)
        
        switch imageOrientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
        }
        
        guard let newCGImage = context.makeImage() else { return self }
        return UIImage(cgImage: newCGImage)
    }
}

struct InputMethodCard: View {
    let icon: String
    let title: String
    let isUsed: Bool
    let isDisabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .padding(.vertical, 16)
            .padding(.horizontal, 8)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isUsed ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isUsed ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(isDisabled)
        .opacity(isDisabled ? 0.5 : 1)
    }
}


// ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
   let question: Question
   @Binding var selectedAnswer: String?
   let showExplanation: Bool
   let isCorrect: Bool?
   
   @State private var isExplanationVisible = false
   
   var body: some View {
       VStack(alignment: .leading, spacing: 16) {
           // Question Text
           Text(question.question)
               .font(.system(size: 22, weight: .semibold))
               .lineSpacing(4)
               .frame(maxWidth: .infinity, alignment: .leading)
               .padding(.bottom, 8)
           
           VStack(alignment: .leading, spacing: 12) {
               TrueFalseButton(
                   title: "True",
                   isSelected: selectedAnswer?.lowercased() == "true",
                   disabled: showExplanation
               ) {
                   selectedAnswer = "true"
               }
               
               TrueFalseButton(
                   title: "False",
                   isSelected: selectedAnswer?.lowercased() == "false",
                   disabled: showExplanation
               ) {
                   selectedAnswer = "false"
               }
           }
           
           // Answer Result
           if showExplanation {
               HStack {
                   if let isCorrect = isCorrect {
                       HStack {
                           Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                               .foregroundColor(isCorrect ? .green : .red)
                           
                           Text(isCorrect ? "Correct!" : "Incorrect")
                               .foregroundColor(isCorrect ? .green : .red)
                               .fontWeight(.semibold)
                       }
                       .padding(.vertical, 4)
                       
                       Spacer()
                   }
               }
               
               // Show correct answer if wrong
               if let isCorrect = isCorrect, !isCorrect {
                   Text("Answer: \(question.correctAnswer)")
                       .font(.subheadline)
                       .foregroundColor(.blue)
                       .padding(.vertical, 4)
               }
           }
           
           // Explanation Section
           if showExplanation && isExplanationVisible {
               VStack(alignment: .leading, spacing: 8) {
                   Text("Explanation")
                       .font(.headline)
                   Text(question.explanation)
                       .font(.body)
                       .foregroundColor(.secondary)
               }
               .padding()
               .frame(maxWidth: .infinity, alignment: .leading)
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .transition(.move(edge: .top).combined(with: .opacity))
           }
       }
       .padding()
       .animation(.spring(), value: showExplanation)
       .animation(.spring(), value: isExplanationVisible)
       .onChange(of: question.id) { _ in
           isExplanationVisible = false
       }
   }
}

struct TrueFalseButton: View {
   let title: String
   let isSelected: Bool
   let disabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           HStack {
               Text(title)
                   .font(.body)
               Spacer()
           }
           .padding()
           .frame(maxWidth: .infinity, alignment: .leading)
           .background(
               RoundedRectangle(cornerRadius: 10)
                   .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
           )
           .overlay(
               RoundedRectangle(cornerRadius: 10)
                   .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
           )
       }
       .disabled(disabled)
   }
}


// ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            // 질문 텍스트
            Text(question.question)
                .font(.title3)
                .fontWeight(.bold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 16)
            
            // 선택지
            VStack(spacing: 16) {
                ForEach(question.options, id: \.self) { option in
                    Button(action: { selectedAnswer = option }) {
                        HStack {
                            Text(option)
                                .font(.body)
                                .fontWeight(.medium)
                                .multilineTextAlignment(.leading)
                                .foregroundColor(getTextColor(for: option))
                            Spacer()
                            if selectedAnswer == option && showExplanation {
                                Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                    .foregroundColor(isCorrect == true ? .green : .red)
                                    .imageScale(.large)
                                    .transition(.scale.combined(with: .opacity))
                            }
                        }
                        .padding(.vertical, 16)
                        .padding(.horizontal, 20)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(getBackgroundColor(for: option))
                                .shadow(color: Color.black.opacity(0.05),
                                       radius: 4, x: 0, y: 2)
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    .disabled(showExplanation)
                }
            }
        }
        .padding()
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.15)
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.15)
            }
        }
        // 기본 배경색을 조금 더 명확하게 구분
        return Color(UIColor.systemGray6)
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue
            } else {
                return isCorrect == true ? .green : .red
            }
        }
        return .primary
    }
}


// ./AISnapStudy/Views/Question/Sections/EducationLevelSection.swift


import SwiftUI

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionTypesSection.swift


import SwiftUI

// Question Type Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Type") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "True/False",
                    count: $viewModel.trueFalseCount
                )
                
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionAboutSection.swift

import SwiftUI

import SwiftUI

struct QuestionAboutSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @Binding var isTextInputSelected: Bool

    var body: some View {
        VStack(spacing: 16) { // DisclosureGroup 제거
            // 기존 이미지 옵션 카드
            HStack(spacing: 12) {
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.takePhoto() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.selectFromGallery() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        isTextInputSelected.toggle()
                        viewModel.toggleTextInput()
                    }
                )
            }
            .padding(.horizontal)

            // 🟢 useTextExtraction 토글 추가
            Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                .padding(.horizontal)
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("📱 useTextExtraction changed to: \(newValue)")
                }

            // 텍스트 입력 필드
            if viewModel.isTextInputActive {
                TextField("Enter your question here...", text: $viewModel.questionText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .frame(height: 50) // 원하는 높이를 지정
                    .padding(.horizontal)
            }

            // 선택한 이미지 표시
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                            SelectedImageCell(
                                image: viewModel.selectedImages[index],
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .listRowSpacing(0)
    }
}


// ./AISnapStudy/Views/Question/Sections/LearningSubjectSection.swift

import SwiftUI

struct LearningSubjectSection: View {
    @StateObject private var subjectManager = SubjectManager.shared
    @Binding var selectedSubject: SubjectType
    
    var visibleSubjects: [SubjectType] {
        // 기본 과목 중 삭제되지 않은 것들만 필터링
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        // 활성화된 커스텀 과목만 필터링
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        📚 LearningSubjectSection - Visible Subjects:
        • Total Subjects: \(subjects.count)
        • Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        • Active Custom Subjects: \(customSubjects.map { $0.displayName })
        • Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
    
    var body: some View {
        LazyVGrid(columns: [
            GridItem(.flexible()),
            GridItem(.flexible()),
            GridItem(.flexible())
        ], spacing: 12) {
            ForEach(visibleSubjects, id: \.id) { subject in
                SubjectSelectionButton(
                    subject: subject,
                    isSelected: selectedSubject.id == subject.id
                ) {
                    withAnimation(.spring()) {
                        selectedSubject = subject
                        print("📝 Selected subject: \(subject.displayName)")
                    }
                }
            }
        }
        .padding(.vertical, 8)
        .onAppear {
            // 현재 선택된 과목이 삭제되었거나 비활성화된 경우 기본 과목으로 변경
            if let defaultSubject = selectedSubject as? DefaultSubject,
               subjectManager.isDeleted(defaultSubject) {
                // 첫 번째로 사용 가능한 과목을 선택
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            } else if let customSubject = selectedSubject as? CustomSubject,
                      !subjectManager.customSubjects.contains(where: { $0.id == customSubject.id && $0.isActive }) {
                // 첫 번째로 사용 가능한 과목을 선택
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Components/AddSubjectView.swift



import SwiftUI


// Helper Views
struct IconSelectionButton: View {
    let icon: String
    let isSelected: Bool
    let color: Color
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .frame(width: 50, height: 50)
                .foregroundColor(isSelected ? .white : color)
                .background(
                    Circle()
                        .fill(isSelected ? color : Color.gray.opacity(0.1))
                )
                .overlay(
                    Circle()
                        .stroke(isSelected ? color : Color.clear, lineWidth: 2)
                )
        }
    }
}

struct ColorSelectionButton: View {
    let color: Color
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Circle()
                .fill(color)
                .frame(width: 50, height: 50)
                .overlay(
                    Circle()
                        .stroke(Color.white, lineWidth: isSelected ? 3 : 0)
                )
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        }
    }
}



// ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    // Add selection state
    @Binding var isSelected: Bool
    let selectionEnabled: Bool // 새로운 프로퍼티 추가
    
    // 기본값을 가진 생성자 추가
    init(problemSet: ProblemSet, isSelected: Binding<Bool> = .constant(false), selectionEnabled: Bool = false) {
        self.problemSet = problemSet
        self._isSelected = isSelected
        self.selectionEnabled = selectionEnabled
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                if selectionEnabled {  // isSelectable 대신 selectionEnabled 사용
                    Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(.blue)
                        .onTapGesture {
                            isSelected.toggle()
                        }
                }
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // 태그 목록 (작고 간결하게)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // 최대 3개의 태그만 표시
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // 정보 그리드
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
            }
            .font(.footnote)
            
            // 설명 (더 짧게)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



// ./AISnapStudy/Views/Components/SpeedUpSection.swift


import SwiftUI

struct SpeedUpSection: View {
    @Binding var useTextExtraction: Bool 
    @State private var isExpanded: Bool = false
    @State private var showHelp = false
    
    var body: some View {
        VStack {
            DisclosureGroup(
                isExpanded: $isExpanded,
                content: {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Automatically extracts text from images to generate questions faster. Recommended when images contain mostly text.")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        // 이미지 제한 설명 추가
                        HStack(alignment: .top, spacing: 8) {
                            Image(systemName: "info.circle.fill")
                                .foregroundColor(.blue)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Image Selection Limits:")
                                    .font(.caption)
                                    .fontWeight(.semibold)
                                
                                Text("• When enabled: Up to 3 images")
                                Text("• When disabled: Single image only")
                            }
                            .font(.caption)
                            .foregroundColor(.secondary)
                        }
                        .padding(.top, 4)
                    }
                    .padding(.vertical, 8)
                },
                label: {
                    HStack {
                        Image(systemName: "bolt.fill")
                            .foregroundColor(.yellow)
                        Text("Speed Up")
                            .font(.headline)
                        Spacer()
                        Toggle("", isOn: $useTextExtraction)
                            .labelsHidden()
                        
                        Button(action: { showHelp = true }) {
                            Image(systemName: "questionmark.circle")
                                .foregroundColor(.blue)
                        }
                    }
                }
            )
        }
        .alert("Speed Up Mode", isPresented: $showHelp) {
            Button("OK", role: .cancel) { }
        } message: {
            Text("Speed Up mode allows batch processing of multiple images (up to 3) with text extraction. When disabled, you can process one image at a time for more detailed analysis.")
        }
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionsView.swift

import SwiftUI

struct SavedQuestionsView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int
    @State private var selectedQuestions: Set<String> = []
    @State private var showCreateSetDialog = false
    @State private var setName = "Saved Questions Set"
    @State private var selectedSubject: DefaultSubject = .generalKnowledge

    var body: some View {
        VStack {
            if homeViewModel.savedQuestions.isEmpty {
                EmptyStateView()
            } else {
                SavedQuestionsList(
                    questions: homeViewModel.savedQuestions,
                    selectedQuestions: $selectedQuestions,
                    homeViewModel: homeViewModel
                )
            }
            
            if !selectedQuestions.isEmpty {
                CreateSetButton(
                    count: selectedQuestions.count,
                    action: { showCreateSetDialog = true }
                )
            }
        }
        .navigationTitle("Saved Questions")
        .sheet(isPresented: $showCreateSetDialog) {  // alert 대신 sheet 사용
            CreateSetView(
                setName: $setName,
                selectedSubject: $selectedSubject,
                onCreate: {
                    createNewSet()
                    showCreateSetDialog = false
                }
            )
        }
    }

    private func createNewSet() {
        // 선택된 질문들의 ID 리스트
        let selectedQuestionIds = selectedQuestions

        let selectedQuestionsList = homeViewModel.savedQuestions
            .filter { selectedQuestions.contains($0.id) }
            .map { question in
                Question(
                    id: UUID().uuidString,
                    type: question.type,
                    subject: selectedSubject,
                    question: question.question,
                    options: question.options,
                    correctAnswer: question.correctAnswer,
                    explanation: question.explanation,
                    hint: question.hint,
                    isSaved: false,  // 새 질문은 북마크 해제된 상태로 생성
                    createdAt: Date()
                )
            }
        
        let newProblemSet = ProblemSet(
            subject: selectedSubject,
            subjectType: "default",
            subjectId: selectedSubject.rawValue,
            subjectName: selectedSubject.displayName,
            questions: selectedQuestionsList,
            educationLevel: .elementary,
            name: setName
        )

        Task {
            // 먼저 새 문제 세트 저장
            await homeViewModel.saveProblemSet(newProblemSet)
            await homeViewModel.setSelectedProblemSet(newProblemSet)
            
            // 선택된 원본 질문들의 북마크 해제
            for questionId in selectedQuestionIds {
                if let originalQuestion = homeViewModel.savedQuestions.first(where: { $0.id == questionId }) {
                    await homeViewModel.toggleQuestionBookmark(originalQuestion)
                }
            }
            
            selectedTab = 1
            showCreateSetDialog = false
            selectedQuestions.removeAll()
        }
    }
}

// 새로운 CreateSetView 구현
struct CreateSetView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var setName: String
    @Binding var selectedSubject: DefaultSubject
    let onCreate: () -> Void
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Set Name")) {
                    TextField("Enter set name", text: $setName)
                }
                
                Section(header: Text("Subject")) {
                    Picker("Select Subject", selection: $selectedSubject) {
                        ForEach(DefaultSubject.allCases, id: \.self) { subject in
                            Text(subject.displayName)
                                .tag(subject)
                        }
                    }
                }
            }
            .navigationTitle("Create New Set")
            .navigationBarItems(
                leading: Button("Cancel") {
                    dismiss()
                },
                trailing: Button("Create") {
                    onCreate()
                }
            )
        }
    }
}

private struct CreateSetAlert: View {
    @Binding var setName: String
    @Binding var selectedSubject: DefaultSubject
    let onCreate: () -> Void

    var body: some View {
        Group {
            TextField("Set Name", text: $setName)
            
            Picker("Subject", selection: $selectedSubject) {
                ForEach(DefaultSubject.allCases, id: \.self) { subject in
                    Text(subject.displayName)
                        .tag(subject)
                }
            }
            
            Button("Cancel", role: .cancel) { }
            Button("Create") {
                onCreate()
            }
        }
    }
}

// MARK: - Supporting Views
private struct EmptyStateView: View {
    var body: some View {
        Text("No saved questions")
            .foregroundColor(.secondary)
    }
}

private struct SavedQuestionsList: View {
    let questions: [Question]
    @Binding var selectedQuestions: Set<String>
    @ObservedObject var homeViewModel: HomeViewModel

    var body: some View {
        List {
            ForEach(Array(questions.enumerated()), id: \.offset) { index, question in
                SavedQuestionCard(
                    question: question,
                    isSelected: selectedQuestions.contains(question.id)
                )
                .contentShape(Rectangle())
                .onTapGesture {
                    toggleSelection(for: question)
                }
                .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                    UnsaveButton(question: question, homeViewModel: homeViewModel)
                }
                .swipeActions(edge: .leading, allowsFullSwipe: true) {
                    UnsaveButton(question: question, homeViewModel: homeViewModel, tint: .blue)
                }
            }
        }
        .listStyle(PlainListStyle())
    }

    private func toggleSelection(for question: Question) {
        if selectedQuestions.contains(question.id) {
            selectedQuestions.remove(question.id)
        } else {
            selectedQuestions.insert(question.id)
        }
    }
}

private struct UnsaveButton: View {
    let question: Question
    let homeViewModel: HomeViewModel
    var tint: Color? = nil

    var body: some View {
        Button {
            Task {
                await homeViewModel.toggleQuestionBookmark(question)
                HapticManager.shared.impact(style: .medium)
            }
        } label: {
            Label("Unsave", systemImage: "bookmark.slash.fill")
        }
        .tint(tint)
    }
}

private struct CreateSetButton: View {
    let count: Int
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Text("Create New Set (\(count))")
                .font(.headline)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue)
                .cornerRadius(10)
        }
        .padding()
    }
}


// ./AISnapStudy/Views/Components/DraggableSubjectGrid.swift

import SwiftUI

struct DraggableSubjectGrid: View {
    @ObservedObject var subjectManager = SubjectManager.shared
    @State private var subjects: [SubjectType]
    @State private var draggingItem: SubjectType?
    @GestureState private var dragLocation: CGPoint = .zero
    
    // Grid layout settings
    let columns = [
        GridItem(.adaptive(minimum: 120), spacing: 12)
    ]
    
    init(subjects: [SubjectType]) {
        _subjects = State(initialValue: subjects)
    }
    
    var body: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(subjects, id: \.id) { subject in
                SubjectButton(subject: subject)
                    .overlay(draggingItem?.id == subject.id ? Color.blue.opacity(0.3) : Color.clear)
                    .onLongPressGesture(minimumDuration: 0.5) {
                        withAnimation(.spring()) {
                            self.draggingItem = subject
                        }
                    }
                    .gesture(
                        DragGesture()
                            .onChanged { value in
                                guard let draggingItem = draggingItem else { return }
                                let currentIndex = subjects.firstIndex { $0.id == draggingItem.id }
                                let targetIndex = computeTargetIndex(location: value.location)
                                
                                if let currentIndex = currentIndex,
                                   let targetIndex = targetIndex,
                                   currentIndex != targetIndex {
                                    withAnimation(.spring()) {
                                        subjects.move(fromOffsets: IndexSet(integer: currentIndex),
                                                    toOffset: targetIndex)
                                    }
                                }
                            }
                            .onEnded { _ in
                                self.draggingItem = nil
                                // Save new order to UserDefaults
                                saveSubjectOrder()
                            }
                    )
            }
        }
        .padding()
    }
    
    private func computeTargetIndex(location: CGPoint) -> Int? {
        // Convert point to index logic
        // ...
        return nil
    }
    
    private func saveSubjectOrder() {
        let subjectIds = subjects.map { $0.id }
        UserDefaults.standard.set(subjectIds, forKey: "subjectOrder")
    }
}

struct SubjectButton: View {
    let subject: SubjectType
    @State private var isPressed = false
    
    var body: some View {
        Button(action: {}) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.subheadline)
                    .lineLimit(1)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(subject.color.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(subject.color.opacity(0.2), lineWidth: 1)
                    )
            )
        }
        .scaleEffect(isPressed ? 1.05 : 1.0)
        .animation(.spring(), value: isPressed)
        .buttonStyle(PlainButtonStyle())
    }
}


// ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/LanguageButton.swift

import SwiftUI

// Add new supporting view for Language Button
struct LanguageButton: View {
    let language: Language
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 6) {
                Text(emoji(for: language))
                    .font(.title2)
                Text(displayName(for: language))
                    .font(.caption)
                    .foregroundColor(isSelected ? .white : .primary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.blue : Color.gray.opacity(0.1))
            )
        }
    }
    
    private func emoji(for language: Language) -> String {
        switch language {
        case .auto: return "🌐"
        case .english: return "🇺🇸"
        case .korean: return "🇰🇷"
        case .japanese: return "🇯🇵"
        case .chinese: return "🇨🇳"
        case .spanish: return "🇪🇸"
        case .french: return "🇫🇷"
        case .german: return "🇩🇪"
        case .russian: return "🇷🇺"
        case .italian: return "🇮🇹"
        }
    }
    
    private func displayName(for language: Language) -> String {
        switch language {
        case .auto: return "Auto"
        default: return language.rawValue
        }
    }
}



struct LanguageSection: View {
    @Binding var selectedLanguage: Language
    @State private var isExpanded: Bool = false
    @State private var showLanguageMenu = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Choose the language in which you want the questions to be generated. The generated questions will appear in your selected language regardless of the input language.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                        
                    Text("Current: \(selectedLanguage.displayName) \(selectedLanguage.emoji)")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            },
            label: {
                HStack {
                    HStack {
                        Image(systemName: "globe")
                            .foregroundColor(.blue)
                        Text("Language")
                            .font(.headline)
                    }
                    
                    Spacer()
                    
                    // 별도의 버튼으로 분리
                    Button(action: {
                        showLanguageMenu = true
                    }) {
                        HStack(spacing: 4) {
                            Text(selectedLanguage.emoji)
                            Image(systemName: "chevron.down")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
            }
        )
        .sheet(isPresented: $showLanguageMenu) {
            LanguageSelectionView(selectedLanguage: $selectedLanguage)
        }
    }
}

// LanguageSelectionView는 더 깔끔한 UI로 업데이트
struct LanguageSelectionView: View {
    @Binding var selectedLanguage: Language
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            List {
                ForEach(Language.allCases) { language in
                    LanguageRow(
                        language: language,
                        isSelected: language == selectedLanguage,
                        onSelect: {
                            selectedLanguage = language
                            UserDefaults.standard.set(language.rawValue, forKey: "selectedLanguage")
                            dismiss()
                        }
                    )
                }
            }
            .navigationTitle("Select Language")
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
        }
        .presentationDetents([.medium, .large])
    }
}

// 별도의 LanguageRow 컴포넌트
struct LanguageRow: View {
    let language: Language
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack(spacing: 12) {
                Text(language.emoji)
                    .font(.title3)
                
                VStack(alignment: .leading) {
                    Text(language.displayName)
                        .foregroundColor(.primary)
                    Text(language.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}


// Language.swift (새로운 파일)
enum Language: String, CaseIterable, Identifiable {
    case auto = "AUTO"
    case english = "english"
    case korean = "korean"
    case japanese = "japanese"
    case chinese = "chinese"
    case spanish = "spanish"
    case french = "french"
    case german = "german"
    case russian = "russian"
    case italian = "italian"
    
    var id: String { self.rawValue }
    
    // OpenAI API에서 사용할 언어 코드
    var languageCode: String {
        switch self {
        case .auto: return "auto"
        case .english: return "en"
        case .korean: return "ko"
        case .japanese: return "ja"
        case .chinese: return "zh"
        case .spanish: return "es"
        case .french: return "fr"
        case .german: return "de"
        case .russian: return "ru"
        case .italian: return "it"
        }
    }
}

// Update Language enum to include display names and emojis
extension Language {
    var displayName: String {
        switch self {
        case .auto: return "Automatic"
        case .english: return "English"
        case .korean: return "한국어"
        case .japanese: return "日本語"
        case .chinese: return "中文"
        case .spanish: return "Español"
        case .french: return "Français"
        case .german: return "Deutsch"
        case .russian: return "Русский"
        case .italian: return "Italiano"
        }
    }
    
    var emoji: String {
        switch self {
        case .auto: return "🌐"
        case .english: return "🇺🇸"
        case .korean: return "🇰🇷"
        case .japanese: return "🇯🇵"
        case .chinese: return "🇨🇳"
        case .spanish: return "🇪🇸"
        case .french: return "🇫🇷"
        case .german: return "🇩🇪"
        case .russian: return "🇷🇺"
        case .italian: return "🇮🇹"
        }
    }
    var codeName: String {
        switch self {
        case .auto: return "automatic"
        case .english: return "english"
        case .korean: return "korean"
        case .japanese: return "japanese"
        case .chinese: return "chinese"
        case .spanish: return "spanish"
        case .french: return "french"
        case .german: return "german"
        case .russian: return "russian"
        case .italian: return "italian"
        }
    }
}

extension Language {
    var description: String {
        switch self {
        case .auto:
            return "Detect language automatically"
        case .english:
            return "English"
        case .korean:
            return "한국어 (Korean)"
        case .japanese:
            return "日本語 (Japanese)"
        case .chinese:
            return "中文 (Chinese)"
        case .spanish:
            return "Español (Spanish)"
        case .french:
            return "Français (French)"
        case .german:
            return "Deutsch (German)"
        case .russian:
            return "Русский (Russian)"
        case .italian:
            return "Italiano (Italian)"
        }
    }
}


// ./AISnapStudy/Views/Components/SubjectManagementView.swift

import SwiftUI

struct SubjectManagementView: View {
   @StateObject private var subjectManager = SubjectManager.shared
   @State private var showingAddSubject = false
   @State private var showingDeleteAlert = false
   @State private var showingEditAlert = false
   @State private var showingRestoreAlert = false
   @State private var subjectToDelete: (any SubjectType)?
   @State private var newName = ""
   @State private var selectedSubject: (any SubjectType)?
   
   // 모든 활성 과목을 하나의 배열로 결합
   private var allSubjects: [SubjectType] {
       var subjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) } as [SubjectType]
       subjects.append(contentsOf: subjectManager.customSubjects)
       return subjects
   }
   
   var body: some View {
       List {
           // Combined Subjects Section
           Section(header: Text("SUBJECTS")) {
               ForEach(allSubjects, id: \.id) { subject in
                   if let defaultSubject = subject as? DefaultSubject {
                       DefaultSubjectRow(
                        subject: defaultSubject,
                        subjectManager: subjectManager,
                        onEdit: { subject in
                            selectedSubject = subject
                            newName = subjectManager.getDisplayName(for: subject)
                            showingEditAlert = true
                        },
                        onDelete: {
                            subjectToDelete = subject
                            showingDeleteAlert = true
                        }
                       )
                   } else if let customSubject = subject as? CustomSubject {
                       CustomSubjectRow(
                           subject: customSubject,
                           subjectManager: subjectManager,
                           onEdit: { subject in
                               selectedSubject = subject
                               newName = subject.name
                               showingEditAlert = true
                           },
                           onDelete: { subject in
                               subjectToDelete = subject
                               showingDeleteAlert = true
                           }
                       )
                   }
               }
               
               Button {
                   showingAddSubject = true
               } label: {
                   Label("Add Subject", systemImage: "plus")
               }
           }
           
           // Recently Deleted Section moved to bottom
           if !subjectManager.hiddenDefaultSubjects.isEmpty {
               Section(header: Text("RECENTLY DELETED")) {
                   Button(action: {
                       showingRestoreAlert = true
                   }) {
                       Label("Restore All Deleted Subjects", systemImage: "arrow.counterclockwise")
                           .foregroundColor(.blue)
                   }
               }
           }
       }
       .navigationTitle("Manage Subjects")
       .sheet(isPresented: $showingAddSubject) {
           AddSubjectView()
       }
       .alert("Rename Subject", isPresented: $showingEditAlert) {
           TextField("Subject Name", text: $newName)
           Button("Cancel", role: .cancel) { }
           Button("Save") {
               if let defaultSubject = selectedSubject as? DefaultSubject {
                   subjectManager.updateDefaultSubjectName(defaultSubject, newName: newName)
               } else if let customSubject = selectedSubject as? CustomSubject {  // 변경
                              subjectManager.updateSubject(customSubject, newName: newName)
               }
           }
           .disabled(newName.isEmpty)
       }
       .alert("Delete Subject", isPresented: $showingDeleteAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Delete", role: .destructive) {
               if let subject = subjectToDelete as? DefaultSubject {
                   subjectManager.toggleDefaultSubject(subject)
               } else if let subject = subjectToDelete as? CustomSubject {  // 변경
                   subjectManager.deleteSubject(subject)
               }
           }
       } message: {
           Text("Are you sure you want to delete this subject? You can restore it later from the Recently Deleted section.")
       }
       .alert("Restore Subjects", isPresented: $showingRestoreAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Restore All") {
               DefaultSubject.allCases.forEach { subject in
                   if subjectManager.isDeleted(subject) {
                       subjectManager.restoreDeletedSubject(subject)
                   }
               }
           }
       } message: {
           Text("Do you want to restore all deleted subjects?")
       }
       .onAppear {
           print("📱 SubjectManagementView appeared")
           print("📚 Active subjects: \(allSubjects.map { $0.displayName })")
           print("🗑️ Hidden subjects: \(subjectManager.hiddenDefaultSubjects)")
       }
   }
}


    // 기본 과목 섹션을 위한 별도의 뷰
struct DefaultSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: (DefaultSubject) -> Void
    
    var body: some View {
        Section(header: Text("Default Subjects")) {
            ForEach(DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }, id: \.id) { subject in
                DefaultSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { _ in onEdit(subject) },  // 수정된 부분
                    onDelete: { onDelete(subject) }     // 수정된 부분
                )
            }
        }
    }
}

// 커스텀 과목 섹션을 위한 별도의 뷰
struct CustomSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    @Binding var showingAddSubject: Bool
    let onEdit: (CustomSubject) -> Void  // 변경
    let onDelete: (CustomSubject) -> Void  // 변경
    
    var body: some View {
        Section(header: Text("Custom Subjects")) {
            ForEach(subjectManager.customSubjects) { subject in
                CustomSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { customSubject in  // 매개변수 이름 변경
                        onEdit(customSubject)
                    },
                    onDelete: { customSubject in  // 매개변수 이름 변경
                        onDelete(customSubject)
                    }
                )
            }
            
            Button {
                showingAddSubject = true
            } label: {
                Label("Add Subject", systemImage: "plus")
            }
        }
    }
}

struct DefaultSubjectRow: View {
    let subject: DefaultSubject
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subjectManager.getDisplayName(for: subject))
            Spacer()
            
            Button(action: {
                onDelete()
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button(role: .destructive) {
                onDelete()
            } label: {
                Label("Delete", systemImage: "trash")
            }
            
            if subjectManager.modifiedDefaultSubjects[subject.id] != nil {
                Button {
                    subjectManager.resetDefaultSubjectName(subject)
                } label: {
                    Label("Reset Name", systemImage: "arrow.counterclockwise")
                }
            }
        }
    }
}

// 사용자 정의 과목 행을 위한 컴포넌트
struct CustomSubjectRow: View {
    let subject: CustomSubject  // 변경
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (CustomSubject) -> Void  // 변경
    let onDelete: (CustomSubject) -> Void  // 변경
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subject.displayName)
            Spacer()
            
            // 삭제 버튼 추가
            Button(action: {
                onDelete(subject)
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
            
            if !subject.isActive {
                Image(systemName: "eye.slash")
                    .foregroundColor(.gray)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button {
                subjectManager.toggleSubjectActive(subject)
            } label: {
                if subject.isActive {
                    Label("Hide", systemImage: "eye.slash")
                } else {
                    Label("Show", systemImage: "eye")
                }
            }
            
            Button(role: .destructive) {
                onDelete(subject)
            } label: {
                Label("Delete", systemImage: "trash")
            }
        }
    }
}



struct AddSubjectView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var subjectName = ""
    @State private var selectedColor = Color.blue
    @State private var selectedIcon = "book.fill"
    
    let availableIcons = [
        "book.fill", "pencil", "function", "globe",
        "atom", "flask.fill", "keyboard", "music.note"
    ]
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Subject Details")) {
                    TextField("Subject Name", text: $subjectName)
                    
                    ColorPicker("Choose Color", selection: $selectedColor)
                    
                    Picker("Choose Icon", selection: $selectedIcon) {
                        ForEach(availableIcons, id: \.self) { icon in
                            Label(icon, systemImage: icon)
                                .tag(icon)
                        }
                    }
                    .pickerStyle(.menu)
                }
            }
            .navigationTitle("Add Subject")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        subjectManager.addSubject(
                            name: subjectName,
                            icon: selectedIcon
                        )
                        dismiss()
                    }
                    .disabled(subjectName.isEmpty)
                }
            }
        }
    }
}



// ./AISnapStudy/Views/Components/SubjectPickerView.swift


import SwiftUI

struct SubjectPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    let problemSet: ProblemSet
    let currentSubject: SubjectType
    
    private func updateProblemSetSubject(to newSubject: SubjectType) async {
        await homeViewModel.updateProblemSetSubject(problemSet, to: newSubject)
        dismiss()
    }
    
    var body: some View {
        NavigationView {
            List {
                ForEach(subjectManager.availableSubjects, id: \.id) { subject in
                    Button(action: {
                        Task {
                            await updateProblemSetSubject(to: subject)
                            dismiss()
                        }
                    }) {
                        HStack {
                            Image(systemName: subject.icon)
                                .foregroundColor(subject.color)
                            
                            Text(subject.displayName)
                                .foregroundColor(.primary)
                            
                            Spacer()
                            
                            if subject.id == currentSubject.id {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Change Subject")
            .navigationBarItems(trailing: Button("Cancel") {
                dismiss()
            })
        }
    }

}


// ./AISnapStudy/Views/Components/ReviewProblemSetCard.swift

import SwiftUI

struct ReviewProblemSetCard: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    let subject: SubjectType
    let problemSet: ProblemSet
    let isEditMode: Bool
    let onDelete: () -> Void
    let onRename: (String) -> Void
    let onFavoriteToggle: () -> Void
    
    @State private var isShowingRenameAlert = false
    @State private var isShowingSubjectPicker = false
    @State private var newName = ""
    @State private var isShowingMergeAlert = false
    @State private var isTargeted = false
    @State private var mergingProblemSets: (source: ProblemSet, target: ProblemSet)?
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Spacer()
                    
                    Button(action: {
                        Task {
                            await homeViewModel.toggleFavorite(problemSet)
                        }
                    }) {
                        Image(systemName: problemSet.isFavorite ? "star.fill" : "star")
                            .foregroundColor(.yellow)
                            .imageScale(.large)
                    }
                }
                HStack {
                    Text("\(problemSet.questions.count) EA")
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            if isEditMode {
                HStack(spacing: 12) {
                    Button(action: {
                        isShowingSubjectPicker = true
                    }) {
                        Image(systemName: "arrow.triangle.swap")
                            .foregroundColor(.blue)
                            .imageScale(.large)
                    }
                    
                    Button(action: {
                        newName = problemSet.name
                        isShowingRenameAlert = true
                    }) {
                        Image(systemName: "pencil.circle.fill")
                            .foregroundColor(.blue)
                            .imageScale(.large)
                    }
                    
                    Button(action: onDelete) {
                        Image(systemName: "trash.circle.fill")
                            .foregroundColor(.red)
                            .imageScale(.large)
                    }
                }
                .transition(.move(edge: .trailing).combined(with: .opacity))
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(Color(UIColor.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
                .background(isTargeted ? Color.blue.opacity(0.1) : Color.clear)
        )
        .sheet(isPresented: $isShowingSubjectPicker) {
            SubjectPickerView(
                problemSet: problemSet,
                currentSubject: subject
            )
        }
        .alert("Rename Problem Set", isPresented: $isShowingRenameAlert) {
            TextField("New name", text: $newName)
            Button("Cancel", role: .cancel) {
                newName = ""
            }
            Button("Save") {
                let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !trimmedName.isEmpty else { return }
                
                Task {
                    await homeViewModel.renameProblemSet(problemSet, newName: trimmedName)
                    onRename(trimmedName)
                }
                newName = ""
            }
        } message: {
            Text("Enter a new name for this problem set")
        }
        // 드래그 앤 드롭 기능
        .draggable(problemSet) {
            DragPreviewView(problemSet: problemSet)
        }
        .dropDestination(for: ProblemSet.self) { droppedItems, location in
            guard let droppedSet = droppedItems.first,
                  droppedSet.id != problemSet.id else { return false }
            
            mergingProblemSets = (droppedSet, problemSet)
            newName = "\(droppedSet.name) + \(problemSet.name)"
            isShowingMergeAlert = true
            HapticManager.shared.impact(style: .medium)
            return true
        } isTargeted: { inDropArea in
            withAnimation(.easeInOut(duration: 0.2)) {
                isTargeted = inDropArea
            }
        }
        .alert("Create Combined Set", isPresented: $isShowingMergeAlert) {
            TextField("New set name", text: $newName)
            Button("Cancel", role: .cancel) {
                mergingProblemSets = nil
                newName = ""
            }
            Button("Create") {
                if let (source, target) = mergingProblemSets {
                    let mergedSet = ProblemSet.merge([source, target], name: newName)
                    Task {
                        // 새로운 병합된 세트만 저장하고 원본은 유지
                        await homeViewModel.saveProblemSet(mergedSet)
                        mergingProblemSets = nil
                        HapticManager.shared.notification(type: .success)  // 여기를 수정
                    }
                }
                newName = ""
            }
        } message: {
            if let sets = mergingProblemSets {
                Text("Create a new set by combining '\(sets.source.name)' with '\(sets.target.name)'\nOriginal sets will be preserved.")
            }
        }
    }
}

struct DragPreviewView: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(spacing: 4) {
            Text(problemSet.name)
                .font(.headline)
            Text("\(problemSet.questions.count) questions")
                .font(.caption)
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(8)
        .shadow(radius: 3)
    }
}


// ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search Review...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


// ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


// ./AISnapStudy/Views/Components/InputMethodCard.swift


import SwiftUI




// ./AISnapStudy/Views/Components/ImageSelectionSection.swift



import SwiftUI
import PhotosUI
import UIKit

struct ImageSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @FocusState private var isTextFieldFocused: Bool
    @State private var keyboardHeight: CGFloat = 0
  
    var body: some View {
        VStack(spacing: 16) {
            // Quick Text Mode Toggle
            Group {
                VStack(alignment: .leading, spacing: 8) {
                    Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                        .padding()
                        .onAppear {
                            print("🔄 Toggle initialized with: \(viewModel.useTextExtraction)")
                        }

                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Quick Text Mode")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            if viewModel.useTextExtraction {
                                Image(systemName: "bolt.fill")
                                    .foregroundColor(.yellow)
                                    .imageScale(.small)
                            }
                        }
                        Text("Extracts text for faster processing")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .toggleStyle(SwitchToggleStyle(tint: .blue))
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("📱 Quick Text Mode changed to: \(newValue)")
                }
            }
            .padding(.horizontal)

            Divider()

            // Input Type Selection Buttons
            HStack(spacing: 12) {
                // Camera Button
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.takePhoto()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Gallery Button
                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.selectFromGallery()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Text Input Button
                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        if viewModel.canUseTextInput {
                            viewModel.onImageOptionSelected()
                            viewModel.toggleTextInput()
                            if viewModel.isTextInputActive {
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isTextFieldFocused = true
                                }
                            } else {
                                isTextFieldFocused = false
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal)

            // Text Input Field
            if viewModel.isTextInputActive {
                VStack(spacing: 12) {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .focused($isTextFieldFocused)
                }
                .padding(.horizontal)
            }

            // Selected Images Display
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(Array(zip(viewModel.selectedImages.indices, viewModel.selectedImages)), id: \.0) { index, image in
                            let imageId = viewModel.getImageId(for: image)
                            SelectedImageCell(
                                image: image,
                                isLoading: viewModel.isLoadingTexts[imageId] ?? false,
                                extractionStatus: viewModel.extractionStatus[imageId],
                                extractedText: viewModel.extractedTexts[imageId],
                                showExtractedText: viewModel.useTextExtraction,
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.horizontal)
                }
            }

            // Generate Button for Selected Content
            if !viewModel.selectedImages.isEmpty || !viewModel.questionText.isEmpty {
                Button {
                    Task {
                        await viewModel.sendAllImages()
                    }
                } label: {
                    HStack {
                        Spacer()
                        Image(systemName: "sparkles")
                        Text("Generate Questions")
                            .fontWeight(.semibold)
                        Spacer()
                    }
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(viewModel.isLoading ? Color.gray : Color.green)
                    )
                    .animation(.easeInOut, value: viewModel.isLoading)
                }
                .buttonStyle(BorderlessButtonStyle())
                .disabled(viewModel.isLoading)
                .padding(.horizontal)
            }
        }
    }
}



// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
   let icon: String
   let isUsed: Bool
   let isDisabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 12) {
               Image(systemName: icon)
                   .font(.system(size: 30))
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 20)
           .foregroundColor(foregroundColor)
           .background(
               RoundedRectangle(cornerRadius: 12)
                   .fill(backgroundColor)
           )
           .overlay(
               RoundedRectangle(cornerRadius: 12)
                   .stroke(strokeColor, lineWidth: 1)
           )
       }
       .disabled(isDisabled)
       .buttonStyle(PlainButtonStyle())
   }
   
   private var foregroundColor: Color {
       if isDisabled {
           return .gray.opacity(0.5)
       }
       return isUsed ? .green : .gray
   }
   
   private var backgroundColor: Color {
       if isDisabled {
           return Color.gray.opacity(0.1)
       }
       return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
   }
   
   private var strokeColor: Color {
       if isDisabled {
           return .clear
       }
       return isUsed ? Color.green.opacity(0.2) : .clear
   }
}

struct SelectedImageCell: View {
    let image: UIImage
    let isLoading: Bool
    let extractionStatus: Bool?
    let extractedText: String?
    let showExtractedText: Bool
    let onDelete: () -> Void
    
    init(
        image: UIImage,
        isLoading: Bool = false,
        extractionStatus: Bool? = nil,
        extractedText: String? = nil,
        showExtractedText: Bool = false,
        onDelete: @escaping () -> Void
    ) {
        self.image = image
        self.isLoading = isLoading
        self.extractionStatus = extractionStatus
        self.extractedText = extractedText
        self.showExtractedText = showExtractedText
        self.onDelete = onDelete
    }
    
    var body: some View {
        ZStack(alignment: .topTrailing) {
            VStack(alignment: .leading, spacing: 4) {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .frame(width: 100, height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                    )
                
                if showExtractedText {
                    if isLoading {
                        HStack(spacing: 4) {
                            ProgressView()
                                .scaleEffect(0.7)
                            Text("Extracting text...")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    } else if let status = extractionStatus {
                        HStack(spacing: 4) {
                            Image(systemName: status ? "doc.text.fill" : "exclamationmark.triangle.fill")
                                .foregroundColor(status ? .green : .orange)
                                .imageScale(.small)
                            Text(status ? "Text extracted" : "Extraction failed")
                                .font(.caption2)
                                .foregroundColor(status ? .green : .orange)
                        }
                    }
                }
            }
            
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 22))
                    .foregroundColor(.white)
                    .background(
                        Circle()
                            .fill(Color.black.opacity(0.5))
                            .frame(width: 24, height: 24)
                    )
            }
            .offset(x: 6, y: -6)
        }
    }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


// ./AISnapStudy/Views/Components/PremiumUpgradeView.swift

import SwiftUI

struct PremiumUpgradeView: View {
    @StateObject private var storeService = StoreService.shared
    @Environment(\.dismiss) private var dismiss
    @State private var showPlans = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // Premium features section
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Premium Features")
                            .font(.title2)
                            .fontWeight(.bold)
                        
                        FeatureRow(
                            icon: "sparkles",
                            title: "More Daily Questions",
                            description: "Create up to 30 question sets per day"
                        )
                        
                        FeatureRow(
                            icon: "square.and.arrow.down",
                            title: "Full Library Access",
                            description: "Download all question sets from our library"
                        )
                    }
                    .padding()
                    
                    // See Plans Button
                    Button {
                        showPlans = true
                    } label: {
                        Text("See Plans")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .cornerRadius(10)
                    }
                    .padding()
                }
            }
            .navigationTitle("Premium Upgrade")
            .navigationBarItems(trailing: Button("Close") {
                dismiss()
            })
            .sheet(isPresented: $showPlans) {
                SubscriptionPlansView()
            }
        }
    }
}

struct SubscriptionPlansView: View {
   @Environment(\.dismiss) private var dismiss
   @StateObject private var storeService = StoreService.shared
   @State private var showTerms = false
   @State private var selectedPlan: PlanType = .annual
   @State private var isLoading = false
   @State private var showAlert = false
   @State private var alertMessage = ""
   
   enum PlanType: String {
       case annual = "com.aisnapstudy.subscription.annual"
       case monthly = "com.aisnapstudy.subscription.monthly"
       
       var productId: String {
           return self.rawValue
       }
   }
   
   var body: some View {
       NavigationView {
           ScrollView {
               VStack(spacing: 24) {
                   Text("Choose your plan")
                       .font(.title2)
                       .fontWeight(.bold)
                   
                   // Annual Plan
                   PlanCard(
                       type: .annual,
                       title: "Annual",
                       price: "$107.92",
                       period: "/ year",
                       description: "Recurring billing.",
                       isSelected: selectedPlan == .annual,
                       discount: "40% off",
                       isBestValue: true,
                       action: { selectedPlan = .annual }
                   )
                   
                   // Monthly Plan
                   PlanCard(
                       type: .monthly,
                       title: "Monthly",
                       price: "$14.99",
                       period: "/ month",
                       description: "Recurring billing. Cancel anytime.",
                       isSelected: selectedPlan == .monthly,
                       action: { selectedPlan = .monthly }
                   )
                   
                   // How subscriptions work
                   SubscriptionInfoSection()
                   
                   // Terms and conditions link
                   Button("Terms and conditions") {
                       showTerms = true
                   }
                   .font(.footnote)
                   .foregroundColor(.blue)
                   
                   // Subscribe button
                   Button(action: {
                       Task {
                           await handlePurchase()
                       }
                   }) {
                       if isLoading {
                           ProgressView()
                               .progressViewStyle(CircularProgressViewStyle(tint: .white))
                       } else {
                           Text("Subscribe")
                               .font(.headline)
                               .foregroundColor(.white)
                       }
                   }
                   .frame(maxWidth: .infinity)
                   .padding()
                   .background(Color.yellow)
                   .cornerRadius(10)
                   .disabled(isLoading)
                   .padding(.horizontal)
               }
               .padding()
           }
           .navigationBarItems(leading: Button("Cancel") { dismiss() })
           .sheet(isPresented: $showTerms) {
               TermsAndConditionsView()
           }
           .alert("구매 오류", isPresented: $showAlert) {
               Button("확인", role: .cancel) { }
           } message: {
               Text(alertMessage)
           }
       }
       .task {
           // 상품 정보 로드
           await storeService.loadProducts()
       }
   }
   
   private func handlePurchase() async {
       isLoading = true
       defer { isLoading = false }
       
       do {
           if let product = storeService.products.first(where: { $0.id == selectedPlan.productId }) {
               try await storeService.purchase(product)
               await MainActor.run {
                   dismiss()
               }
           } else {
               throw PurchaseError.productNotFound
           }
       } catch {
           await MainActor.run {
               alertMessage = error.localizedDescription
               showAlert = true
           }
       }
   }
}

enum PurchaseError: LocalizedError {
   case productNotFound
   
   var errorDescription: String? {
       switch self {
       case .productNotFound:
           return "선택한 구독 상품을 찾을 수 없습니다."
       }
   }
}

// StoreService의 PurchaseProduct enum 업데이트
enum PurchaseProduct: String, CaseIterable {
   case monthlySubscription = "com.aisnapstudy.subscription.monthly"
   case annualSubscription = "com.aisnapstudy.subscription.annual"
   
   var id: String { rawValue }
   var displayName: String {
       switch self {
       case .monthlySubscription:
           return "Monthly Subscription"
       case .annualSubscription:
           return "Annual Subscription"
       }
   }
}

struct TermsAndConditionsView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    Text("Payment will be charged to the user's iTunes Account upon confirmation of purchase.")
                        .padding(.bottom)
                    
                    Text("Subscription will renew automatically unless auto-renew is turned off at least 24 hours before the end of the current period.")
                        .padding(.bottom)
                    
                    Text("Account will be charged for renewal within 24 hours prior to the end of the current period and will identify the cost of the renewal.")
                        .padding(.bottom)
                    
                    Text("Subscriptions may be managed by the user and auto-renewal may be turned off in the user's account settings after purchase.")
                        .padding(.bottom)
                    
                    Text("Any unused portion of a free trial period, if offered, will be forfeited when the user purchases a subscription, where applicable.")
                        .padding(.bottom)
                }
                .padding()
            }
            .navigationTitle("Terms and conditions")
            .navigationBarItems(trailing: Button("Done") { dismiss() })
        }
    }
}

struct PlanCard: View {
    let type: SubscriptionPlansView.PlanType
    let title: String
    let price: String
    let period: String
    let description: String
    let isSelected: Bool
    var discount: String? = nil
    var isBestValue: Bool = false
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    if isBestValue {
                        Text("Best Value")
                            .font(.caption)
                            .fontWeight(.bold)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(Color.yellow)
                            .cornerRadius(12)
                    }
                    Spacer()
                    if isSelected {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                    }
                }
                
                Text(title)
                    .font(.title2)
                    .fontWeight(.bold)
                
                HStack(alignment: .firstTextBaseline) {
                    Text(price)
                        .font(.title)
                        .fontWeight(.bold)
                    Text(period)
                        .foregroundColor(.secondary)
                }
                
                if let discount = discount {
                    Text(discount)
                        .font(.subheadline)
                        .foregroundColor(.green)
                }
                
                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            .padding()
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(.systemBackground))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isSelected ? Color.blue : Color.gray.opacity(0.2), lineWidth: 2)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct SubscriptionInfoSection: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            Text("How annual subscriptions work")
                .font(.headline)
            
            HStack(spacing: 16) {
                Image(systemName: "lock.fill")
                    .foregroundColor(.yellow)
                    .frame(width: 30)
                
                VStack(alignment: .leading) {
                    Text("Today: Get instant access")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                    Text("You are billed for one year")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            HStack(spacing: 16) {
                Image(systemName: "arrow.clockwise")
                    .frame(width: 30)
                
                VStack(alignment: .leading) {
                    Text("December 16, 2025: Renewal")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                    Text("Your subscription is renewed for another year unless you cancel before this date.")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
}

struct FeatureRow: View {
    let icon: String
    let title: String
    let description: String
    
    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(.blue)
                .frame(width: 30)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.headline)
                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
    }
}


// View에서 사용할 수 있는 Premium 상태 표시 컴포넌트
struct SubscriptionStatusView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @State private var showUpgradeView = false
    
    var body: some View {
        HStack {
            Text(viewModel.subscriptionStatusText)
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            if !viewModel.isPremium {
                Button(action: {
                    showUpgradeView = true
                }) {
                    Text("Upgrade")
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.blue)
                        .cornerRadius(8)
                }
            }
        }
        .sheet(isPresented: $showUpgradeView) {
            PremiumUpgradeView()
        }
    }
}



// ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


// ./AISnapStudy/Views/Components/ReviewCard.swift



import SwiftUI

struct ReviewCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    let isSelected: Bool

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(question.question)
                .font(.headline)
                .lineLimit(2)
            
            HStack {
                Text(question.type.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.blue)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(isSelected ? Color.blue.opacity(0.1) : Color(.systemBackground))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isSelected ? Color.blue : Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}


// ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


// ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // 각 버튼에 대한 별도의 액션 정의
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // 중요: 버튼 스타일 분리
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // 중요: 버튼 스타일 분리
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @StateObject private var studyViewModel: StudyViewModel
    @StateObject private var reviewViewModel: ReviewViewModel  // 추가
    @State private var selectedTab = 0
    @StateObject private var statViewModel: StatViewModel
    
    
    init() {
        let homeVM = HomeViewModel.shared
        
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        
        // StudyViewModel 초기화 시점 변경
        let studyVM = StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        )
        self._studyViewModel = StateObject(wrappedValue: studyVM)
        
        let statVM = StatViewModel(
            context: CoreDataService.shared.viewContext,
            homeViewModel: homeVM,
            studyViewModel: studyVM
        )
        // ReviewViewModel 초기화 추가
        let reviewVM = ReviewViewModel(homeViewModel: homeVM)
        self._reviewViewModel = StateObject(wrappedValue: reviewVM)
        
        // StatViewModel도 studyViewModel 참조 추가
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
             context: CoreDataService.shared.viewContext,
             homeViewModel: homeVM,  // homeViewModel 전달
             studyViewModel: studyVM // studyViewModel 전달
         ))
        
        
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
        
        // homeViewModel에 studyViewModel 설정
        homeVM.setStudyViewModel(studyVM)
        
        // StatViewModel을 StudyViewModel에 연결
        studyVM.setStatViewModel(statVM)
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            Group {
                if studyViewModel.isGeneratingQuestions {  // 문제 생성 중일 때
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                } else if let problemSet = homeViewModel.selectedProblemSet {
                    StudyView(
                        questions: problemSet.questions,
                        studyViewModel: studyViewModel,
                        selectedTab: $selectedTab
                    )
                } else {
                    Text("No Problem Set Selected")
                }
            }
            .tabItem {
                Label("Study", systemImage: "book.fill")
            }
            .tag(1)
            
            ReviewView(
                viewModel: reviewViewModel,
                selectedTab: $selectedTab  // selectedTab 바인딩 전달
            )
            .tabItem {
                Label("Review", systemImage: "clock.fill")
            }
            .tag(2)
            
            StatView(
                viewModel: statViewModel,
                selectedTab: $selectedTab,
                correctAnswers: studyViewModel.correctAnswers,
                totalQuestions: studyViewModel.totalQuestions
            )
            .tabItem {
                Label("Result", systemImage: "checkmark.circle.fill")
            }
            .tag(3)
            
            // 새로 추가된 DailyStatsView 탭
            DailyStatsView(viewModel: statViewModel)
                .tabItem {
                    Label("Stats", systemImage: "chart.bar.fill")
                }
                .tag(4)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { newProblemSet in
            if let problemSet = newProblemSet,
               // Review에서 선택된 경우에만 탭 전환
               selectedTab == 2 {  // 2는 Review 탭
                studyViewModel.loadQuestions(problemSet.questions)
                selectedTab = 1  // Study 탭으로 전환
            }
        }
         .environmentObject(homeViewModel)
    }
}


// ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData


struct StatView: View {
   @ObservedObject var viewModel: StatViewModel
   @Binding var selectedTab: Int
   let correctAnswers: Int
   let totalQuestions: Int
   
   var incorrectAnswers: Int {
       totalQuestions - correctAnswers
   }
   
   var percentageCorrect: Int {
       guard totalQuestions > 0 else { return 0 }
       return Int((Double(correctAnswers) / Double(totalQuestions)) * 100)
   }
   
   var body: some View {
       ScrollView {
           VStack(spacing: 20) {
               Text("Result")
                   .font(.system(size: 34, weight: .bold))  // 크기를 키우고 볼드 처리
                   .padding(.top)
               
               // Progress Circle
               ZStack {
                   Circle()
                       .trim(from: 0, to: 1)
                       .stroke(Color.orange, lineWidth: 25)
                       .rotationEffect(.degrees(-90))
                       .frame(width: 200, height: 200)
                   
                   Circle()
                       .trim(from: 0, to: Double(correctAnswers) / Double(totalQuestions))
                       .stroke(Color.green, lineWidth: 25)
                       .rotationEffect(.degrees(-90))
                       .frame(width: 200, height: 200)
                   
                   Text("\(percentageCorrect)%")
                       .font(.system(size: 40, weight: .bold))
               }
               .padding(.vertical)
               
               // Correct/Incorrect Labels
               HStack(spacing: 50) {
                   HStack {
                       Text("Correct")
                           .foregroundColor(.green)
                       Text("\(correctAnswers)")
                           .font(.headline)
                           .padding(8)
                           .background(
                               Circle()
                                   .fill(Color.green.opacity(0.2))
                           )
                   }
                   
                   HStack {
                       Text("Incorrect")
                           .foregroundColor(.orange)
                       Text("\(incorrectAnswers)")
                           .font(.headline)
                           .padding(8)
                           .background(
                               Circle()
                                   .fill(Color.orange.opacity(0.2))
                           )
                   }
               }
               
               Spacer()
               
               VStack(spacing: 12) {
                   Button(action: {
                       viewModel.resetProgress()
                       viewModel.logCurrentQuestionState()
                       withAnimation {
                           selectedTab = 1
                       }
                   }) {
                       Text("Retry Test")
                           .font(.headline)
                           .foregroundColor(.white)
                           .padding()
                           .frame(maxWidth: .infinity)
                           .background(Color.blue)
                           .cornerRadius(10)
                   }
                   
                   Button(action: {
                       withAnimation {
                           selectedTab = 2  // Review 탭으로 이동
                       }
                   }) {
                       Text("Take New Test")
                           .font(.headline)
                           .foregroundColor(.white)
                           .padding()
                           .frame(maxWidth: .infinity)
                           .background(Color.green)
                           .cornerRadius(10)
                   }
               }
               .padding(.horizontal)
               .padding(.bottom, 20)
           }
       }
   }
}


// ./AISnapStudy/Views/Main/HomeView.swift




import SwiftUI
import Combine
import CoreData

// MARK: - Main View
struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var showUpgradeView = false
    @State private var showStudySets = false
    @State private var selectedSubject: DefaultSubject = .generalKnowledge
    @StateObject private var storeService = StoreService.shared
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 32) {
                    // Welcome Section
                    VStack(alignment: .leading, spacing: 24) {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Welcome Back!")
                                .font(.system(size: 32, weight: .bold))
                                .foregroundColor(colorScheme == .dark ? .white : .black)
                            
                            if !storeService.subscriptionStatus.isPremium {
                                HStack(spacing: 8) {
                                    Image(systemName: "sparkles")
                                        .foregroundColor(.yellow)
                                    Text("\(storeService.subscriptionStatus.dailyQuestionsRemaining) questions remaining")
                                        .foregroundColor(.secondary)
                                }
                                .font(.system(size: 16))
                            }
                        }
                        .padding(.horizontal, 24)
                        
                        // Create Questions Button
                        Button(action: {
                            if storeService.subscriptionStatus.dailyQuestionsRemaining > 0 {
                                selectedSubject = .generalKnowledge
                                showQuestionSettings = true
                            } else {
                                // 남은 질문이 없을 때는 업그레이드 안내
                                showUpgradeView = true
                            }
                        }) {
                            HStack(spacing: 12) {
                                Image(systemName: "sparkles")
                                    .font(.system(size: 28))
                                Text("Create New Questions")
                                    .font(.system(size: 22, weight: .semibold))
                            }
                            .frame(maxWidth: .infinity)
                            .frame(height: 100)
                            .foregroundColor(.white)
                            .background(
                                LinearGradient(
                                    colors: [
                                        storeService.subscriptionStatus.dailyQuestionsRemaining > 0 ? .blue : .gray,
                                        storeService.subscriptionStatus.dailyQuestionsRemaining > 0 ? .blue.opacity(0.8) : .gray.opacity(0.8)
                                    ],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .cornerRadius(16)
                        }
                        .padding(.horizontal, 24)
                    }
                    
                    // Favorites Section
                    if !viewModel.favoriteProblemSets.isEmpty {
                        VStack(alignment: .leading, spacing: 20) {
                            HStack(spacing: 12) {
                                Image(systemName: "star.fill")
                                    .foregroundColor(.yellow)
                                    .font(.system(size: 24))
                                Text("Favorites")
                                    .font(.system(size: 24, weight: .bold))
                                    .foregroundColor(colorScheme == .dark ? .white : .black)
                            }
                            .padding(.horizontal, 24)
                            
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: 16) {
                                    ForEach(viewModel.favoriteProblemSets) { set in
                                        Button {
                                            Task {
                                                await viewModel.setSelectedProblemSet(set)
                                                if let studyViewModel = viewModel.studyViewModel {
                                                    await studyViewModel.resetState()
                                                    selectedTab = 1
                                                }
                                            }
                                        } label: {
                                            VStack(alignment: .leading, spacing: 8) {
                                                Text(set.name)
                                                    .font(.system(size: 18, weight: .semibold))
                                                    .foregroundColor(.primary)
                                                    .lineLimit(1)
                                                    .truncationMode(.tail)
                                                Text("\(set.questions.count) Questions")
                                                    .font(.system(size: 14))
                                                    .foregroundColor(.secondary)
                                            }
                                            .frame(width: 230)
                                            .padding(16)
                                            .background(colorScheme == .dark ? Color(.systemGray6) : .white)
                                            .cornerRadius(12)
                                            .overlay(
                                                RoundedRectangle(cornerRadius: 12)
                                                    .stroke(Color.gray.opacity(0.1), lineWidth: 3)
                                            )
                                            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
                                        }
                                    }
                                }
                                .padding(.horizontal, 24)
                            }
                        }
                    }
                    
                    // Library Section
                    VStack(alignment: .leading, spacing: 20) {
                        HStack(spacing: 12) {
                            Image(systemName: "square.stack.3d.up.fill")
                                .foregroundColor(.blue)
                                .font(.system(size: 24))
                            Text("Library")
                                .font(.system(size: 24, weight: .bold))
                                .foregroundColor(colorScheme == .dark ? .white : .black)
                        }
                        .padding(.horizontal, 24)
                        
                        Button {
                            showStudySets = true
                        } label: {
                            HStack {
                                Text("View library question sets")
                                    .font(.system(size: 18))
                                    .foregroundColor(.primary)
                                Spacer()
                                Text("\(viewModel.remoteSets.count) Sets")
                                    .foregroundColor(.secondary)
                                Image(systemName: "chevron.right")
                                    .font(.system(size: 14))
                                    .foregroundColor(.secondary)
                            }
                            .padding(20)
                            .background(colorScheme == .dark ? Color(.systemGray6) : .white)
                            .cornerRadius(12)
                            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
                        }
                        .padding(.horizontal, 24)
                    }
                }
                .padding(.vertical, 32)
            }
            .background(colorScheme == .dark ? Color.black : Color(.systemBackground))
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .principal) {
                    HStack {
                        Text("AI Study")
                            .font(.system(size: 34, weight: .bold))
                            .foregroundColor(colorScheme == .dark ? .white : .black)
                        Spacer()
                        if !storeService.subscriptionStatus.isPremium {
                            Button(action: { showUpgradeView = true }) {
                                Text("Upgrade")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.black)
                                    .padding(.horizontal, 16)
                                    .padding(.vertical, 8)
                                    .background(Color.yellow)
                                    .cornerRadius(20)
                            }
                        }
                    }
                    .padding(.bottom, 8)
                }
            }
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab
            )
        }
        .sheet(isPresented: $showUpgradeView) {
            PremiumUpgradeView()
        }
        .sheet(isPresented: $showStudySets) {
            StudySetsView(viewModel: viewModel)
        }
    }
}


// MARK: - Section Header
struct SectionHeader: View {
    let title: String
    let icon: String
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: icon)
                .foregroundColor(.blue)
            Text(title)
                .font(.title3.bold())
        }
        .padding(.horizontal)
    }
}

// MARK: - Welcome Section
struct WelcomeSection: View {
    let isPremium: Bool
    let remainingQuestions: Int
    @Binding var showUpgradeView: Bool
    
    var body: some View {
        VStack(spacing: 16) {
            // 환영 메시지 카드
            CardView {
                HStack {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Welcome Back!")
                            .font(.title2.bold())
                        Text("Ready to learn something new?")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                    Spacer()
                    Image(systemName: "brain.head.profile")
                        .font(.system(size: 40))
                        .foregroundColor(.blue)
                }
            }
            
            // 프리미엄 배너 (무료 사용자만 표시)
            if !isPremium {
                Button(action: { showUpgradeView = true }) {
                    CardView {
                        HStack {
                            HStack(spacing: 8) {
                                Image(systemName: "star.fill")
                                    .foregroundColor(.yellow)
                                Text("Upgrade to Premium")
                                    .fontWeight(.semibold)
                            }
                            Spacer()
                            Text("\(remainingQuestions) questions left")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
        .padding(.horizontal)
    }
}

// CardView 컴포넌트
struct CardView<Content: View>: View {
    let content: Content
    
    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }
    
    var body: some View {
        content
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
    }
}




// MARK: - Favorites List
struct FavoritesList: View {
    let problemSets: [ProblemSet]
    let viewModel: HomeViewModel
    @Binding var selectedTab: Int
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(problemSets) { set in
                    FavoriteCard(
                        set: set,
                        action: {
                            Task {
                                await viewModel.setSelectedProblemSet(set)
                                if let studyViewModel = viewModel.studyViewModel {
                                    await studyViewModel.resetState()
                                    selectedTab = 1
                                }
                            }
                        }
                    )
                }
            }
            .padding(.horizontal)
        }
    }
}

// MARK: - Favorite Card
// 선택적으로 별도의 FavoriteCard 컴포넌트로 분리할 수도 있습니다
struct FavoriteCard: View {
    let set: ProblemSet
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 8) {
                Text(set.name)
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .truncationMode(.tail)
                Text("\(set.questions.count) Questions")
                    .font(.system(size: 14))
                    .foregroundColor(.gray)
            }
            .frame(width: 280)
            .padding(16)
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
    }
}

// MARK: - Downloadable Sets List
struct DownloadableSetsList: View {
    let remoteSets: [RemoteQuestionSet]
    let viewModel: HomeViewModel
    
    var body: some View {
        VStack(spacing: 4) { // 리스트의 간격만 줄임
            ForEach(remoteSets) { set in
                DownloadableSetCard(
                    set: set,
                    action: {
                        Task {
                            await viewModel.downloadQuestionSet(set)
                        }
                    }
                )
            }
        }
        .padding(.horizontal)
    }
}

struct DownloadableSetCard: View {
    let set: RemoteQuestionSet
    let action: () -> Void
    
    @State private var isDownloading = false
    @State private var isCompleted = false
    
    var body: some View {
        CardView {
            HStack(spacing: 12) {
                // 타이틀과 정보
                VStack(alignment: .leading, spacing: 4) {
                    Text(set.title)
                        .font(.headline)
                    
                    HStack(spacing: 12) {
                        // 문제 수
                        HStack(spacing: 4) {
                            Image(systemName: "doc.text")
                                .foregroundColor(.blue)
                            Text("\(set.questionCount)")
                                .foregroundColor(.secondary)
                        }
                        .font(.subheadline)
                        
                        // 난이도
                        HStack(spacing: 4) {
                            Image(systemName: "chart.bar.fill")
                                .foregroundColor(.blue)
                            Text(set.difficulty)
                                .foregroundColor(.secondary)
                        }
                        .font(.subheadline)
                    }
                }
                
                Spacer()
                
                // 다운로드 버튼
                Button {
                    withAnimation {
                        isDownloading = true
                    }
                    action()
                    
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                        withAnimation {
                            isDownloading = false
                            isCompleted = true
                        }
                    }
                } label: {
                    Group {
                        if isCompleted {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                        } else if isDownloading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle())
                        } else {
                            Image(systemName: "arrow.down.circle.fill")
                                .foregroundColor(.blue)
                        }
                    }
                    .frame(width: 24, height: 24)
                }
                .disabled(isDownloading || isCompleted)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
        }
        .padding(.horizontal)
        .padding(.vertical, 4)
    }
}


// 원격 문제 세트 섹션 컴포넌트
struct RemoteQuestionSetsSection: View {
    let remoteSets: [RemoteQuestionSet]
    let viewModel: HomeViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Available Question Sets")
                .font(.system(size: 20, weight: .semibold))
                .foregroundColor(.primary)
                .padding(.horizontal)
            
            ForEach(remoteSets) { remoteSet in
                RemoteQuestionSetCard(
                    set: remoteSet,
                    onDownload: {
                        Task {
                            await viewModel.downloadQuestionSet(remoteSet)
                        }
                    }
                )
                .padding(.horizontal)
            }
        }
    }
}

// 원격 문제 세트 카드 컴포넌트
struct RemoteQuestionSetCard: View {
    let set: RemoteQuestionSet
    let onDownload: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(set.title)
                .font(.headline)
                .foregroundColor(.primary)
            
            Text(set.description)
                .font(.subheadline)
                .foregroundColor(.secondary)
                .lineLimit(2)
            
            HStack {
                HStack(spacing: 8) {
                    Image(systemName: "doc.text")
                        .foregroundColor(.blue)
                    Text("\(set.questionCount) questions")
                }
                .font(.caption)
                .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: onDownload) {
                    HStack {
                        Image(systemName: "arrow.down.circle.fill")
                        Text("Download")
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
    }
}

// Premium 업그레이드 버튼 컴포넌트
struct PremiumUpgradeButton: View {
    let remainingQuestions: Int
    @Binding var showUpgradeView: Bool
    
    var body: some View {
        Button(action: {
            showUpgradeView = true
        }) {
            HStack {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
                Text("Upgrade to Premium")
                    .fontWeight(.semibold)
                    .foregroundColor(.primary)
                Spacer()
                Text("\(remainingQuestions) questions left")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding()
            .background(Color(.systemBackground))
            .cornerRadius(10)
            .shadow(radius: 2)
        }
        .padding(.horizontal)
    }
}



// ./AISnapStudy/Views/Main/ReviewView.swift

import SwiftUI

struct ReviewView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @ObservedObject var viewModel: ReviewViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var showSubjectManagement = false
    @State private var searchText = ""
    @State private var selectedSubject: SubjectType?
    @Binding var selectedTab: Int
   
    public init(viewModel: ReviewViewModel, selectedTab: Binding<Int>) {
        self.viewModel = viewModel
        self._selectedTab = selectedTab
    }
    
    private var visibleSubjects: [SubjectType] {
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        📚 ReviewView - Visible Subjects:
        • Total Subjects: \(subjects.count)
        • Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        • Active Custom Subjects: \(customSubjects.map { $0.displayName })
        • Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
   
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 5) {
                    Spacer()
                        .frame(height: 5)
                    
                    // Add Saved Questions Card
                    NavigationLink(
                        destination: SavedQuestionsView(selectedTab: $selectedTab)
                    ) {
                        SavedQuestionsCard(savedCount: homeViewModel.savedQuestions.count)
                    }
                    .buttonStyle(PlainButtonStyle())
                    .padding(.horizontal)
                    
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 5) {
                        ForEach(visibleSubjects, id: \.id) { subject in
                            NavigationLink(
                                destination: ProblemSetsListView(
                                    subject: subject,
                                    problemSets: filterProblemSets(subject: subject),
                                    selectedTab: $selectedTab
                                )
                            ) {
                                SubjectCardView(
                                    subject: subject,
                                    problemSetCount: filterProblemSets(subject: subject).count
                                )
                            }
                        }
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .principal) {
                    Text("Review")
                        .font(.system(size: 34, weight: .bold))  // 크기를 키우고 볼드 처리
                        .padding(.bottom, 5)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showSubjectManagement = true
                    }) {
                        Image(systemName: "slider.horizontal.3")
                            .foregroundColor(.blue)
                            .imageScale(.large)
                    }
                }
            }
            .sheet(isPresented: $showSubjectManagement) {
                NavigationView {
                    SubjectManagementView()
                        .navigationTitle("Manage Subjects")
                        .navigationBarItems(
                            trailing: Button("Done") {
                                showSubjectManagement = false
                            }
                        )
                }
            }
        }
    }
    
    private func filterProblemSets(subject: SubjectType) -> [ProblemSet] {
        return homeViewModel.problemSets.filter { problemSet in
            if let defaultSubject = subject as? DefaultSubject {
                return problemSet.subjectType == "default" &&
                       problemSet.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return problemSet.subjectType == "custom" &&
                       problemSet.subjectId == customSubject.id
            }
            return false
        }
    }
}

// Add new SavedQuestionsCard component
struct SavedQuestionsCard: View {
    let savedCount: Int
    
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: "bookmark.fill")
                .font(.system(size: 24))
                .foregroundColor(.blue)
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Saved Questions")
                    .font(.headline)
                Text("\(savedCount) questions saved")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Image(systemName: "chevron.right")
                .foregroundColor(.gray)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(
                    color: Color.black.opacity(0.1),
                    radius: 8,
                    x: 0,
                    y: 4
                )
        )
    }
}

struct SubjectCardView: View {
    let subject: SubjectType
    let problemSetCount: Int
    
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: subject.icon)
                .font(.system(size: 32))
                .foregroundColor(subject.color)
            
            Text(subject.displayName)
                .font(.headline)
                .foregroundColor(.primary)
                .lineLimit(1)
            
            Text("\(problemSetCount) sets")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 24)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(subject.color.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(subject.color.opacity(0.2), lineWidth: 1)
                )
        )
        .contentShape(Rectangle())
    }
}

struct ProblemSetsListView: View {
    let subject: SubjectType
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int
    @State private var isEditMode = false
    @State private var showHelpAlert = false
    @State private var localProblemSets: [ProblemSet] = []
    
    // 알림 관련 상태
    @State private var isShowingDeleteAlert = false
    @State private var problemSetToDelete: ProblemSet?
    @State private var showingMergeAlert = false
    @State private var mergingProblemSets: (source: ProblemSet, target: ProblemSet)?
    @State private var mergeSetName = ""
    
    var body: some View {
        ProblemSetListContainer(
            localProblemSets: localProblemSets,
            isEditMode: isEditMode,
            selectedTab: $selectedTab,
            problemSetToDelete: $problemSetToDelete,
            isShowingDeleteAlert: $isShowingDeleteAlert
        )
        .navigationTitle(subject.displayName)
        .toolbar {
            ProblemSetToolbar(
                isEditMode: $isEditMode,
                showHelpAlert: $showHelpAlert
            )
        }
        .onAppear { localProblemSets = problemSets }
        .onChange(of: homeViewModel.problemSets) { newProblemSets in
            updateLocalProblemSets(newProblemSets)
        }
        .alert("Delete Problem Set", isPresented: $isShowingDeleteAlert) {
            DeleteAlertButtons(
                problemSetToDelete: problemSetToDelete,
                homeViewModel: homeViewModel
            )
        }
    }
    
    private func updateLocalProblemSets(_ newProblemSets: [ProblemSet]) {
        localProblemSets = newProblemSets.filter { set in
            if let defaultSubject = subject as? DefaultSubject {
                return set.subjectType == "default" && set.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return set.subjectType == "custom" && set.subjectId == customSubject.id
            }
            return false
        }
    }
}

// MARK: - Supporting Views
private struct ProblemSetListContainer: View {
    let localProblemSets: [ProblemSet]
    let isEditMode: Bool
    @Binding var selectedTab: Int
    @Binding var problemSetToDelete: ProblemSet?
    @Binding var isShowingDeleteAlert: Bool
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var refreshID = UUID() // 추가
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                LazyVStack(spacing: 12) {
                    ForEach(localProblemSets) { problemSet in
                        ProblemSetItem(
                            problemSetId: problemSet.id,  // ID만 전달
                            isEditMode: isEditMode,
                            selectedTab: $selectedTab,
                            problemSetToDelete: $problemSetToDelete,
                            isShowingDeleteAlert: $isShowingDeleteAlert,
                            onFavoriteToggle: {
                                Task {
                                    await homeViewModel.toggleFavorite(problemSet)
                                    // UI 강제 새로고침
                                    await MainActor.run {
                                        refreshID = UUID()
                                    }
                                }
                            }
                        )
                    }
                }
            }
            .padding(.vertical)
            .id(refreshID) // 추가
        }
    }
}

private struct ProblemSetItem: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    let problemSetId: String  // problemSet 대신 ID만 저장
    let isEditMode: Bool
    @Binding var selectedTab: Int
    @Binding var problemSetToDelete: ProblemSet?
    @Binding var isShowingDeleteAlert: Bool
    let onFavoriteToggle: () -> Void

    // 필요할 때마다 최신 problemSet 데이터 조회
    private var problemSet: ProblemSet? {
        homeViewModel.problemSets.first { $0.id == problemSetId }
    }
    
    // 생성자 수정
    init(problemSetId: String,
         isEditMode: Bool,
         selectedTab: Binding<Int>,
         problemSetToDelete: Binding<ProblemSet?>,
         isShowingDeleteAlert: Binding<Bool>,
         onFavoriteToggle: @escaping () -> Void) {
        self.problemSetId = problemSetId
        self.isEditMode = isEditMode
        self._selectedTab = selectedTab
        self._problemSetToDelete = problemSetToDelete
        self._isShowingDeleteAlert = isShowingDeleteAlert
        self.onFavoriteToggle = onFavoriteToggle
    }
    
    var body: some View {
        Group {
            if let currentProblemSet = problemSet {
                ReviewProblemSetCard(
                    subject: currentProblemSet.resolvedSubject,
                    problemSet: currentProblemSet,
                    isEditMode: isEditMode,
                    onDelete: {
                        problemSetToDelete = currentProblemSet
                        isShowingDeleteAlert = true
                    },
                    onRename: { newName in
                        Task {
                            await homeViewModel.renameProblemSet(currentProblemSet, newName: newName)
                        }
                    },
                    onFavoriteToggle: onFavoriteToggle
                )
                .onTapGesture {
                    handleTap(problemSet: currentProblemSet)
                }
            }
        }
        .padding(.horizontal)
    }
    
    private func handleTap(problemSet: ProblemSet) {
        Task {
            await homeViewModel.setSelectedProblemSet(problemSet)
            if let studyViewModel = homeViewModel.studyViewModel {
                await studyViewModel.resetState()
                await MainActor.run {
                    withAnimation {
                        selectedTab = 1
                    }
                }
            }
        }
    }
}

private struct ProblemSetToolbar: ToolbarContent {
    @Binding var isEditMode: Bool
    @Binding var showHelpAlert: Bool
    
    var body: some ToolbarContent {
        ToolbarItem(placement: .navigationBarTrailing) {
            HStack(spacing: 16) {
                Button(action: { showHelpAlert = true }) {
                    Image(systemName: "questionmark.circle")
                        .imageScale(.large)
                        .foregroundColor(.blue)
                }
                
                Button(action: {
                    withAnimation {
                        isEditMode.toggle()
                    }
                }) {
                    Image(systemName: isEditMode ? "checkmark.circle.fill" : "pencil.circle")
                        .imageScale(.large)
                        .foregroundColor(isEditMode ? .green : .blue)
                }
            }
        }
    }
}

private struct DeleteAlertButtons: View {
    let problemSetToDelete: ProblemSet?
    let homeViewModel: HomeViewModel
    
    var body: some View {
        Group {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let problemSet = problemSetToDelete {
                    Task {
                        await homeViewModel.deleteProblemSet(problemSet)
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Main/StudySetsView.swift

import SwiftUI


// 정렬 옵션을 위한 enum
enum SortOption: String, CaseIterable {
    case name = "Name"
    case questionCount = "Questions"
    case difficulty = "Difficulty"
}

struct StudySetsView: View {
    let viewModel: HomeViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var selectedSort: SortOption = .name
    @State private var isAscending = true
    
    private var sortedSets: [RemoteQuestionSet] {
        var sets = viewModel.remoteSets
        
        switch selectedSort {
        case .name:
            sets.sort { (set1, set2) in
                isAscending ? set1.title < set2.title : set1.title > set2.title
            }
        case .questionCount:
            sets.sort { (set1, set2) in
                isAscending ? set1.questionCount < set2.questionCount : set1.questionCount > set2.questionCount
            }
        case .difficulty:
            let difficultyOrder = ["Elementary": 0, "Middle": 1, "Hard": 2]
            sets.sort { (set1, set2) in
                let order1 = difficultyOrder[set1.difficulty] ?? 0
                let order2 = difficultyOrder[set2.difficulty] ?? 0
                return isAscending ? order1 < order2 : order1 > order2
            }
        }
        
        return sets
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 2) {
                    ForEach(sortedSets) { set in
                        DownloadableSetCard(
                            set: set,
                            action: {
                                Task {
                                    await viewModel.downloadQuestionSet(set)
                                }
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Text("Study Sets")
                        .font(.system(size: 22, weight: .semibold))
                        .foregroundColor(.primary)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    HStack(spacing: 16) {
                        Menu {
                            Picker("Sort by", selection: $selectedSort) {
                                ForEach(SortOption.allCases, id: \.self) { option in
                                    Text(option.rawValue)
                                }
                            }
                            
                            Divider()
                            
                            Button(action: { isAscending.toggle() }) {
                                HStack {
                                    Text(isAscending ? "Ascending" : "Descending")
                                    Image(systemName: isAscending ? "arrow.up" : "arrow.down")
                                }
                            }
                        } label: {
                            Image(systemName: "arrow.up.arrow.down")
                                .foregroundColor(.blue)
                        }
                        
                        Button("Done") {
                            dismiss()
                        }
                    }
                }
            }
        }
    }
}




// LocalSetCard 컴포넌트
struct LocalSetCard: View {
    let set: ProblemSet
    let viewModel: HomeViewModel
    
    var body: some View {
        CardView {
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(set.name)
                            .font(.headline)
                        Text("\(set.questions.count) Questions")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                    
                    Spacer()
                    
                    Button {
                        Task {
                            await viewModel.toggleFavorite(set)
                        }
                    } label: {
                        Image(systemName: set.isFavorite ? "star.fill" : "star")
                            .foregroundColor(set.isFavorite ? .yellow : .gray)
                    }
                }
            }
            .padding()
        }
        .padding(.horizontal)
    }
}


// ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
    @EnvironmentObject var homeViewModel: HomeViewModel  // 추가
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
    @State private var isCorrect: Bool? = nil  // 이 부분이 중요합니다
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // 추가
   @State private var previewIsCorrect: Bool? = nil        // 추가
    @State private var showDeleteAlert = false  // 추가
    @State private var questionToDelete: Question? = nil  // 추가
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
    var body: some View {
        VStack {
            if studyViewModel.isGeneratingQuestions {
                VStack(spacing: 16) {
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.white)
                    .transition(.opacity)
                    
                    if !studyViewModel.generatedQuestions.isEmpty {
                        ScrollView {
                            LazyVStack(spacing: 12) {
                                ForEach(studyViewModel.generatedQuestions) { question in
                                    QuestionPreviewCard(
                                        question: question,
                                        selectedAnswer: $previewSelectedAnswer,
                                        isCorrect: $previewIsCorrect,
                                        onAnswerSelected: { correct in
                                            print("Answer selected: \(correct)")
                                        }
                                    )
                                    .transition(.slide)
                                }
                            }
                            .padding()
                        }
                    }
                }
            } else if !studyViewModel.hasQuestions {
                Text("No questions available")
                    .font(.title3)
                    .foregroundColor(.gray)
            } else {
                VStack {
                    Spacer()
                        .frame(height: 20)
                    
                    ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                               total: Double(studyViewModel.totalQuestions))
                        .progressViewStyle(CustomProgressViewStyle())
                        .padding(.horizontal, 20)
                        .padding(.bottom, 10)
                    
                    Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.secondary)
                        .padding(.bottom, 20)
                    
                    if !studyViewModel.hasQuestions {
                        Text("No questions available")
                            .font(.title3)
                            .foregroundColor(.gray)
                    } else {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 20) {
                                if let currentQuestion = studyViewModel.currentQuestion {
                                    switch currentQuestion.type {
                                    case .multipleChoice:
                                        MultipleChoiceView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect
                                        )
                                        
                                    case .trueFalse:
                                        TrueFalseView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect  // 여기 isCorrect 바인딩이 문제일 수 있습니다
                                        )
                                    }
                                    
                                    if showExplanation && studyViewModel.showExplanation {
                                        ExplanationView(explanation: currentQuestion.explanation)
                                    }
                                }
                            }
                            .padding()
                        }
                        
                        VStack {
                            Divider()
                            
                            HStack(spacing: 12) {
                                if studyViewModel.showExplanation {
                                    UtilityButtons(
                                        showExplanation: $showExplanation,
                                        isSaved: $isSaved,
                                        studyViewModel: studyViewModel,
                                        onDelete: {
                                            questionToDelete = studyViewModel.currentQuestion
                                            showDeleteAlert = true
                                        }
                                    )
                                }
                                
                                ActionButton(
                                    viewModel: studyViewModel,
                                    selectedTab: $selectedTab,
                                    isCorrect: $isCorrect,
                                    showExplanation: $showExplanation
                                )
                            }
                            .padding()
                            .background(Color(UIColor.systemBackground))
                        }
                    }
                }
            }
        }
        .alert("Delete Question", isPresented: $showDeleteAlert) {  // 추가
                    Button("Cancel", role: .cancel) { }
                    Button("Delete", role: .destructive) {
                        if let question = questionToDelete,
                           let problemSet = homeViewModel.selectedProblemSet {
                            Task {
                                await homeViewModel.removeQuestionFromProblemSet(
                                    question.id,
                                    from: problemSet
                                )
                            }
                        }
                    }
                } message: {
                    Text("Are you sure you want to delete this question?")
                }
        .onAppear {
            if let currentQuestion = studyViewModel.currentQuestion {
                isSaved = currentQuestion.isSaved
            }
        }
        .onChange(of: studyViewModel.currentQuestion) { newQuestion in
            if let question = newQuestion {
                isSaved = question.isSaved
            }
        }
    }
}

struct CustomProgressViewStyle: ProgressViewStyle {
    func makeBody(configuration: Configuration) -> some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 12)
                
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.blue)
                    .frame(width: CGFloat(configuration.fractionCompleted ?? 0) * geometry.size.width,
                           height: 12)
            }
        }
        .frame(height: 12)
    }
}

// 새로 추가된 미리보기 카드 뷰
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // 상단 정보
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
          }
          
          // 질문
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // 답변 옵션
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// 기존 컴포넌트들은 유지
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   let onDelete: () -> Void
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
           
           Button(action: onDelete) {
               Image(systemName: "trash")
                   .foregroundColor(.red)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.red.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil  // 다음 문제로 넘어갈 때 리셋
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               if let currentQuestion = viewModel.currentQuestion,
                  let selectedAnswer = viewModel.selectedAnswer {
                   isCorrect = currentQuestion.correctAnswer.lowercased() == selectedAnswer.lowercased()
               }
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}

struct GeneratingQuestionsOverlay: View {
    let questionCount: Int  // 필요하지만 사용하지 않을 매개변수
    @State private var rotation: Double = 0
    @State private var dotScale: CGFloat = 1.0
    @State private var currentTipIndex = 0
    let timer = Timer.publish(every: 5, on: .main, in: .common).autoconnect()
    
    var body: some View {
        ZStack {
            // 배경색을 흰색으로 변경
            Color.white
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 30) {
                // Main Animation Circle
                ZStack {
                    // Outer rotating circle
                    Circle()
                        .stroke(lineWidth: 6)
                        .frame(width: 200, height: 200)
                        .foregroundColor(.blue.opacity(0.3))
                        .rotationEffect(.degrees(rotation))
                    
                    // Inner gradient circle
                    Circle()
                        .stroke(
                            LinearGradient(
                                gradient: Gradient(colors: [.blue, .purple]),
                                startPoint: .top,
                                endPoint: .bottom
                            ),
                            lineWidth: 10
                        )
                        .frame(width: 180, height: 180)
                        .rotationEffect(.degrees(-rotation))
                    
                    // Center content - 텍스트 색상을 검은색으로 변경하고 Questions 수 표시 제거
                    VStack(spacing: 8) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 40))
                            .foregroundColor(.blue)
                        Text("Generating")
                            .font(.title)
                            .foregroundColor(.black)  // 검은색으로 변경
                        Text("Questions")
                            .font(.title2)
                            .foregroundColor(.black)  // 검은색으로 변경
                    }
                }
                .onAppear {
                    withAnimation(
                        .linear(duration: 4)
                        .repeatForever(autoreverses: false)
                    ) {
                        rotation = 360
                    }
                }
                
                // Animated Dots
                HStack(spacing: 8) {
                    ForEach(0..<3) { index in
                        Circle()
                            .fill(Color.blue)
                            .frame(width: 12, height: 12)
                            .scaleEffect(dotScale)
                            .animation(
                                .easeInOut(duration: 0.6)
                                .repeatForever()
                                .delay(Double(index) * 0.2),
                                value: dotScale
                            )
                    }
                }
                .onAppear {
                    dotScale = 0.5
                }
                
                // Tips Section
                VStack(spacing: 12) {
                    Text(tips[currentTipIndex])
                        .font(.headline)
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                        .frame(height: 60)
                        .transition(.opacity.combined(with: .slide))
                        .id(currentTipIndex)
                        .animation(.easeInOut, value: currentTipIndex)
                    
                    // Progress Dots
                    HStack(spacing: 6) {
                        ForEach(0..<tips.count) { index in
                            Circle()
                                .fill(index == currentTipIndex ? Color.white : Color.gray)
                                .frame(width: 8, height: 8)
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 15)
                        .fill(Color.blue.opacity(0.8))
                )
            }
            .padding(30)
        }
        .onReceive(timer) { _ in
            withAnimation {
                currentTipIndex = (currentTipIndex + 1) % tips.count
            }
        }
    }
    
    private let tips = [
        "Creating personalized questions just for you...",
        "Analyzing content to ensure the best learning experience...",
        "Getting ready to challenge your knowledge...",
        "Preparing explanations to help you understand better...",
        "Almost there! Your questions are being finalized..."
    ]
}

struct GeneratedQuestionPreviewCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: question.type == .multipleChoice ? "list.bullet.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(.blue)
                Text(question.type == .multipleChoice ? "Multiple Choice" : "True/False")
                    .font(.caption)
                    .foregroundColor(.blue)
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .foregroundColor(.primary)
        }
        .padding()
        .background(Color.white)
        .cornerRadius(10)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
    }
}


// ./AISnapStudy/Views/Stats/CalendarStatsView.swift

import SwiftUI



struct CalendarStatsView: View {
    @State private var selectedMonth = Date()  // 내부에서 상태 관리
    let monthlyData: [Date: [DailyStats]]
    private let calendar = Calendar.current
    private let daysInWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    
    private var calendarDays: [CalendarDay] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: selectedMonth),
              let monthFirstWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.start),
              let monthLastWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.end) else {
            return []
        }
        
        let dateInterval = DateInterval(start: monthFirstWeek.start, end: monthLastWeek.end)
        let dates = calendar.generateDates(for: dateInterval, matching: DateComponents(hour: 0))
        
        return dates.enumerated().map { CalendarDay(id: $0, date: $1) }
    }
    
    private func convertToDailyProgress(_ stats: DailyStats) -> DailyProgress {
        return DailyProgress(
            date: stats.date,
            questionsCompleted: stats.totalQuestions,
            correctAnswers: stats.correctAnswers,
            totalTime: 0  // 시간 데이터가 없다면 0으로 설정
        )
    }
    
    var body: some View {
        VStack {
            HStack {
                Button(action: previousMonth) {
                    Image(systemName: "chevron.left")
                }
                
                Text(monthString)
                    .font(.headline)
                    .frame(maxWidth: .infinity)
                
                Button(action: nextMonth) {
                    Image(systemName: "chevron.right")
                }
            }
            .padding(.bottom)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 7)) {
                 // 요일 헤더
                 ForEach(daysInWeek, id: \.self) { day in
                     Text(day)
                         .font(.caption)
                         .foregroundColor(.secondary)
                 }
                 
                 // 날짜 그리드
                 ForEach(calendarDays, id: \.id) { calendarDay in
                     if let stats = statsFor(date: calendarDay.date) {
                         DayCellView(
                             date: calendarDay.date,
                             progress: convertToDailyProgress(stats)
                         )
                     } else {
                         Text(String(calendar.component(.day, from: calendarDay.date)))
                             .font(.caption)
                             .foregroundColor(.secondary)
                             .frame(height: 35)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var monthString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: selectedMonth)
    }
    
    private var days: [Date] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: selectedMonth),
              let monthFirstWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.start),
              let monthLastWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.end) else {
            return []
        }
        
        let dateInterval = DateInterval(start: monthFirstWeek.start, end: monthLastWeek.end)
        return calendar.generateDates(for: dateInterval, matching: DateComponents(hour: 0))
    }
    
    private func statsFor(date: Date) -> DailyStats? {
        let monthRange = calendar.monthDateRange(for: selectedMonth)
        guard let stats = monthlyData[monthRange.start] else { return nil }
        return stats.first { calendar.isDate($0.date, inSameDayAs: date) }
    }
    
    private func previousMonth() {
        selectedMonth = calendar.date(byAdding: .month, value: -1, to: selectedMonth) ?? selectedMonth
    }
    
    private func nextMonth() {
        selectedMonth = calendar.date(byAdding: .month, value: 1, to: selectedMonth) ?? selectedMonth
    }
}




// ./AISnapStudy/Views/Stats/DailyStatsView.swift

import SwiftUI
import Charts

enum TimeRange: String, CaseIterable {
    case week = "Week"
    case month = "Month"
}

struct DailyStatsView: View {
    @State private var currentMonthDate = Date()  // 추가된 상태 변수
    @ObservedObject var viewModel: StatViewModel
    @State private var selectedTimeRange: TimeRange = .week
    @State private var selectedDate = Date()
    @State private var showingDatePicker = false
    
    private var todayStats: DailyProgress? {
        let calendar = Calendar.current
        return viewModel.weeklyProgress.first {
            calendar.isDate($0.date, inSameDayAs: Date())
        }
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                timePicker
                
                switch selectedTimeRange {
                case .week:
                    weeklyProgressChart
                case .month:
                    VStack(spacing: 10) {
                        // 월 이동 컨트롤
                        HStack {
                            Button(action: previousMonth) {
                                Image(systemName: "chevron.left")
                                    .font(.title3)
                            }
                            
                            Text(monthYearString)
                                .font(.headline)
                                .frame(maxWidth: .infinity)
                            
                            Button(action: nextMonth) {
                                Image(systemName: "chevron.right")
                                    .font(.title3)
                            }
                        }
                        .padding(.horizontal)
                        
                        MonthCalendarView(
                            month: currentMonthDate,
                            monthlyData: viewModel.monthlyProgress
                        )
                    }
                }
                
                StatsCircleContainer(
                    todayStats: todayStats,
                    weeklyStats: viewModel.weeklyProgress,
                    monthlyProgress: viewModel.monthlyProgress,  // 추가
                    selectedTimeRange: selectedTimeRange,        // 추가
                    currentMonthDate: currentMonthDate
                )
            }
            .padding()
        }
        .navigationTitle("Daily Statistics")
    }
    
    private var monthYearString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: currentMonthDate)
    }
    
    private func previousMonth() {
        if let newDate = Calendar.current.date(byAdding: .month, value: -1, to: currentMonthDate) {
            currentMonthDate = newDate
        }
    }
    
    private func nextMonth() {
        if let newDate = Calendar.current.date(byAdding: .month, value: 1, to: currentMonthDate) {
            currentMonthDate = newDate
        }
    }

    
    
    private var weeklyProgressChart: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Weekly Progress")
                .font(.headline)
                .padding(.horizontal)
            
            Chart {
                ForEach(viewModel.weeklyProgress) { progress in
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.questionsCompleted)
                    )
                    .position(by: .value("Type", "Total"))
                    .foregroundStyle(.blue.opacity(0.3))
                    
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.correctAnswers)
                    )
                    .position(by: .value("Type", "Correct"))
                    .foregroundStyle(.green)
                }
            }
            .frame(height: 200)
            .padding(.horizontal, 20)
            .chartLegend(position: .top)
            .chartForegroundStyleScale([
                "Total": .blue.opacity(0.3),
                "Correct": .green
            ])
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var monthlyProgressChart: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Monthly Progress")
                .font(.headline)
                .padding(.horizontal)
            
            Chart {
                ForEach(viewModel.monthlyProgress) { progress in
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.questionsCompleted)
                    )
                    .position(by: .value("Type", "Total"))
                    .foregroundStyle(.blue.opacity(0.3))
                    
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.correctAnswers)
                    )
                    .position(by: .value("Type", "Correct"))
                    .foregroundStyle(.green)
                }
            }
            .frame(height: 200)
            .padding(.horizontal, 20)
            .chartLegend(position: .top)
            .chartForegroundStyleScale([
                "Total": .blue.opacity(0.3),
                "Correct": .green
            ])
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var yearlyProgressChart: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Yearly Progress")
                .font(.headline)
                .padding(.horizontal)
            
            Chart {
                ForEach(viewModel.yearlyProgress) { progress in
                    BarMark(
                        x: .value("Month", progress.week),
                        y: .value("Questions", progress.questionsCompleted)
                    )
                    .position(by: .value("Type", "Total"))
                    .foregroundStyle(.blue.opacity(0.3))
                    
                    BarMark(
                        x: .value("Month", progress.week),
                        y: .value("Questions", progress.correctAnswers)
                    )
                    .position(by: .value("Type", "Correct"))
                    .foregroundStyle(.green)
                }
            }
            .frame(height: 200)
            .padding(.horizontal, 20)
            .chartLegend(position: .top)
            .chartForegroundStyleScale([
                "Total": .blue.opacity(0.3),
                "Correct": .green
            ])
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var timePicker: some View {
        Picker("Time Range", selection: $selectedTimeRange) {
            ForEach(TimeRange.allCases, id: \.self) { range in
                Text(range.rawValue).tag(range)
            }
        }
        .pickerStyle(.segmented)
        .padding()
        .onChange(of: selectedTimeRange) { _ in
            let period: StatsPeriod = switch selectedTimeRange {
                case .week: .day
                case .month: .month
            }
            Task {
                await viewModel.loadStatsByPeriod(period)
            }
        }
    }
}

struct CalendarDay: Identifiable, Hashable {
    let id: Int
    let date: Date
    
    // Hashable 구현
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
    }
    
    static func == (lhs: CalendarDay, rhs: CalendarDay) -> Bool {
        return lhs.id == rhs.id && lhs.date == rhs.date
    }
}

struct MonthCalendarView: View {
    @Environment(\.colorScheme) private var colorScheme
    let month: Date
    let monthlyData: [DailyProgress]
    private let calendar = Calendar.current
    private let daysInWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    
    var body: some View {
        VStack(spacing: 15) {
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 8), count: 7), spacing: 8) {
                // 요일 헤더
                ForEach(daysInWeek, id: \.self) { day in
                    Text(day)
                        .font(.caption)
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity)
                }
                
                // 빈 셀 채우기
                ForEach(0..<firstWeekdayOfMonth, id: \.self) { _ in
                    Color.clear
                        .frame(height: 40)
                }
                
                // 날짜 그리드
                ForEach(calendarDays, id: \.id) { calendarDay in
                    if let progress = progressForDate(calendarDay.date),
                       progress.questionsCompleted > 0 {
                        DayCellView(date: calendarDay.date, progress: progress)
                    } else {
                        Text(String(calendar.component(.day, from: calendarDay.date)))
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(colorScheme == .dark ? .white : .primary)
                            .frame(maxWidth: .infinity)
                            .frame(height: 40)
                            .background(
                                RoundedRectangle(cornerRadius: 8)
                                    .fill(colorScheme == .dark ? Color(.systemGray6) : Color(.systemGray6))
                            )
                    }
                }
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 12)
        .background(colorScheme == .dark ? Color(.systemGray5) : Color(.systemBackground))
        .cornerRadius(16)
    }

    // 월의 첫 번째 날의 요일 (0 = 일요일, 6 = 토요일)
    private var firstWeekdayOfMonth: Int {
        guard let firstDay = calendar.date(from: calendar.dateComponents([.year, .month], from: month)) else {
            return 0
        }
        return calendar.component(.weekday, from: firstDay) - 1
    }
    
    private var calendarDays: [CalendarDay] {
        guard let range = calendar.range(of: .day, in: .month, for: month) else {
            return []
        }
        
        return (1...range.count).map { day -> CalendarDay in
            let components = calendar.dateComponents([.year, .month], from: month)
            var newComponents = DateComponents()
            newComponents.year = components.year
            newComponents.month = components.month
            newComponents.day = day
            let date = calendar.date(from: newComponents) ?? month
            return CalendarDay(id: day, date: date)
        }
    }
    
    private func progressForDate(_ date: Date) -> DailyProgress? {
        monthlyData.first { calendar.isDate($0.date, inSameDayAs: date) }
    }
    
    private var monthString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: month)
    }
    
    private var daysInMonth: [Date] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: month),
              let monthFirstWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.start),
              let monthLastWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.end) else {
            return []
        }
        
        let dateInterval = DateInterval(start: monthFirstWeek.start, end: monthLastWeek.end)
        return calendar.generateDates(for: dateInterval, matching: DateComponents(hour: 0))
    }
}

struct StatsCircleContainer: View {
    let todayStats: DailyProgress?
    let weeklyStats: [DailyProgress]
    let monthlyProgress: [DailyProgress]  // 추가
    let selectedTimeRange: TimeRange      // 추가
    let currentMonthDate: Date           // 추가
    
    private var monthlyStats: (total: Int, correct: Int, incorrect: Int) {
        let calendar = Calendar.current
        let currentMonth = calendar.component(.month, from: currentMonthDate)
        let currentYear = calendar.component(.year, from: currentMonthDate)
        
        let thisMonthProgress = monthlyProgress.filter { progress in
            let progressMonth = calendar.component(.month, from: progress.date)
            let progressYear = calendar.component(.year, from: progress.date)
            return progressMonth == currentMonth && progressYear == currentYear
        }
        
        let total = thisMonthProgress.reduce(0) { $0 + $1.questionsCompleted }
        let correct = thisMonthProgress.reduce(0) { $0 + $1.correctAnswers }
        return (total, correct, total - correct)
    }
    
    var body: some View {
        HStack {
            CircleProgressView(
                progress: Double(todayStats?.correctAnswers ?? 0) / Double(max(1, todayStats?.questionsCompleted ?? 1)),
                title: "Today's Accuracy",
                total: todayStats?.questionsCompleted ?? 0,
                correct: todayStats?.correctAnswers ?? 0,
                incorrect: (todayStats?.questionsCompleted ?? 0) - (todayStats?.correctAnswers ?? 0)
            )
            
            Spacer(minLength: 30)
            
            if selectedTimeRange == .month {
                // 월별 통계
                CircleProgressView(
                    progress: monthlyStats.total > 0 ? Double(monthlyStats.correct) / Double(monthlyStats.total) : 0,
                    title: "Monthly Accuracy",
                    total: monthlyStats.total,
                    correct: monthlyStats.correct,
                    incorrect: monthlyStats.incorrect
                )
            } else {
                // 주간 통계
                CircleProgressView(
                    progress: calculateWeeklyProgress(),
                    title: "Weekly Accuracy",
                    total: calculateWeeklyTotal(),
                    correct: calculateWeeklyCorrect(),
                    incorrect: calculateWeeklyIncorrect()
                )
            }
        }
        .padding(.top)
    }
    
    private func calculateWeeklyProgress() -> Double {
        let total = weeklyStats.reduce(0) { $0 + $1.questionsCompleted }
        let correct = weeklyStats.reduce(0) { $0 + $1.correctAnswers }
        return total > 0 ? Double(correct) / Double(total) : 0
    }
    
    private func calculateWeeklyTotal() -> Int {
        weeklyStats.reduce(0) { $0 + $1.questionsCompleted }
    }
    
    private func calculateWeeklyCorrect() -> Int {
        weeklyStats.reduce(0) { $0 + $1.correctAnswers }
    }
    
    private func calculateWeeklyIncorrect() -> Int {
        let total = calculateWeeklyTotal()
        let correct = calculateWeeklyCorrect()
        return total - correct
    }
}

struct CircleProgressView: View {
    let progress: Double
    let title: String
    let total: Int
    let correct: Int
    let incorrect: Int
    
    var body: some View {
        VStack {
            ZStack {
                Circle()
                    .stroke(lineWidth: 20)
                    .opacity(0.3)
                    .foregroundColor(.blue)
                
                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(style: StrokeStyle(lineWidth: 25, lineCap: .round))
                    .foregroundColor(.green)
                    .rotationEffect(.degrees(-90))
                    .animation(.linear, value: progress)
                
                VStack {
                    Text("\(Int(progress * 100))%")
                        .font(.headline)
                        .bold()
                    Text(title)
                        .font(.caption2)
                }
            }
            .frame(width: 150, height: 150)
            
            VStack(alignment: .leading, spacing: 8) {
                VStack {
                    Text("Correct: \(correct)")
                        .font(.subheadline)
                        .foregroundColor(.green)
                }
                
                VStack {
                    Text("Incorrect: \(incorrect)")
                        .font(.subheadline)
                        .foregroundColor(.red)
                }
                
                VStack {
                    Text("Total: \(total)")
                        .font(.subheadline)
                }
            }
            .padding(.top)
        }
        .padding()
    }
}

struct ActivityRow: View {
   let title: String
   let value: String
   let icon: String
   let color: Color
   
    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(color)
                .font(.title2)
                .frame(width: 30)
            
            VStack(alignment: .leading) {
                Text(title)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text(value)
                    .font(.headline)
            }
            
            Spacer()
        }
    }
}

struct DailyStatCard: View {
    let title: String
    let value: String
    let trend: String
    let trendUp: Bool
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            Text(value)
                .font(.title2)
                .bold()
            
            if !trend.isEmpty {
                HStack(spacing: 4) {
                    Image(systemName: trendUp ? "arrow.up.right" : "arrow.down.right")
                    Text(trend)
                }
                .font(.caption)
                .foregroundColor(trendUp ? .green : .red)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}
struct DayCellView: View {
    @Environment(\.colorScheme) private var colorScheme
    let date: Date
    let progress: DailyProgress
    
    private var activityColor: Color {
        let questionCount = progress.questionsCompleted
        guard questionCount > 0 else { return colorScheme == .dark ? Color(.systemGray6) : Color(.systemGray6) }
        return Color.green
    }
    
    private var textColor: Color {
        colorScheme == .dark ? .white : .primary
    }
    
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 8)
                .fill(activityColor)
                .frame(maxWidth: .infinity)
                .frame(height: 40)
            
            VStack(spacing: 2) {
                Text("\(Calendar.current.component(.day, from: date))")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.white)
                Text("\(progress.questionsCompleted)")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.white)
            }
        }
    }
}

extension Calendar {
    func generateDates(
        for dateInterval: DateInterval,
        matching components: DateComponents
    ) -> [Date] {
        var dates: [Date] = []
        dates.reserveCapacity(40)

        var date = dateInterval.start
        repeat {
            dates.append(date)
            guard let nextDate = self.nextDate(after: date, matching: components, matchingPolicy: .nextTime) else {
                break
            }
            date = nextDate
        } while date <= dateInterval.end

        return dates
    }
}


// ./AISnapStudy/Views/Stats/StreakBadgeView.swift

import SwiftUI

struct StreakBadgeView: View {
    let streakInfo: StreakInfo
    
    private var streakMessage: String {
        switch streakInfo.currentStreak {
        case 2: return "2 Days! Keep going! 🎯"
        case 3: return "3 Days! You're on fire! 🔥"
        case 4: return "4 Days! Fantastic! ⭐️"
        case 5: return "5 Days! Incredible! 🌟"
        case 6: return "6 Days! Amazing! 🏆"
        case 7...: return "7+ Days! Legendary! 👑"
        default: return "Start your streak today! 💫"
        }
    }
    
    var body: some View {
        VStack(spacing: 12) {
            Text("\(streakInfo.currentStreak)")
                .font(.system(size: 48, weight: .bold))
                .foregroundColor(.orange)
            
            Text("Day Streak")
                .font(.headline)
                .foregroundColor(.secondary)
            
            Text(streakMessage)
                .font(.subheadline)
                .multilineTextAlignment(.center)
                .foregroundColor(.primary)
            
            if streakInfo.longestStreak > streakInfo.currentStreak {
                Text("Longest streak: \(streakInfo.longestStreak) days")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 15)
                .fill(Color(.systemBackground))
                .shadow(radius: 2)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 15)
                .stroke(Color.orange.opacity(0.3), lineWidth: 2)
        )
    }
}


// ./AISnapStudy/Views/Stats/DetailedStatsView.swift

import SwiftUI
import Charts

struct DetailedStatsView: View {
    @StateObject private var viewModel = DetailedStatsViewModel()
    @State private var selectedMonth = Date()
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Streak Badge Section
                StreakBadgeView(streakInfo: viewModel.streakInfo)
                    .padding()
                
                // Calendar View
                CalendarStatsView(monthlyData: viewModel.monthlyData)
                .padding()
                
                // Stats Summary
                StatsSummaryView(dailyStats: viewModel.dailyStats)
                    .padding()
                
                // Progress Chart
                ProgressChartView(dailyStats: viewModel.dailyStats)
                    .frame(height: 250)
                    .padding()
            }
        }
        .navigationTitle("Detailed Stats")
    }
}

struct StatsSummaryView: View {
    let dailyStats: [DailyStats]
    
    private var totalQuestions: Int {
        dailyStats.reduce(0) { $0 + $1.totalQuestions }
    }
    
    private var totalCorrect: Int {
        dailyStats.reduce(0) { $0 + $1.correctAnswers }
    }
    
    private var averageAccuracy: Double {
        guard totalQuestions > 0 else { return 0 }
        return Double(totalCorrect) / Double(totalQuestions) * 100
    }
    
    var body: some View {
        VStack(spacing: 16) {
            Text("Summary")
                .font(.headline)
            
            HStack(spacing: 20) {
                StatCard(
                    title: "Total",
                    value: "\(totalQuestions)",
                    icon: "list.bullet",
                    color: .blue
                )
                
                StatCard(
                    title: "Correct",
                    value: "\(totalCorrect)",
                    icon: "checkmark",
                    color: .green
                )
                
                StatCard(
                    title: "Accuracy",
                    value: String(format: "%.1f%%", averageAccuracy),
                    icon: "percent",
                    color: .orange
                )
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

struct ProgressChartView: View {
    let dailyStats: [DailyStats]
    
    var body: some View {
        Chart {
            ForEach(dailyStats) { stats in
                BarMark(
                    x: .value("Date", stats.date),
                    y: .value("Questions", stats.totalQuestions)
                )
                .foregroundStyle(by: .value("Type", "Total"))
                
                BarMark(
                    x: .value("Date", stats.date),
                    y: .value("Questions", stats.correctAnswers)
                )
                .foregroundStyle(by: .value("Type", "Correct"))
            }
        }
        .chartForegroundStyleScale([
            "Total": Color.blue.opacity(0.3),
            "Correct": Color.green
        ])
        .chartLegend(position: .top)
    }
}


// ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 512 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.8
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // 이미지의 크기를 최대 치수에 맞게 조정
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // 설정된 품질로 압축
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // 크기가 최대 파일 크기를 초과하는 경우, 품질을 낮춰서 추가 압축 시도
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera),
                  UIImagePickerController.isCameraDeviceAvailable(.rear) else {
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetail의 설정 값을 사용
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // 예측 토큰 수 계산
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        📊 Image Optimization Results:
        • Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        • Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        • Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        • Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        • Estimated Tokens: \(estimatedTokens)
        • Processing Time: \(String(format: "%.3f", processingTime))s
        • Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}



// ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
    case fileProviderAccessDenied
    case fileCoordinationFailed
}

public class StorageService {
    // MARK: - Properties
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let fileCoordinator = NSFileCoordinator()
    private let fileManager = FileManager.default
    
    // MARK: - Constants
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    private let maxRetryCount = 3
    private let retryDelay: TimeInterval = 0.5
    
    // MARK: - File System
    private var documentDirectory: URL? {
        fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
    }
    
    private func getDirectoryURL(for type: String) -> URL? {
        documentDirectory?.appendingPathComponent(type)
    }
    
    // MARK: - FileProvider Handling
    private func handleFileProviderAccess<T>(_ operation: @escaping (URL) throws -> T) throws -> T {
        guard checkFileProviderAuthorization() else {
            throw StorageError.fileProviderAccessDenied
        }
        
        guard let url = documentDirectory else {
            throw StorageError.invalidData
        }
        
        var coordinationError: NSError?
        var result: T?
        var operationError: Error?
        
        fileCoordinator.coordinate(writingItemAt: url, options: .forMoving, error: &coordinationError) { coordinatedURL in
            do {
                result = try operation(coordinatedURL)
            } catch {
                operationError = error
            }
        }
        
        if let error = coordinationError {
            throw StorageError.fileCoordinationFailed
        }
        
        if let error = operationError {
            throw error
        }
        
        return result!
    }
    
    private func checkFileProviderAuthorization() -> Bool {
        // 실제 환경에서는 적절한 권한 체크 로직 구현
        return true
    }
    
    // MARK: - Error Handling
    private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
        do {
            return try operation()
        } catch let error as NSError {
            Logger.logError(error, category: "FileOperation")
            
            // 재시도 로직
            for attempt in 1...maxRetryCount {
                Logger.log("Retrying operation (attempt \(attempt)/\(maxRetryCount))", category: "FileOperation")
                do {
                    return try operation()
                } catch {
                    if attempt == maxRetryCount {
                        throw error
                    }
                    Thread.sleep(forTimeInterval: retryDelay)
                }
            }
            throw error
        }
    }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var problemSets = try self.getProblemSets()
                problemSets.append(problemSet)
                
                let data = try self.encoder.encode(problemSets)
                self.defaults.set(data, forKey: self.problemSetsKey)
            }
        }
    }
    
    public func getProblemSets() throws -> [ProblemSet] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: problemSetsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([ProblemSet].self, from: data)
            } catch {
                Logger.logError(error, category: "ProblemSets")
                throw StorageError.loadFailed
            }
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                sessions.append(session)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: studySessionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([StudySession].self, from: data)
            } catch {
                Logger.logError(error, category: "StudySessions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.deleteFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                
                guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
                    throw StorageError.notFound
                }
                
                sessions.remove(at: index)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func saveQuestion(_ question: Question) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var savedQuestions = try self.getSavedQuestions()
                savedQuestions.append(question)
                
                let data = try self.encoder.encode(savedQuestions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: savedQuestionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([Question].self, from: data)
            } catch {
                Logger.logError(error, category: "SavedQuestions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func saveQuestions(_ questions: [Question]) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                let data = try self.encoder.encode(questions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("📝 [\(category)] \(message)")
        #endif
    }
    
    static func logError(_ error: Error, category: String) {
        #if DEBUG
        print("❌ [\(category)] Error: \(error.localizedDescription)")
        #endif
    }
}


// ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    // private 저장 프로퍼티 수정
    private var apiKey: String?
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    private let keyServerURL = "https://aistockadvisor.net/api/get-api-key"
    
    // 싱글톤 수정
    static let shared = OpenAIService()
    
    // 단일 초기화 메서드
    private init() {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
        
        // 초기화 시점에 API Key 가져오기
        Task {
            try? await fetchAPIKey()
        }
    }
    
    private func makeOpenAIRequest(_ request: inout URLRequest) throws {
        guard let apiKey = self.apiKey else {
            print("❌ API key is nil")
            throw NetworkError.apiError("API key not available")
        }
        
        
        // String 리터럴로 헤더 생성
        let authHeaderValue = "Bearer " + apiKey
        request.setValue(authHeaderValue, forHTTPHeaderField: "Authorization")
    
    }

    
    // fetchAPIKey 함수 수정
    func fetchAPIKey() async throws {
        let request = URLRequest(url: URL(string: keyServerURL)!)
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.invalidResponse
        }
        
        let decoder = JSONDecoder()
        let keyResponse = try decoder.decode(APIKeyResponse.self, from: data)
        
        // API 키 저장 전 확인
        print("Debug - Received API Key (first 10 chars):", keyResponse.apiKey.prefix(10))
        
        // API 키 저장
        self.apiKey = keyResponse.apiKey
    }
    
    // API Key가 없을 경우 가져오는 메서드
    private func ensureValidAPIKey() async throws {
        if apiKey == nil {
            try await fetchAPIKey()
        }
    }
    
    func cleanup() {
           apiKey = nil
       }
    
    func sendTextExtractionResult(_ extractedText: String) async throws -> String {
        // API Key 확인
        try await ensureValidAPIKey()
        
        print("🔄 Processing extracted text in OpenAI service...")
        print("📝 Input text: \(extractedText)")
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        
        try makeOpenAIRequest(&request)  // API Key 설정

        let body: [String: Any] = [
            "model": "gpt-4o",
            "messages": [
                ["role": "system", "content": "You are an expert at analyzing extracted text."],
                ["role": "user", "content": extractedText]
            ],
            "temperature": 0.7,
            "max_tokens": 2000
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        print("🌐 Sending request to OpenAI API...")
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("❌ Invalid response received")
            throw NetworkError.invalidResponse
        }
        
        print("📡 Response status code: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            print("❌ API request failed with status code: \(httpResponse.statusCode)")
            throw NetworkError.apiError("API request failed with status \(httpResponse.statusCode)")
        }

        let result = String(data: data, encoding: .utf8) ?? "No response"
        print("✅ OpenAI processing completed: \(result)")
        return result
    }


        func sendImageDataToOpenAI(_ imageData: Data) async throws {
            // API Key 확인
            try await ensureValidAPIKey()
            
            let url = URL(string: "https://api.openai.com/v1/images")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("Bearer \(apiKey ?? "")", forHTTPHeaderField: "Authorization")

            let body: [String: Any] = [
                "image": imageData.base64EncodedString(),
                "purpose": "image-analysis"
            ]

            request.httpBody = try JSONSerialization.data(withJSONObject: body, options: [])

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw NSError(domain: "OpenAIService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to get valid response from OpenAI API"])
            }

            let result = String(data: data, encoding: .utf8) ?? "No response"
            print("✅ Image sent to OpenAI. Response: \(result)")
        }
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public 으로 변경
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init 추가
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public 으로 변경
        let subject: DefaultSubject  // Subject -> DefaultSubject로 변경
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        let language: Language
        
        public init(    // public init 추가
            subject: DefaultSubject,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int],
            language: Language
        ) {
            self.subject = subject
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
            self.language = language
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("❌ Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("📸 Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("❌ Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }

    // extractCompleteQuestion 함수도 추가
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSON이 완전한 객체인지 확인
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSON이 아직 완성되지 않았거나 파싱할 수 없는 경우
            return nil
        }
    }
    
    // 나머지 private 구조체들은 그대로 유지
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        // 네트워크 연결 확인
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        // 캐시 확인
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("✅ Retrieved questions from cache")
            return cachedQuestions
        }
        
        // API 키 확인 및 로깅
        guard let apiKey = self.apiKey else {
            print("❌ API key is nil")
            throw NetworkError.apiError("API key not available")
        }
        print("Debug - API Key type:", type(of: apiKey))
        print("Debug - API Key length:", apiKey.count)
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // 이미지 또는 텍스트를 처리하는 태스크 추가
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            // API 키를 명시적으로 전달
            let questions = try await self.performQuestionGeneration(
                input: processedInput,
                textInput: processedTextInput,
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters,
                apiKey: apiKey  // API 키 전달
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(
        _ subject: SubjectType,
        isImageInput: Bool,
        isExtractedText: Bool,  // 새로운 매개변수 추가
        educationLevel: EducationLevel,
        language: Language
    ) -> SubjectPrompt {
        let subjectName = if let customSubject = subject as? CustomSubject {  // 수정된 부분
            customSubject.displayName
        } else {
            subject.displayName
        }
        
        let languageInstructionText = language == .auto ?
            "Generate questions in the exact same language as the input text." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.codeName).
            DO NOT use the input text's language. Even if the input is in another language, the output must be in \(language.codeName) only.
            """
        
        let languageInstructionImage = language == .auto ?
            "Generate questions in the same language as any visible text in the image." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.codeName).
            DO NOT use the language of visible text in the image. All output must be in \(language.codeName) only.
            """

        // 순수 이미지 기반 입력
        if isImageInput && !isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained, image-based questions.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as visible text in the image" : language.codeName)
                    - Ensure consistent language usage throughout all content.
                    - Translate concepts accurately without losing meaning.
                    
                    FORMATTING REQUIREMENTS:
                    - Each question must be self-contained with all necessary context provided.
                    - Avoid ambiguous or overly broad questions.
                    - True/False answers must be "true" or "false" (lowercase).

                    ERROR PREVENTION:
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Create high-quality, context-rich questions based on the given image.
                    \(languageInstructionImage)
                    Each question must include detailed explanations and hints.

                    Examples of good questions:
                    - "If the sum of the angles in a triangle is 180°, and one angle is 90°, what are the other two angles?"
                    - "The Roman Empire declined for many reasons. Which of the following factors contributed the most to its fall?"
                    
                    Examples of bad questions:
                    - "What does the text explain?"
                    - "Is this image interesting?"
                    """
            )
        }
        // 이미지에서 추출된 텍스트 기반 입력
        else if isImageInput && isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained questions based on extracted text from images.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as the extracted text" : language.codeName)
                    - Maintain consistent language usage across all questions, answers, and explanations.
                    - Preserve technical terms and proper nouns during translation.

                    FORMATTING REQUIREMENTS:
                    - Create questions with all necessary context included.
                    - True/False answers must be "true" or "false" (lowercase).
                    - Avoid "wh-" questions like "what", "who", or "how".

                    ERROR PREVENTION:
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Generate accurate and context-aware questions from the extracted text in the image.
                    \(languageInstructionImage)
                    Include hints and explanations for each question.

                    Examples of good questions:
                    - "The fall of the Roman Empire is often attributed to external invasions. Which of the following best explains this?"
                    - "In the Pythagorean theorem, if a² + b² = c², what does 'c' represent in a right triangle?"

                    Examples of bad questions:
                    - "What does this text mean?"
                    - "Explain the context."
                    """
            )
        }
        // 텍스트 기반 입력
        else {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating questions for \(educationLevel.displayName) students.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as input text" : language.codeName)
                    - Maintain consistent language usage across all questions, answers, and explanations.
                    - Preserve technical terms and proper nouns during translation.
                    
                    FORMATTING REQUIREMENTS:
                    - Include all necessary context within the questions.
                    - Avoid overly broad or simplistic questions.
                    - True/False answers must be "true" or "false" (lowercase).

                    ERROR PREVENTION:
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Create thoughtful and context-rich questions based on the input text.
                    \(languageInstructionText)
                    Create National Assessment of Educational Progress questions for \(educationLevel.displayName) school students
                    Include hints and detailed explanations.

                    Examples of good questions:
                    - "The Renaissance was a cultural movement in Europe. Which of the following innovations was NOT developed during this period?"
                    - "If a car travels 60 miles in one hour, how far will it travel in three hours at the same speed?"

                    Examples of bad questions:
                    - "What is the capital of France?"
                    - "Explain this text."
                    """
            )
        }
    }

    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            isExtractedText: !input.isImage && input.content.count > 0,  // 텍스트 추출 여부 확인
            educationLevel: parameters.educationLevel,
            language: parameters.language
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": [
                                "type": "array",
                                "items": [
                                    "type": "string"
                                ],
                                "description": "For true_false type, must be exactly ['true', 'false']"
                            ],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint"]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters,
        apiKey: String  // API 키 매개변수 추가
    ) async throws -> [Question] {
        print("🤖 OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages 배열을 미리 선언
        var messages: [[String: Any]]

        // 구조화된 메시지 생성
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI 공식 멀티모달 포맷 사용
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        
        // API 키를 직접 사용하여 Authorization 헤더 설정
        let authHeaderValue = "Bearer " + apiKey
        request.setValue(authHeaderValue, forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        // Debug: 헤더 확인
        print("Debug - Final Authorization header:", String(authHeaderValue.prefix(20)), "...")
        
        print("""
        🌐 API Request:
        • URL: \(baseURL)
        • Method: POST
        • Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            🌐 API Response:
            • Status Code: \(httpResponse.statusCode)
            • Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            // True/False 질문에서 접두사 제거
            let processedQuestion = questionData.type == "true_false" ?
                questionData.question
                    .replacingOccurrences(
                        of: "^(True or False:|True/False:|T/F:|\\(True/False\\)|\\[True/False\\]|True or False\\?|Is it true or false:|True False:)\\s*",
                        with: "",
                        options: [.regularExpression, .caseInsensitive]
                    )
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines) :
                questionData.question
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines)

            // True/False 답변 정규화
            var correctAnswer = questionData.correctAnswer
            if questionData.type == "true_false" {
                correctAnswer = correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
                if ["yes", "네", "true", "correct", "that's right", "맞습니다", "네, 그렇습니다", "사실입니다"].contains(correctAnswer) {
                    correctAnswer = "true"
                } else if ["no", "아니오", "false", "incorrect", "that's wrong", "아닙니다", "아니요", "사실이 아니다", "사실이 아닙니다"].contains(correctAnswer) {
                    correctAnswer = "false"
                }
            }

            return Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                question: processedQuestion,
                options: questionData.options,
                correctAnswer: correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        ✅ Questions Generated:
        • Count: \(questions.count)
        • Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


struct APIKeyResponse: Codable {
    let apiKey: String
    
    // CodingKeys 추가
    enum CodingKeys: String, CodingKey {
        case apiKey = "apiKey"
    }
}



// ./AISnapStudy/Services/VisionService.swift

// Services/VisionService.swift

import Vision
import UIKit

// Vision 관련 에러 타입 정의
enum VisionError: Error {
    case invalidImage
    case processingFailed
    case noTextFound
    case unknown(Error)
}

class VisionService {
    static let shared = VisionService()
    
    private init() {}
    
    func extractText(from image: UIImage) async throws -> String {
        print("🔍 Starting universal text extraction...")
        
        guard let cgImage = image.cgImage else {
            print("❌ Failed to get CGImage from UIImage")
            throw VisionError.invalidImage
        }

        let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        let request = VNRecognizeTextRequest()
        
        // Universal text recognition settings
        request.recognitionLevel = .accurate
        request.usesLanguageCorrection = true
        request.automaticallyDetectsLanguage = true // Enable automatic language detection
        
        print("📝 Configured for universal text recognition")
        
        do {
            try requestHandler.perform([request])
            
            let observations = request.results ?? []
            print("📊 Found \(observations.count) text observations")
            
            var textBlocks: [(text: String, location: CGRect)] = []
            
            for observation in observations {
                if let candidate = observation.topCandidates(1).first {
                    let text = candidate.string
                    let confidence = candidate.confidence
                    
                    if confidence > 0.2 {
                        textBlocks.append((text, observation.boundingBox))
                    }
                }
            }
            
            let finalText = processTextBlocks(textBlocks)
            
            guard !finalText.isEmpty else {
                print("⚠️ No valid text extracted")
                throw VisionError.noTextFound
            }
            
            print("✅ Successfully extracted text")
            return finalText
            
        } catch {
            print("❌ Text extraction failed: \(error.localizedDescription)")
            throw VisionError.processingFailed
        }
    }
    
    private func processTextBlocks(_ blocks: [(text: String, location: CGRect)]) -> String {
        // Sort blocks by their position on the page
        let sortedBlocks = blocks.sorted { (block1, block2) -> Bool in
            // Different lines (threshold for line height difference)
            if abs(block1.location.minY - block2.location.minY) > 0.05 {
                return block1.location.minY > block2.location.minY
            }
            // Same line - left to right
            return block1.location.minX < block2.location.minX
        }
        
        // Process and join text blocks
        let processedText = sortedBlocks
            .map { block in
                var text = block.text
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Fix common punctuation issues
                text = text.replacingOccurrences(of: "\\s*([.,!?])\\s*", with: "$1 ", options: .regularExpression)
                text = text.replacingOccurrences(of: "([.,!?])\\1+", with: "$1", options: .regularExpression)
                
                return text
            }
            .joined(separator: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        return processedText
    }
}


// ./AISnapStudy/Services/RemoteQuestionService.swift

import Foundation
import Combine
import SwiftUI

class RemoteQuestionService {
    static let shared = RemoteQuestionService()
    private let baseURL = "https://aistockadvisor.net"
    private let cache = NSCache<NSString, NSArray>()
    
    func fetchFeaturedSets() async throws -> [RemoteQuestionSet] {
        let url = URL(string: "\(baseURL)/featured-sets")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode([RemoteQuestionSet].self, from: data)
    }
    
    func fetchQuestionSet(_ id: String) async throws -> ProblemSet {
        print("🌐 Downloading question set with ID: \(id)")
        let url = URL(string: "\(baseURL)/api/question-sets/\(id)")!
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("📡 Response status: \(httpResponse.statusCode)")
        
        struct RemoteSet: Codable {
            let id: String
            let subject: String
            let subjectType: String
            let subjectId: String
            let subjectName: String
            let questions: [RemoteQuestion]
            let createdAt: String
            let educationLevel: String
            let name: String
            
            struct RemoteQuestion: Codable {
                let id: String
                let type: String
                let question: String
                let options: [String]
                let correctAnswer: String
                let explanation: String
                let hint: String
            }
        }
        
        let decoder = JSONDecoder()
        let remoteSet = try decoder.decode(RemoteSet.self, from: data)
        
        // Question 모델로 변환
        let questions = remoteSet.questions.map { q -> Question in
            let questionType: QuestionType = {
                switch q.type.lowercased() {
                    case "multiple_choice":
                        return .multipleChoice
                    case "true_false":
                        return .trueFalse
                    default:
                        return .multipleChoice  // 기본값
                }
            }()
            
            return Question(
                id: q.id,
                type: questionType,
                subject: DefaultSubject.download,  // DefaultSubject 타입으로 변경
                question: q.question,
                options: q.options,
                correctAnswer: q.correctAnswer,
                explanation: q.explanation,
                hint: q.hint,
                isSaved: false,
                createdAt: Date()
            )
        }
        
        // ProblemSet으로 변환
        return ProblemSet(
            id: UUID().uuidString,
            subject: DefaultSubject.download,
            subjectType: "default",
            subjectId: DefaultSubject.download.rawValue,
            subjectName: "Downloaded Sets",
            questions: questions,
            createdAt: ISO8601DateFormatter().date(from: remoteSet.createdAt) ?? Date(),
            educationLevel: EducationLevel(rawValue: remoteSet.educationLevel) ?? .elementary,
            name: remoteSet.name
        )
    }
    
    func searchQuestionSets(query: String) async throws -> [RemoteQuestionSet] {
        let url = URL(string: "\(baseURL)/search?q=\(query)")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode([RemoteQuestionSet].self, from: data)
    }
    
    func fetchQuestionSets() async throws -> [RemoteQuestionSet] {
        print("🌐 Fetching remote question sets...")
        let url = URL(string: "\(baseURL)/api/question-sets")!
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("📡 Response status: \(httpResponse.statusCode)")
        
        // 받은 JSON 데이터 출력
        if let jsonString = String(data: data, encoding: .utf8) {
            print("📥 Received JSON data: \(jsonString)")
        }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601  // ISO8601 형식의 날짜 처리
        
        do {
            let sets = try decoder.decode([RemoteQuestionSet].self, from: data)
            print("✅ Fetched \(sets.count) remote sets")
            return sets
        } catch {
            print("🔴 Decoding error: \(error)")
            throw error
        }
    }

}

// MARK: - ViewModels
class QuestionStoreViewModel: ObservableObject {
    @Published var featuredSets: [RemoteQuestionSet] = []
    @Published var popularSets: [RemoteQuestionSet] = []
    @Published var recentSets: [RemoteQuestionSet] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var searchResults: [RemoteQuestionSet] = []
    @Published var searchQuery = ""
    
    private let remoteService = RemoteQuestionService.shared
    private let homeViewModel: HomeViewModel
    
    init(homeViewModel: HomeViewModel) {
        self.homeViewModel = homeViewModel
    }
    
    @MainActor
    func loadFeaturedSets() async {
        isLoading = true
        do {
            featuredSets = try await remoteService.fetchFeaturedSets()
        } catch {
            self.error = error
        }
        isLoading = false
    }
    
    @MainActor
    func downloadQuestionSet(_ set: RemoteQuestionSet) async {
        isLoading = true
        do {
            let problemSet = try await remoteService.fetchQuestionSet(set.id)
            // Convert to Download subject
            let downloadedSet = ProblemSet(
                subject: DefaultSubject.download,  // New Download subject
                subjectType: "default",
                subjectId: DefaultSubject.download.rawValue,
                subjectName: "Download",
                questions: problemSet.questions,
                createdAt: Date(),
                educationLevel: .high,  // Or determine from set.difficulty
                name: set.title
            )
            await homeViewModel.saveProblemSet(downloadedSet)
        } catch {
            self.error = error
        }
        isLoading = false
    }
}

// MARK: - Views
struct QuestionStoreView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var selectedCategory: String?
    @State private var showingSearch = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                if homeViewModel.isLoadingRemote {
                    ProgressView("Loading question sets...")
                } else {
                    ForEach(homeViewModel.remoteSets) { remoteSet in
                        QuestionSetCard(
                            set: remoteSet,
                            onDownload: {
                                Task {
                                    await homeViewModel.downloadQuestionSet(remoteSet)
                                }
                            }
                        )
                    }
                }
            }
            .padding()
        }
        .navigationTitle("Question Store")
    }
}

struct QuestionSetCard: View {
   let set: RemoteQuestionSet
   let onDownload: () -> Void
   @Environment(\.colorScheme) private var colorScheme
   
   var body: some View {
       VStack(alignment: .leading, spacing: 16) {
           // 상단 영역
           HStack(alignment: .top) {
               // 아이콘
               Image(systemName: "book.fill")
                   .font(.system(size: 24))
                   .foregroundColor(.blue)
                   .frame(width: 40, height: 40)
                   .background(Color.blue.opacity(0.1))
                   .clipShape(Circle())
               
               VStack(alignment: .leading, spacing: 4) {
                   Text(set.title)
                       .font(.system(size: 18, weight: .semibold))
                       .foregroundColor(.primary)
                   
                   Text(set.description)
                       .font(.subheadline)
                       .foregroundColor(.secondary)
                       .lineLimit(2)
               }
           }
           
           Divider()
           
           // 하단 정보 영역
           HStack(spacing: 16) {
               // 문제 수
               HStack(spacing: 6) {
                   Image(systemName: "doc.text.fill")
                       .foregroundColor(.blue)
                   Text("\(set.questionCount) Questions")
                       .font(.system(size: 14, weight: .medium))
               }
               .foregroundColor(.secondary)
               
               // 난이도
               HStack(spacing: 6) {
                   Image(systemName: "chart.bar.fill")
                       .foregroundColor(.green)
                   Text(set.difficulty)
                       .font(.system(size: 14, weight: .medium))
               }
               .foregroundColor(.secondary)
               
               Spacer()
               
               // 다운로드 버튼
               Button(action: onDownload) {
                   HStack(spacing: 6) {
                       Image(systemName: "arrow.down.circle.fill")
                       Text("Download")
                   }
                   .font(.system(size: 14, weight: .medium))
                   .foregroundColor(.white)
                   .padding(.horizontal, 16)
                   .padding(.vertical, 8)
                   .background(Color.blue)
                   .cornerRadius(20)
               }
           }
       }
       .padding(16)
       .background(colorScheme == .dark ? Color(.systemGray6) : Color.white)
       .cornerRadius(16)
       .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 4)
       .overlay(
           RoundedRectangle(cornerRadius: 16)
               .stroke(Color.gray.opacity(0.1), lineWidth: 1)
       )
       .padding(.horizontal)
   }
}

// Featured Section with carousel
struct FeaturedSection: View {
    let sets: [RemoteQuestionSet]
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Featured")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.horizontal)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 15) {
                    ForEach(sets) { set in
                        FeaturedCard(set: set, onDownload: onDownload)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
}

// Featured Card
struct FeaturedCard: View {
    let set: RemoteQuestionSet
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        VStack(alignment: .leading) {
            
            // Content
            VStack(alignment: .leading, spacing: 8) {
                Text(set.title)
                    .font(.headline)
                
                Text(set.description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .lineLimit(2)
                
                HStack {
                    Label("\(set.questionCount) questions", systemImage: "doc.text")
                    Spacer()
                    Button(action: { onDownload(set) }) {
                        Image(systemName: "arrow.down.circle.fill")
                            .imageScale(.large)
                    }
                }
                .font(.caption)
            }
            .padding()
        }
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 5)
        .frame(width: 280)
    }
}

// Category Section
struct CategorySection: View {
    let categories = ["Math", "Science", "Language", "History", "Geography", "General"]
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Categories")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.horizontal)
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 15) {
                ForEach(categories, id: \.self) { category in
                    CategoryCard(category: category)
                }
            }
        }
    }
}

// Category Card
struct CategoryCard: View {
    let category: String
    
    var body: some View {
        VStack {
            Image(systemName: iconName(for: category))
                .font(.title)
                .foregroundColor(.blue)
            Text(category)
                .font(.caption)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
    
    private func iconName(for category: String) -> String {
        switch category.lowercased() {
        case "math": return "function"
        case "science": return "flask.fill"
        case "language": return "textformat"
        case "history": return "clock.fill"
        case "geography": return "globe"
        default: return "book.fill"
        }
    }
}

// Question Set Section
struct QuestionSetSection: View {
    let title: String
    let sets: [RemoteQuestionSet]
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        VStack(alignment: .leading) {
            Text(title)
                .font(.title2)
                .fontWeight(.bold)
                .padding(.horizontal)
            
            ForEach(sets) { set in
                QuestionSetRow(set: set, onDownload: onDownload)
            }
        }
    }
}

// Question Set Row
struct QuestionSetRow: View {
    let set: RemoteQuestionSet
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        HStack {
            
            VStack(alignment: .leading) {
                Text(set.title)
                    .font(.headline)
                Text("\(set.questionCount) questions")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Button(action: { onDownload(set) }) {
                Image(systemName: set.isDownloaded ? "checkmark.circle.fill" : "arrow.down.circle")
                    .imageScale(.large)
                    .foregroundColor(set.isDownloaded ? .green : .blue)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

extension RemoteQuestionService {
    private func handleNetworkError(_ error: Error) {
        if let urlError = error as? URLError {
            switch urlError.code {
            case .notConnectedToInternet:
                print("❌ No internet connection")
            case .timedOut:
                print("❌ Request timed out")
            case .cannotFindHost:
                print("❌ Cannot find host: \(urlError.failingURL?.host ?? "unknown")")
            default:
                print("❌ Network error: \(urlError.localizedDescription)")
            }
        } else {
            print("❌ Unknown error: \(error.localizedDescription)")
        }
    }
}


// ./AISnapStudy/Services/StoreService.swift

import StoreKit

@MainActor
class StoreService: ObservableObject {
    static let shared = StoreService()
    
    @Published private(set) var products: [Product] = []
    @Published private(set) var purchasedProducts: [Product] = []
    @Published private(set) var subscriptionStatus: UserSubscriptionStatus
    
    private let productIds: Set<String> = Set(PurchaseProduct.allCases.map { $0.id })
    private let defaults = UserDefaults.standard
    private let subscriptionStatusKey = "userSubscriptionStatus"
    private let lastResetDateKey = "lastResetDate"
    private var resetTimer: Timer?
    
    private init() {
        // 저장된 구독 상태 불러오기
        if let savedData = defaults.data(forKey: subscriptionStatusKey),
           let savedStatus = try? JSONDecoder().decode(UserSubscriptionStatus.self, from: savedData) {
            self.subscriptionStatus = savedStatus
        } else {
            self.subscriptionStatus = UserSubscriptionStatus.defaultStatus
        }
        
        // 초기화 시 상태 확인 및 리셋
        checkAndResetDailyQuestions()
        
        Task {
            await loadProducts()
            await updatePurchasedProducts()
            await checkSubscriptionStatus()
        }
        
        setupDailyReset()
    }
    
    deinit {
        resetTimer?.invalidate()
    }
    
    private func setupDailyReset() {
        let calendar = Calendar.current
        let now = Date()
        guard let tomorrow = calendar.date(byAdding: .day, value: 1, to: now),
              let nextMidnight = calendar.date(bySettingHour: 0, minute: 0, second: 0, of: tomorrow) else {
            return
        }
        
        resetTimer?.invalidate()
        resetTimer = Timer(fire: nextMidnight, interval: 86400, repeats: true) { [weak self] _ in
            Task { @MainActor [weak self] in
                self?.checkAndResetDailyQuestions()
            }
        }
        
        if let timer = resetTimer {
            RunLoop.main.add(timer, forMode: .common)
        }
    }
    
    private func checkAndResetDailyQuestions() {
        let calendar = Calendar.current
        let now = Date()
        
        let shouldReset = if let lastResetDate = defaults.object(forKey: lastResetDateKey) as? Date {
            !calendar.isDate(lastResetDate, inSameDayAs: now)
        } else {
            true
        }
        
        if shouldReset {
            resetDailyQuestions()
        }
    }
    
    func loadProducts() async {
        do {
            products = try await Product.products(for: productIds)
            print("✅ Loaded \(products.count) products")
        } catch {
            print("❌ Failed to load products: \(error)")
        }
    }
    
    func purchase(_ product: Product) async throws {
        let result = try await product.purchase()
        
        switch result {
        case .success(let verification):
            await updatePurchasedProducts()
            await checkSubscriptionStatus()
            print("✅ Purchase successful")
            
        case .userCancelled:
            print("ℹ️ Purchase cancelled by user")
            
        case .pending:
            print("⏳ Purchase pending")
            
        @unknown default:
            print("❓ Unknown purchase result")
        }
    }
    
    func updatePurchasedProducts() async {
        purchasedProducts.removeAll()
        
        for await result in Transaction.currentEntitlements {
            guard case .verified(let transaction) = result else { continue }
            
            if let product = products.first(where: { $0.id == transaction.productID }) {
                purchasedProducts.append(product)
            }
        }
        
        await updateSubscriptionStatus()
    }
    
    private func updateSubscriptionStatus() async {
        let isPremium = !purchasedProducts.isEmpty
        subscriptionStatus.isPremium = isPremium
        
        // Premium 상태가 변경되었을 때만 질문 수 리셋
        if isPremium != subscriptionStatus.isPremium {
            resetDailyQuestions()
        }
        
        saveSubscriptionStatus()
    }
    
    private func resetDailyQuestions() {
        let maxQuestions = subscriptionStatus.isPremium ? 30 : 1
        subscriptionStatus.dailyQuestionsRemaining = maxQuestions
        subscriptionStatus.lastResetDate = Date()
        
        // 상태 저장
        saveSubscriptionStatus()
        // 마지막 리셋 날짜 저장
        defaults.set(Date(), forKey: lastResetDateKey)
    }
    
    func checkSubscriptionStatus() async {
        if let savedStatus = loadSubscriptionStatus() {
            if savedStatus.isPremium != subscriptionStatus.isPremium {
                // Premium 상태가 변경된 경우만 업데이트
                subscriptionStatus = savedStatus
                resetDailyQuestions()
            } else {
                // 그 외의 경우 남은 질문 수만 유지
                subscriptionStatus.dailyQuestionsRemaining = savedStatus.dailyQuestionsRemaining
            }
        }
        
        checkAndResetDailyQuestions()
    }
    
    func decrementRemainingQuestions() {
        guard subscriptionStatus.dailyQuestionsRemaining > 0 else { return }
        subscriptionStatus.dailyQuestionsRemaining -= 1
        saveSubscriptionStatus()
    }
    
    private func saveSubscriptionStatus() {
        if let encoded = try? JSONEncoder().encode(subscriptionStatus) {
            defaults.set(encoded, forKey: subscriptionStatusKey)
        }
    }
    
    private func loadSubscriptionStatus() -> UserSubscriptionStatus? {
        guard let data = defaults.data(forKey: subscriptionStatusKey),
              let status = try? JSONDecoder().decode(UserSubscriptionStatus.self, from: data) else {
            return nil
        }
        return status
    }
}


// ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    // MARK: - Singleton
    static let shared = NetworkMonitor()
    
    // MARK: - Properties
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    private var timestampQueue: TimestampQueue
    
    // MARK: - Published Properties
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    // MARK: - Constants
    private let maxTimestamps = 1000
    private let cleanupInterval: TimeInterval = 300 // 5 minutes
    
    // MARK: - Debug Control
    private var shouldLog: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    // MARK: - Initialization
    private init() {
        self.timestampQueue = TimestampQueue(maxSize: maxTimestamps)
        setupPeriodicCleanup()
        startMonitoring()
    }
    
    // MARK: - Monitoring
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            self.timestampQueue.enqueue(Date().timeIntervalSince1970)
            
            DispatchQueue.main.async {
                self.updateNetworkStatus(path)
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    private func updateNetworkStatus(_ path: NWPath) {
        self.status = path.status
        self.isReachable = path.status == .satisfied
        self.connectionType = path.availableInterfaces.first?.type
        self.isExpensive = path.isExpensive
        self.isConstrained = path.isConstrained
        
        if shouldLog {
            switch path.status {
            case .satisfied:
                // 중요한 네트워크 상태 변경만 노티피케이션 발송
                if !isReachable {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            case .unsatisfied:
                Logger.log("Network disconnected", category: "Network")
            default:
                break
            }
        }
    }
    
    // MARK: - Network Status Check
    func checkNetworkAvailability() -> Bool {
        return status == .satisfied
    }
    
    func handleNetworkError(_ error: Error) async throws -> Bool {
        if !checkNetworkAvailability() {
            throw NetworkError.noConnection
        }
        return true
    }
    
    // MARK: - Timestamp Management
    private func setupPeriodicCleanup() {
        Timer.scheduledTimer(withTimeInterval: cleanupInterval, repeats: true) { [weak self] _ in
            self?.performTimestampCleanup()
        }
    }
    
    private func performTimestampCleanup() {
        let currentTime = Date().timeIntervalSince1970
        timestampQueue.removeTimestampsBefore(currentTime - cleanupInterval)
        if shouldLog {
            Logger.log("Timestamp cleanup completed", category: "Network")
        }
    }
    
    // MARK: - Utility Methods
    func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    // MARK: - Connection Management
    func getConnectionDetails() -> String {
        """
        Network Status:
        • Connection: \(isReachable ? "Connected" : "Disconnected")
        • Type: \(getInterfaceTypeString(connectionType))
        • Expensive: \(isExpensive ? "Yes" : "No")
        • Constrained: \(isConstrained ? "Yes" : "No")
        """
    }
    
    // MARK: - Cleanup
    func stopMonitoring() {
        monitor.cancel()
        if shouldLog {
            Logger.log("Network monitoring stopped", category: "Network")
        }
    }
    
    deinit {
        stopMonitoring()
    }
}

// MARK: - TimestampQueue
private class TimestampQueue {
    private var timestamps: [TimeInterval]
    private let maxSize: Int
    
    init(maxSize: Int) {
        self.maxSize = maxSize
        self.timestamps = []
        timestamps.reserveCapacity(maxSize)
    }
    
    func enqueue(_ timestamp: TimeInterval) {
        if timestamps.count >= maxSize {
            timestamps.removeFirst()
        }
        timestamps.append(timestamp)
    }
    
    func removeTimestampsBefore(_ time: TimeInterval) {
        timestamps.removeAll { $0 < time }
    }
    
    var count: Int {
        timestamps.count
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("📱 [\(category)] \(message)")
        #endif
    }
}


