// ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

@MainActor
class QuestionSettingsViewModel: ObservableObject {
    
    @Published var selectedSubject: any SubjectType {
        didSet {
            if let defaultSubject = selectedSubject as? DefaultSubject {
                UserDefaults.standard.set(defaultSubject.rawValue, forKey: "lastSelectedSubject")
            } else if let customSubject = selectedSubject as? CustomSubject {
                UserDefaults.standard.set("custom_" + customSubject.id, forKey: "lastSelectedSubject")
            }
        }
    }
    
    @Published var useTextExtraction: Bool = true {
        didSet {
            UserDefaults.standard.set(useTextExtraction, forKey: "useTextExtraction")
        }
    }
    
    @Published var selectedLanguage: Language = .auto {
        didSet {
            UserDefaults.standard.set(selectedLanguage.rawValue, forKey: "selectedLanguage")
        }
    }
    
    // TextExtraction ê´€ë ¨ ìƒíƒœë“¤
    @Published var extractedTexts: [String: String] = [:]
    @Published var isLoadingTexts: [String: Bool] = [:]
    @Published var extractionStatus: [String: Bool] = [:]
    @Published private(set) var isCameraAuthorized = false
    @Published private(set) var isGalleryAuthorized = false
    @Published var availableSubjects: [SubjectType] = []
    
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private var openAIService: OpenAIService?
    private let totalMaximumQuestions = 10
    private var studyViewModel: StudyViewModel?
    
    // MARK: - UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    private func loadAvailableSubjects() {
        // DefaultSubjectë¥¼ ì§ì ‘ ì¶”ê°€
        var subjects: [any SubjectType] = DefaultSubject.allCases
        
        // í™œì„±í™”ëœ ì‚¬ìš©ì ì •ì˜ ê³¼ëª© ì¶”ê°€
        let activeUserSubjects = SubjectManager.shared.customSubjects
            .filter { $0.isActive }
        subjects.append(contentsOf: activeUserSubjects)
        
        availableSubjects = subjects
        
        // í˜„ì¬ ì„ íƒëœ ê³¼ëª©ì´ ì—†ê±°ë‚˜ ë¹„í™œì„±í™”ëœ ê²½ìš° ê¸°ë³¸ ê³¼ëª©ìœ¼ë¡œ ì„¤ì •
        if !subjects.contains(where: { $0.id == selectedSubject.id }) {
            selectedSubject = DefaultSubject.math  // ê¸°ë³¸ê°’ìœ¼ë¡œ math ì„¤ì •
        }
    }

    private var imageIds: [UIImage: String] = [:]
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView: Bool = false
    @Published var isGeneratingQuestions: Bool = false
    @Published var problemSetName: String = ""
    @Published var isLoading: Bool = false
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool = true
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool = false
    @Published var alertTitle: String = ""
    @Published var alertMessage: String = ""
    
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         }
     }
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
         }
     }
     
    let subject: DefaultSubject
    
     
     // MARK: - Initialization
    init(subject: any SubjectType, homeViewModel: HomeViewModel) {  // selectedTab ë§¤ê°œë³€ìˆ˜ ì œê±°
        self.selectedSubject = subject
        self.subject = subject as? DefaultSubject ?? .math  // ê¸°ë³¸ê°’ ì„¤ì •
        self.homeViewModel = homeViewModel
        self.studyViewModel = homeViewModel.studyViewModel
        
        // ì €ì¥ëœ Subject ë¶ˆëŸ¬ì˜¤ê¸°
        if let savedSubjectID = UserDefaults.standard.string(forKey: "lastSelectedSubject") {
            if savedSubjectID.starts(with: "custom_") {
                let customID = String(savedSubjectID.dropFirst(7))
                self.selectedSubject = SubjectManager.shared.customSubjects.first { $0.id == customID } ?? subject
            } else {
                self.selectedSubject = DefaultSubject(rawValue: savedSubjectID) ?? subject
            }
        } else {
            self.selectedSubject = subject
        }
        
        // UserDefaultsì—ì„œ ë§ˆì§€ë§‰ ì„¤ì •ê°’ì„ ë¶ˆëŸ¬ì˜¤ê±°ë‚˜, ì„ íƒëœ subject ì‚¬ìš©
        let lastSubjectRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastSubject)
        let lastEducationLevelRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel)
        
        // educationLevel ì´ˆê¸°í™”
        self.educationLevel = EducationLevel(rawValue: lastEducationLevelRaw ?? "") ?? .elementary
        
        // ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
        self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
        self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Initialize network monitoring
         self.isNetworkAvailable = networkMonitor.isReachable
         
         // ê¸°ë³¸ê°’ ì„¤ì •
         UserDefaults.standard.register(defaults: ["useTextExtraction": true])
         // ì €ì¥ëœ ê°’ ë¡œë“œ
         self.useTextExtraction = UserDefaults.standard.bool(forKey: "useTextExtraction")
         print("ğŸ“± Initial useTextExtraction value loaded: \(useTextExtraction)")
         
         // ì €ì¥ëœ ì–¸ì–´ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
         if let savedLanguage = UserDefaults.standard.string(forKey: "selectedLanguage"),
            let language = Language(rawValue: savedLanguage) {
             self.selectedLanguage = language
         }
         
         
         // Initialize OpenAI service
         do {
             self.openAIService = try OpenAIService()
         } catch {
             self.error = error
             print("Failed to initialize OpenAI service:", error)
         }
     }
    
    // Add permission check methods
    func checkCameraPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .camera)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
    
    func checkGalleryPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .gallery)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
     
     // MARK: - Image Management
     private func generateImageId() -> String {
         return UUID().uuidString
     }
     
    func getImageId(for image: UIImage) -> String {
        if let existingId = imageIds[image] {
            return existingId
        }
        let newId = generateImageId()
        imageIds[image] = newId
        return newId
    }

    // ìƒˆë¡œìš´ í•¨ìˆ˜ ì¶”ê°€
    private func sendExtractedTextToOpenAI(_ text: String) async throws {
        print("ğŸ“¤ Preparing to send extracted text to OpenAI")
        guard let openAIService = openAIService else {
            print("âŒ OpenAI service not initialized")
            return
        }
        
        do {
            let response = try await openAIService.sendTextExtractionResult(text)
            print("âœ… OpenAI processing completed for extracted text")
            print("ğŸ“¥ OpenAI Response: \(response)")
        } catch {
            print("âŒ Failed to process extracted text with OpenAI: \(error)")
            throw error
        }
    }

    private func sendImageToOpenAI(_ imageData: Data) async throws {
        print("ğŸ“¤ Preparing to send image to OpenAI")
        guard let openAIService = openAIService else {
            print("âŒ OpenAI service not initialized")
            return
        }
        
        do {
            try await openAIService.sendImageDataToOpenAI(imageData)
            print("âœ… Image successfully sent to OpenAI")
        } catch {
            print("âŒ Failed to send image to OpenAI: \(error)")
            throw error
        }
    }

    
    func removeImage(at index: Int) {
        guard index < selectedImages.count else { return }
        
        let imageToRemove = selectedImages[index]
        if let imageId = imageIds[imageToRemove] {
            // Remove extracted text for this image
            extractedTexts.removeValue(forKey: imageId)
            imageIds.removeValue(forKey: imageToRemove)
            print("ğŸ—‘ï¸ Removed text for image: \(imageId)")
        }
        
        selectedImages.remove(at: index)
        
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false
            hasSelectedGallery = false
        }
    }
    
    
    func saveProblemSetName() {
        if problemSetName.isEmpty {
            problemSetName = generateDefaultName()
        }
        
        // ì´ë¦„ì´ ì €ì¥ë˜ì—ˆìŒì„ ì•Œë¦¬ëŠ” í”¼ë“œë°± ì œê³µ
        HapticManager.shared.impact(style: .medium)
        print("Problem Set name saved: \(problemSetName)")
        
        // ì§ˆë¬¸ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆê³  ì´ë¦„ì´ ì €ì¥ë˜ì—ˆì„ ë•Œë§Œ StudyViewë¡œ ì´ë™
        if !isGeneratingQuestions {
            shouldShowStudyView = true
        }
    }
    
    // ê¸°ë³¸ ì´ë¦„ ìƒì„± ë©”ì„œë“œ
    func generateDefaultName() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMdd_HHmm"
        let dateString = dateFormatter.string(from: Date())
        let totalQuestions = multipleChoiceCount + trueFalseCount
        
        return "\(selectedSubject.displayName)_\(totalQuestions)Q_\(dateString)"
    }
     
     // ê¸°ì¡´ resetCounts ë©”ì„œë“œ ìˆ˜ì •
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults ì™„ì „ ì´ˆê¸°í™”ê°€ í•„ìš”í•œ ê²½ìš°ë¥¼ ìœ„í•œ ìƒˆë¡œìš´ ë©”ì„œë“œ
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         resetCounts()
     }
    
    // questionTextê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ì´ë¯¸ì§€ ì˜µì…˜ì„ ìˆ¨ê¸°ê¸° ìœ„í•œ ê³„ì‚° ì†ì„±
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // í…ìŠ¤íŠ¸ ì…ë ¥ì„ ë¦¬ì…‹í•˜ëŠ” ë©”ì„œë“œ
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // ì‹¤ì œ ì„ íƒëœ ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œë§Œ ì²´í¬
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // ë‹¤ìŒ ìƒíƒœ ë³€ê²½ì„ ìœ„í•´ ë¦¬ì…‹
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // ìƒíƒœ ë¦¬ì…‹
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }

    @MainActor
    func addImage(_ image: UIImage) async {
       print("ğŸ“¸ Starting addImage processing...")
       do {
           let compressedData = try await Task {
               try ImageService.shared.compressForAPI(image)
           }.value

           if let compressedImage = UIImage(data: compressedData) {
               selectedImages.append(compressedImage)
               let imageId = getImageId(for: compressedImage)

               if useTextExtraction {
                   print("ğŸ” Text extraction enabled for image: \(imageId)")
                   isLoadingTexts[imageId] = true
                   
                   // FileProvider ì—ëŸ¬ì™€ ìƒê´€ì—†ì´ Vision API ì‚¬ìš©
                   do {
                       // VisionServiceë¥¼ í†µí•œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                       print("ğŸ“ Starting Vision API text extraction...")
                       let extractedText = try await VisionService.shared.extractText(from: compressedImage)
                       
                       if !extractedText.isEmpty {
                           print("âœ… Text extracted successfully: \(extractedText)")
                           await MainActor.run {
                               extractedTexts[imageId] = extractedText
                               extractionStatus[imageId] = true
                               isLoadingTexts[imageId] = false
                           }
                       } else {
                           print("âš ï¸ No text extracted from image")
                           await MainActor.run {
                               extractionStatus[imageId] = false
                               isLoadingTexts[imageId] = false
                           }
                       }
                   } catch {
                       print("âŒ Text extraction failed: \(error.localizedDescription)")
                       await MainActor.run {
                           extractionStatus[imageId] = false
                           isLoadingTexts[imageId] = false
                       }
                   }
               } else {
                   print("â„¹ï¸ Text extraction disabled - using image directly")
               }
           }
       } catch {
           print("âŒ Error in image processing: \(error.localizedDescription)")
           self.error = error
           showError(error)
       }
    }
    
    
    @MainActor
    func sendAllImages() async {
       print("ğŸš€ Starting sendAllImages process...")
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("âŒ No content to generate questions from")
           return
       }
       
       isLoading = true
       studyViewModel?.isGeneratingQuestions = true
       
       do {
           var allExtractedText = ""
           var imagesForDirectProcessing: [UIImage] = []
           
           // ì´ë¯¸ì§€ ì²˜ë¦¬
           for image in selectedImages {
               let imageId = getImageId(for: image)
               print("ğŸ“¸ Processing image: \(imageId)")
               
               if useTextExtraction {
                   print("ğŸ” Text extraction enabled - attempting to extract text...")
                   do {
                       let extractedText = try await VisionService.shared.extractText(from: image)
                       if !extractedText.isEmpty {
                           print("âœ… Successfully extracted text: \(extractedText)")
                           allExtractedText += extractedText + "\n"
                       } else {
                           print("âš ï¸ No text extracted, adding to direct processing queue")
                           imagesForDirectProcessing.append(image)
                       }
                   } catch {
                       print("âŒ Error extracting text from image: \(error)")
                       imagesForDirectProcessing.append(image)
                   }
               } else {
                   print("â„¹ï¸ Text extraction disabled - adding to direct processing queue")
                   imagesForDirectProcessing.append(image)
               }
           }

           // í…ìŠ¤íŠ¸ ì…ë ¥ ì²˜ë¦¬
           if !questionText.isEmpty {
               let textInput = OpenAIService.QuestionInput(
                   content: questionText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("ğŸ“ Processing text input")
               await generateQuestions(from: textInput, parameters: createParameters())
           }
           
           // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ì²˜ë¦¬
           if !allExtractedText.isEmpty {
               let input = OpenAIService.QuestionInput(
                   content: allExtractedText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("ğŸ“¤ Sending extracted text to OpenAI")
               await generateQuestions(from: input, parameters: createParameters())
           }
           
           // ì§ì ‘ ì´ë¯¸ì§€ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš° ì²˜ë¦¬
           if !imagesForDirectProcessing.isEmpty {
               print("ğŸ“¸ Processing \(imagesForDirectProcessing.count) images directly")
               for image in imagesForDirectProcessing {
                   print("ğŸ–¼ï¸ Direct processing image")
                   try await processImageDirectly(image)
               }
           }
           
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           showSuccess()
           shouldShowStudyView = true
           
       } catch {
           print("âŒ Error in sendAllImages: \(error.localizedDescription)")
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           self.error = error
           showError(error)
       }
    }
    // generateQuestions(from:parameters:) ë³´ì¡° í•¨ìˆ˜
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
       print("ğŸ”„ Starting question generation from input")
       guard let openAIService = self.openAIService else {
           print("âŒ OpenAI service not initialized")
           return
       }
       
       do {
           let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
           print("âœ… Successfully generated \(questions.count) questions")
           
           let name = problemSetName.isEmpty ? generateDefaultName() : problemSetName
           await processGeneratedQuestions(questions, name: name)
       } catch {
           print("âŒ Error generating questions: \(error)")
           await MainActor.run {
               self.error = error
               showError(error)
           }
       }
    }

    // ì§ì ‘ ì´ë¯¸ì§€ ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¨ìˆ˜ë„ ìˆ˜ì •
    private func processImageDirectly(_ image: UIImage) async throws {
        print("ğŸ–¼ï¸ Processing image directly...")
        guard let openAIService = self.openAIService else {
            throw NetworkError.apiError("OpenAI service not initialized")
        }
        
        let compressedData = try await imageService.compressForAPI(image)
        let input = OpenAIService.QuestionInput(
            content: compressedData,
            isImage: true
        )
        print("ğŸ“¤ Sending image to OpenAI")
        let questions = try await openAIService.generateQuestions(from: input, parameters: createParameters())
        await processGeneratedQuestions(questions, name: problemSetName)
    }

    private func createParameters() -> OpenAIService.QuestionParameters {
        let subjectToUse = (selectedSubject as? DefaultSubject) ?? .math  // DefaultSubjectë¡œ ë³€í™˜
        
        return OpenAIService.QuestionParameters(
            subject: subjectToUse,
            educationLevel: educationLevel,
            questionTypes: [
                QuestionType.multipleChoice: multipleChoiceCount,
                QuestionType.trueFalse: trueFalseCount
            ],
            language: selectedLanguage
        )
    }
    
    // Update image handling methods
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("ğŸ“¸ Processing camera image...")
        guard let image = image else {
            print("âŒ No image captured")
            return
        }

        Task {
            do {
                let orientedImage = image.fixedOrientation()
                await addImage(orientedImage)
                hasCameraImage = true
                hasSelectedCamera = true
                hasSelectedGallery = false
                print("âœ… Camera image added successfully")
            } catch {
                print("âŒ Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }

    @MainActor
    func selectFromGallery() async {
        do {
            let hasPermission = try await imageService.requestPermission(for: .gallery)
            if hasPermission {
                hasSelectedCamera = false  // Reset camera selection
                hasSelectedGallery = true
                showImagePicker = true
                hasGalleryImages = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func takePhoto() async {
        print("ğŸ“¸ Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                hasSelectedGallery = false  // Reset gallery selection
                hasSelectedCamera = true
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func processGeneratedQuestions(_ questions: [Question], name: String) async {
        print("\nğŸ”„ Processing Generated Questions for subject: \(selectedSubject.displayName)")
        
        // 1. Subject ì •ë³´ ì¤€ë¹„
        var subjectType = "default"
        var subjectId = ""
        var subjectName = ""
        var defaultSubject = DefaultSubject.generalKnowledge
        
        if let customSubject = selectedSubject as? CustomSubject {
            subjectType = "custom"
            subjectId = customSubject.id
            subjectName = customSubject.displayName
            defaultSubject = .generalKnowledge
            
            print("""
            ğŸ“ Preparing Custom Subject:
            â€¢ Name: \(customSubject.displayName)
            â€¢ ID: \(customSubject.id)
            â€¢ Type: \(subjectType)
            """)
        } else if let defaultSubject = selectedSubject as? DefaultSubject {
            subjectType = "default"
            subjectId = defaultSubject.rawValue
            subjectName = defaultSubject.displayName
            
            print("""
            ğŸ“ Preparing Default Subject:
            â€¢ Name: \(defaultSubject.displayName)
            â€¢ ID: \(defaultSubject.rawValue)
            â€¢ Type: \(subjectType)
            """)
        }
        
        // 2. ì§ˆë¬¸ ì—…ë°ì´íŠ¸
        let updatedQuestions = questions.map { question in
            var updatedQuestion = question
            if let customSubject = selectedSubject as? CustomSubject {
                // CustomSubjectì¸ ê²½ìš° generalKnowledgeë¡œ ì„¤ì •
                updatedQuestion = Question(
                    id: question.id,
                    type: question.type,
                    subject: .generalKnowledge,
                    question: question.question,
                    options: question.options,
                    correctAnswer: question.correctAnswer,
                    explanation: question.explanation,
                    hint: question.hint,
                    isSaved: question.isSaved,
                    createdAt: question.createdAt
                )
            }
            return updatedQuestion
        }
        
        // 3. ProblemSet ìƒì„±
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            subject: defaultSubject,
            subjectType: subjectType,
            subjectId: subjectId,
            subjectName: subjectName,
            questions: updatedQuestions,
            createdAt: Date(),
            educationLevel: self.educationLevel,
            name: name
        )
        
        print("""
        ğŸ“¦ Created ProblemSet:
        â€¢ ID: \(problemSet.id)
        â€¢ Subject Type: \(problemSet.subjectType)
        â€¢ Subject ID: \(problemSet.subjectId)
        â€¢ Subject Name: \(problemSet.subjectName)
        â€¢ Questions Count: \(problemSet.questions.count)
        â€¢ Education Level: \(problemSet.educationLevel.rawValue)
        """)
        
        // 4. ProblemSet ì €ì¥ ë° ì„ íƒ
        await homeViewModel.saveProblemSet(problemSet)
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // 5. ì•Œë¦¼ ë°œì†¡
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
        
        print("âœ… Problem Set processing completed")
    }

    @MainActor
    private func showSuccess() {
       alertTitle = "Success"
       alertMessage = "Questions have been successfully generated."
       showAlert = true
    }
    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


// ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    @Published var streak: Int = 0
    @Published var correctAnswers: Int = 0 {
        didSet {
            // ì ìˆ˜ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì¶œë ¥ë˜ëŠ” ë””ë²„ê·¸ ë¡œê·¸
            print("ğŸ“Š StatViewModel score updated: \(correctAnswers * 10) points")
        }
    }
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var isLoading = false
    
    private weak var studyViewModel: StudyViewModel?
    private weak var homeViewModel: HomeViewModel?

    
    @Published var totalPoints: Int = 0      // í˜„ì¬ ì„¸ì…˜ì˜ ì ìˆ˜
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    

    
    init(context: NSManagedObjectContext,
         homeViewModel: HomeViewModel? = nil,
         studyViewModel: StudyViewModel? = nil) {
        self.context = context
        self.homeViewModel = homeViewModel
        self.studyViewModel = studyViewModel
        
        // Move the loadStats() call to the end of the init method
        loadStats()
    }
    
    var currentSessionScore: Int {
        return correctAnswers * 10  // ê³„ì‚° ì†ì„±ìœ¼ë¡œ ë³€ê²½
    }
    
    // StudyViewModel ì„¤ì • ë©”ì„œë“œ
    func setStudyViewModel(_ viewModel: StudyViewModel?) {
        self.studyViewModel = viewModel
        print("ğŸ“± StudyViewModel connected to StatViewModel")
    }

    
    func updateScore() {
        if let studyVM = studyViewModel {
            // correctAnswers ê°’ì„ ì—…ë°ì´íŠ¸
            self.correctAnswers = studyVM.correctAnswers
            self.totalQuestions = studyVM.totalQuestions
            // ë””ë²„ê·¸ë¥¼ ìœ„í•œ ë¡œê·¸
            print("ğŸ“Š Score Updated - Correct: \(correctAnswers), Total: \(totalQuestions), Score: \(currentSessionScore)")
        }
    }
    
    func updateStats(correctAnswers: Int, totalQuestions: Int) {
        self.correctAnswers = correctAnswers
        self.completedQuestions = totalQuestions
        self.accuracyRate = totalQuestions > 0 ?
            (Double(correctAnswers) / Double(totalQuestions)) * 100 : 0
            
        print("""
        ğŸ“Š Stats Updated:
        â€¢ Correct Answers: \(correctAnswers)
        â€¢ Total Score: \(correctAnswers * 10)
        â€¢ Accuracy Rate: \(accuracyRate)%
        """)
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("ğŸ”„ Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("ğŸ”„ Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    func loadStats() {
        isLoading = true
        let request: NSFetchRequest<CDStudySession> = CDStudySession.fetchRequest()
        
        do {
            let sessions = try context.fetch(request)
            calculateStats(from: sessions)
        } catch {
            print("Failed to fetch study sessions:", error)
        }
        
        isLoading = false
    }

    private func calculateStats(from sessions: [CDStudySession]) {
        totalQuestions = sessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrect = sessions.reduce(0) { total, session in
            total + (session.questions?.filter { ($0 as? CDQuestion)?.isCorrect == true }.count ?? 0)
        }
        
        averageScore = totalQuestions > 0 ? (Double(totalCorrect) / Double(totalQuestions)) * 100 : 0
        correctAnswers = totalCorrect
        completedQuestions = totalQuestions
        totalPoints = completedQuestions * 10
        accuracyRate = completedQuestions > 0 ? (Double(correctAnswers) / Double(completedQuestions)) * 100 : 0
        streak = calculateStreak(from: sessions)
    }

    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
            print("ğŸ”„ Starting resetProgress...")
            correctAnswers = 0
            completedQuestions = 0
            accuracyRate = 0
            totalPoints = 0  // ì ìˆ˜ ì´ˆê¸°í™”
            
            // HomeViewModelì„ í†µí•´ StudyViewModelì— ì ‘ê·¼
            guard let homeVM = homeViewModel else {
                print("âŒ homeViewModel is nil in resetProgress")
                return
            }
            
            guard let studyVM = homeVM.studyViewModel else {
                print("âŒ studyViewModel is nil in resetProgress")
                return
            }
            
            guard let currentProblemSet = homeVM.selectedProblemSet else {
                print("âŒ No selected problem set found")
                return
            }
            guard let homeVM = homeViewModel,
                  let studyVM = homeVM.studyViewModel,
                  let currentProblemSet = homeVM.selectedProblemSet else {
                print("âŒ Required view models not found")
                return
                }

                Task {
                    print("ğŸ”„ Resetting study state...")
                    await studyVM.resetState()
                    
                    await MainActor.run {
                        print("ğŸ”„ Loading questions...")
                        studyVM.loadQuestions(currentProblemSet.questions)
                        
                        print("""
                        âœ… Reset complete:

                        â€¢ Total Questions: \(currentProblemSet.questions.count)
                        """)
                    }
                }
            }
        }


// ./AISnapStudy/ViewModels/HomeViewModel.swift

// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    
    @Published var studyViewModel: StudyViewModel?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var selectedProblemSet: ProblemSet?
//    @Published var correctAnswers: Int = 0
    @Published var totalQuestions: Int = 0

    
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()

    
    init() {
        Task {
            await loadInitialData()
        }
    }
    // í˜„ì¬ ì„¸ì…˜ì˜ ì ìˆ˜ ê´€ë ¨ ì†ì„± ì¶”ê°€
    var currentSessionScore: Int {
        return studyViewModel?.correctAnswers ?? 0
    }
    
    var currentSessionTotalQuestions: Int {
        return selectedProblemSet?.questions.count ?? 0
    }
    
    func setStudyViewModel(_ viewModel: StudyViewModel) {
        print("ğŸ“± Setting StudyViewModel in HomeViewModel")
        self.studyViewModel = viewModel
    }
    
    @MainActor
    func resetAndSetProblemSet(_ problemSet: ProblemSet) async {
        print("ğŸ”„ Starting complete ProblemSet reset")
        
        // ìƒˆë¡œìš´ ProblemSet ì„¤ì •
        self.selectedProblemSet = problemSet
        
        // StudyViewModelì´ nilì´ ì•„ë‹Œì§€ í™•ì¸
        guard let studyVM = studyViewModel else {
            print("âŒ StudyViewModel is nil")
            return
        }
        
        // ìƒíƒœ ë¦¬ì…‹ ë° ë¬¸ì œ ë‹¤ì‹œ ë¡œë“œ
        await studyVM.resetState()
        studyVM.loadQuestions(problemSet.questions)
        
        print("""
        âœ… ProblemSet reset complete:
        â€¢ ID: \(problemSet.id)
        â€¢ Questions: \(problemSet.questions.count)
        â€¢ Index reset to 0
        â€¢ Current Question: \(studyVM.currentQuestion?.question ?? "none")
        """)
    }
    
    // MARK: - Data Loading
    @MainActor
    private func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("ğŸ”µ HomeViewModel - Initial data loading")
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            hasLoadedData = true
            print("âœ… Initial data loaded successfully")
        } catch {
            print("âŒ Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("ğŸ”µ HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // ìµœê·¼ ProblemSetì„ selectedProblemSetìœ¼ë¡œ ì„¤ì •
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            print("âœ… Loaded problem sets: \(problemSets.count)")
            print("âœ… Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("âŒ Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            print("ğŸ’¾ Saving ProblemSet with \(problemSet.questions.count) questions")
            try await coreDataService.saveProblemSet(problemSet)
            
            // ë°ì´í„° ë¦¬ë¡œë“œ ëŒ€ì‹  ë¬¸ì œ ì„¸íŠ¸ ì§ì ‘ ì¶”ê°€
            problemSets.insert(problemSet, at: 0)
            setSelectedProblemSet(problemSet)
            
            print("âœ… Saved ProblemSet: \(problemSet.questions.count) questions")
        } catch {
            self.error = error
            print("âŒ Failed to save ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("ğŸ”µ HomeViewModel - Setting selected problem set")
        
        // ìƒíƒœ ë³€ê²½ì„ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ í•œë²ˆì— ì²˜ë¦¬
        DispatchQueue.main.async {
            self.selectedProblemSet = problemSet
            
            if let problemSet = problemSet {
                print("""
                âœ… ProblemSet set successfully:
                â€¢ ID: \(problemSet.id)
                â€¢ Questions: \(problemSet.questions.count)
                """)
            }
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("âŒ Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("âŒ Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                ğŸ“ Stored ProblemSets:
                â€¢ Count: \(storedSets.count)
                â€¢ Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("âŒ Failed to verify storage: \(error)")
            }
        }
    }
}

extension HomeViewModel {
    @MainActor
    func renameProblemSet(_ problemSet: ProblemSet, newName: String) async {
        do {
            // Create a new ProblemSet with updated name
            var updatedProblemSet = problemSet
            updatedProblemSet.name = newName
            
            // Update in CoreData
            try await Task {
                try coreDataService.updateProblemSet(problemSet, newName: newName)
            }.value
        
            
            if let index = problemSets.firstIndex(where: { $0.id == problemSet.id }) {
                problemSets[index] = problemSets[index].copy(withName: newName)
                
                // Update selected problem set if needed
                if selectedProblemSet?.id == problemSet.id {
                    selectedProblemSet = problemSets[index]
                }
            }
            
            // Notify all observers
            objectWillChange.send()
            
            print("""
            âœ… Problem Set renamed and updated:
            â€¢ ID: \(problemSet.id)
            â€¢ New Name: \(newName)
            â€¢ In Memory Update: Success
            """)
        } catch {
            print("âŒ Failed to rename problem set: \(error)")
        }
    }
    
    @MainActor
    func deleteProblemSet(_ problemSet: ProblemSet) async {
        do {
            try await coreDataService.deleteProblemSet(problemSet)
            problemSets.removeAll { $0.id == problemSet.id }
            
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = nil
            }
            
            print("""
            âœ… Problem Set deleted:
            â€¢ ID: \(problemSet.id)
            â€¢ Name: \(problemSet.name)
            """)
        } catch {
            self.error = error
            print("âŒ Failed to delete problem set: \(error)")
        }
    }
}


// ./AISnapStudy/ViewModels/ReviewViewModel.swift


import Foundation

@MainActor
class ReviewViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            ğŸ“š Review Data Loaded:
            â€¢ Study Sessions: \(studySessions.count)
            â€¢ Problem Sets: \(problemSets.count)
            â€¢ Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("âŒ Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("âœ… Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("âŒ Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("ğŸ“± HomeViewModel reference set in ReviewViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


// ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
    // OpenAIService íƒ€ì… ì°¸ì¡° ì¶”ê°€
    typealias QuestionInput = OpenAIService.QuestionInput
    typealias QuestionParameters = OpenAIService.QuestionParameters
    private weak var statViewModel: StatViewModel?

    @Published private(set) var loadedQuestions: [Question] = []
    @Published private(set) var loadingProgress = 0

    private let openAIService: OpenAIService

    @Published private(set) var currentQuestion: Question?
    @Published var selectedAnswer: String?
    @Published var showExplanation = false
    private var questions: [Question] = []
    private var cancellables = Set<AnyCancellable>()
    @Published private(set) var currentIndex = 0
    @Published var correctAnswers: Int = 0

    // ì§ˆë¬¸ ìƒì„± ê´€ë ¨ í”„ë¡œí¼í‹° ì¶”ê°€
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    
    func setStatViewModel(_ viewModel: StatViewModel) {
        self.statViewModel = viewModel
    }

    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }

    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }

    var totalQuestions: Int {
        questions.count
    }

    private let context: NSManagedObjectContext
    private var currentSession: CDStudySession?
    private let homeViewModel: HomeViewModel

    private var hasInitialized = false

    init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
        self.context = context
        self.homeViewModel = homeViewModel

        // OpenAIService ì´ˆê¸°í™”
        do {
            self.openAIService = try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAI service: \(error)")
        }

        Task { @MainActor in
            homeViewModel.$selectedProblemSet
                .compactMap { $0 }
                .removeDuplicates(by: { $0.id == $1.id })
                .receive(on: RunLoop.main)
                .sink { [weak self] problemSet in
                    guard let self = self else { return }
                    // async ë©”ì„œë“œë¥¼ Task ë‚´ì—ì„œ í˜¸ì¶œí•˜ë„ë¡ ìˆ˜ì •
                    Task {
                        await self.resetState()
                        await MainActor.run {
                            self.loadQuestions(problemSet.questions)
                        }
                    }
                }
                .store(in: &self.cancellables)
        }

        setupCurrentSession()
    }


    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []

        // ì˜ˆìƒë˜ëŠ” ì´ ì§ˆë¬¸ ìˆ˜ ê³„ì‚°
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)

        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            await MainActor.run {
                questions.forEach { question in
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }

        await MainActor.run {
            isGeneratingQuestions = false
            loadedQuestions = generatedQuestions
            loadingProgress = 100
            isLoadingQuestions = false
        }
    }
   
    @MainActor
    func resetState() async {
        print("ğŸ”„ Performing complete state reset")
        currentIndex = 0
        selectedAnswer = nil
        showExplanation = false
        correctAnswers = 0
        
        await MainActor.run {
            questions.removeAll()
            
            if let problemSet = homeViewModel.selectedProblemSet {
                questions = problemSet.questions
                currentQuestion = questions.first
            }
        }
        
        print("""
        âœ… State reset complete:
        â€¢ Questions count: \(questions.count)
        â€¢ Current index: \(currentIndex)
        â€¢ Current question: \(currentQuestion?.question ?? "No question loaded")
        """)
    }
   
    @MainActor
    func loadQuestions(_ newQuestions: [Question]) {
        guard questions != newQuestions else {
            print("âš ï¸ Same questions already loaded, skipping")
            return
        }
        
        print("ğŸ“ Loading fresh set of \(newQuestions.count) questions")
        questions = newQuestions
        currentIndex = 0
        currentQuestion = questions.isEmpty ? nil : questions[0]
        
        print("âœ… Questions loaded: \(currentQuestion?.question ?? "No question loaded")")
    }
   
   private func setupCurrentSession() {
       let session = CDStudySession(context: context)
       session.startTime = Date()
       currentSession = session
       saveContext()
   }
   
    func submitAnswer() {
        guard let currentQuestion = currentQuestion else { return }
        
        print("Debug True/False Detailed:")
        print("Selected Answer (raw): \(selectedAnswer ?? "nil")")
        print("Selected Answer (lowercased): \(selectedAnswer?.lowercased() ?? "nil")")
        print("Correct Answer (raw): \(currentQuestion.correctAnswer)")
        print("Correct Answer (lowercased): \(currentQuestion.correctAnswer.lowercased())")
        print("Are they equal? \(currentQuestion.correctAnswer.lowercased() == selectedAnswer?.lowercased())")
        print("Length of selected answer: \(selectedAnswer?.count ?? 0)")
        print("Length of correct answer: \(currentQuestion.correctAnswer.count)")
        
        // Trim whitespace and convert to lowercase for comparison
        let trimmedSelected = selectedAnswer?.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedCorrect = currentQuestion.correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        
        let isCorrect = trimmedSelected == trimmedCorrect
        
        if isCorrect {
            correctAnswers += 1
            // Update score in StatViewModel
            DispatchQueue.main.async {
                self.statViewModel?.correctAnswers = self.correctAnswers
                // Debug log for score update
                print("âœ… Correct answer! Total correct: \(self.correctAnswers)")
            }
        }

        print("Trimmed Selected: '\(trimmedSelected ?? "nil")'")
        print("Trimmed Correct: '\(trimmedCorrect)'")
        print("Final comparison result: \(isCorrect)")
        

        if let session = currentSession {
            let question = CDQuestion(context: context)
            question.isCorrect = isCorrect
            question.question = currentQuestion.question
            question.session = session
            saveContext()
        }
        
        showExplanation = true
    }

   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
   private func saveContext() {
       do {
           try context.save()
       } catch {
           print("Failed to save context: \(error)")
       }
   }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("âœ… Question save state toggled successfully")
       } catch {
           print("âŒ Failed to toggle question save state: \(error)")
       }
   }
}


// ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
        setupMetal()
    }

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
        }
    }
    
    private func setupMetal() {
        // Metal ë””ë°”ì´ìŠ¤ ì²´í¬
        guard MTLCreateSystemDefaultDevice() != nil else {
            print("Metal is not supported on this device")
            return
        }
        
        // MetalTools í”„ë ˆì„ì›Œí¬ ì´ˆê¸°í™” ì§€ì—°
        DispatchQueue.main.async {
            // MetalTools ê´€ë ¨ ì‘ì—…
        }
    }
    
    private func setupAppearance() {
        // ë„¤ë¹„ê²Œì´ì…˜ ë°” ìŠ¤íƒ€ì¼ ì„¤ì •
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        
        // íƒ­ ë°” ìŠ¤íƒ€ì¼ ì„¤ì •
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        return true
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        ğŸ“Š CoreData Configuration:
        â€¢ Store Descriptions: \(container.persistentStoreDescriptions.count)
        â€¢ View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("âŒ No store URL found")
            return
        }
        
        print("â€¢ Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("âœ… Created CoreData directory")
        } catch {
            print("âŒ Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData ì˜µì…˜ ì„¤ì •
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // ì„±ëŠ¥ ìµœì í™” ì„¤ì •
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


// ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


// ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


// ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


// ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



// ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


// ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


// ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    let day: String          // "Mon", "Tue", etc.
    let questionsCompleted: Int
    let correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.day = date.formatted(.dateTime.weekday(.abbreviated))
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


// ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // ì¶”ê°€: Structured Outputsì˜ refusal ì²˜ë¦¬ë¥¼ ìœ„í•´
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


// ./AISnapStudy/Models/Language.swift




// ./AISnapStudy/Models/ProblemSet.swift

import Foundation

public struct ProblemSet: Identifiable, Codable, Hashable {
    // Core properties
    public let id: String
    public let subject: SubjectType  // í•„ìˆ˜ í”„ë¡œí¼í‹°ë¡œ ìœ ì§€
    public let subjectType: String
    public let subjectId: String
    public let subjectName: String
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?
    public var isFavorite: Bool

    public var questionCount: Int {
        questions.count
    }

    public var resolvedSubject: SubjectType {
        if subjectType == "default" {
            return DefaultSubject(rawValue: subjectId) ?? .generalKnowledge
        } else {
            return SubjectManager.shared.customSubjects.first(where: { $0.id == subjectId }) ?? DefaultSubject.generalKnowledge
        }
    }

    // CustomSubjectë¥¼ ìœ„í•œ ìƒì„±ì
    public init(
        id: String = UUID().uuidString,
        subject: SubjectType,
        subjectType: String,
        subjectId: String,
        subjectName: String,
        questions: [Question],
        createdAt: Date = Date(),
        educationLevel: EducationLevel,
        name: String
    ) {
        self.id = id
        self.subject = subject
        self.subjectType = subjectType
        self.subjectId = subjectId
        self.subjectName = subjectName
        self.questions = questions
        self.createdAt = createdAt
        self.educationLevel = educationLevel
        self.name = name
        self.tags = []
        self.problemSetDescription = nil
        self.isFavorite = false
    }

    private enum CodingKeys: String, CodingKey {
        case id, subject, subjectType, subjectId, subjectName
        case questions, createdAt, lastAttempted
        case educationLevel, name, tags
        case problemSetDescription, isFavorite
    }

    public init(from decoder: Decoder) throws {
        
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        
        // Properly decode subject based on subjectType
        subjectType = try container.decode(String.self, forKey: .subjectType)
        subjectId = try container.decode(String.self, forKey: .subjectId)
        subjectName = try container.decode(String.self, forKey: .subjectName)
        
        if subjectType == "custom" {
            subject = CustomSubject(id: subjectId, name: subjectName, icon: "book.fill")
        } else {
            subject = try container.decode(DefaultSubject.self, forKey: .subject)
        }
        
        // Decode remaining properties
        questions = try container.decode([Question].self, forKey: .questions)
        createdAt = try container.decode(Date.self, forKey: .createdAt)
        lastAttempted = try container.decodeIfPresent(Date.self, forKey: .lastAttempted)
        educationLevel = try container.decode(EducationLevel.self, forKey: .educationLevel)
        name = try container.decode(String.self, forKey: .name)
        tags = try container.decode([String].self, forKey: .tags)
        problemSetDescription = try container.decodeIfPresent(String.self, forKey: .problemSetDescription)
        isFavorite = try container.decode(Bool.self, forKey: .isFavorite)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(subject, forKey: .subject)
        try container.encode(subjectType, forKey: .subjectType)
        try container.encode(subjectId, forKey: .subjectId)
        try container.encode(subjectName, forKey: .subjectName)
        try container.encode(questions, forKey: .questions)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(lastAttempted, forKey: .lastAttempted)
        try container.encode(educationLevel, forKey: .educationLevel)
        try container.encode(name, forKey: .name)
        try container.encode(tags, forKey: .tags)
        try container.encodeIfPresent(problemSetDescription, forKey: .problemSetDescription)
        try container.encode(isFavorite, forKey: .isFavorite)
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/ReviewFilter.swift


import Foundation

enum ReviewFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



// ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
   case multipleChoice = "multiple_choice"
   case trueFalse = "true_false"
}

public struct Question: Identifiable, Codable, Hashable {
   public let id: String
   public let type: QuestionType
   public let subject: DefaultSubject  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
   public let question: String
   public let options: [String]
   public let correctAnswer: String
   public let explanation: String
   public let hint: String?
   public var isSaved: Bool
   public let createdAt: Date
   
   private enum CodingKeys: String, CodingKey {
       case id, type, subject, question, options
       case correctAnswer, explanation, hint
       case isSaved, createdAt
   }
   
   public init(
       id: String,
       type: QuestionType,
       subject: DefaultSubject,  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
       question: String,
       options: [String] = [],
       correctAnswer: String,
       explanation: String,
       hint: String? = nil,
       isSaved: Bool = false,
       createdAt: Date = Date()
   ) {
       self.id = id
       self.type = type
       self.subject = subject
       self.question = question
       self.options = options
       self.correctAnswer = correctAnswer
       self.explanation = explanation
       self.hint = hint
       self.isSaved = isSaved
       self.createdAt = createdAt
   }
   
   // Decodable êµ¬í˜„
   public init(from decoder: Decoder) throws {
       let container = try decoder.container(keyedBy: CodingKeys.self)
       
       id = try container.decode(String.self, forKey: .id)
       type = try container.decode(QuestionType.self, forKey: .type)
       subject = try container.decode(DefaultSubject.self, forKey: .subject)
       question = try container.decode(String.self, forKey: .question)
       options = try container.decode([String].self, forKey: .options)
       correctAnswer = try container.decode(String.self, forKey: .correctAnswer)
       explanation = try container.decode(String.self, forKey: .explanation)
       hint = try container.decodeIfPresent(String.self, forKey: .hint)
       isSaved = try container.decode(Bool.self, forKey: .isSaved)
       createdAt = try container.decode(Date.self, forKey: .createdAt)
   }
    // Hashable í”„ë¡œí† ì½œ ìš”êµ¬ì‚¬í•­ì„ ì—¬ê¸°ì— ì§ì ‘ êµ¬í˜„
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
   
   // Encodable êµ¬í˜„
   public func encode(to encoder: Encoder) throws {
       var container = encoder.container(keyedBy: CodingKeys.self)
       
       try container.encode(id, forKey: .id)
       try container.encode(type, forKey: .type)
       try container.encode(subject, forKey: .subject)
       try container.encode(question, forKey: .question)
       try container.encode(options, forKey: .options)
       try container.encode(correctAnswer, forKey: .correctAnswer)
       try container.encode(explanation, forKey: .explanation)
       try container.encodeIfPresent(hint, forKey: .hint)
       try container.encode(isSaved, forKey: .isSaved)
       try container.encode(createdAt, forKey: .createdAt)
   }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
   public static var supportsSecureCoding: Bool {
       return true
   }
   
   let question: Question
   
   init(question: Question) {
       self.question = question
       super.init()
   }
   
   public func encode(with coder: NSCoder) {
       coder.encode(question.id, forKey: "id")
       coder.encode(question.type.rawValue, forKey: "type")
       coder.encode(question.subject.rawValue, forKey: "subject")
       coder.encode(question.question, forKey: "question")
       coder.encode(question.options, forKey: "options")
       coder.encode(question.correctAnswer, forKey: "correctAnswer")
       coder.encode(question.explanation, forKey: "explanation")
       coder.encode(question.hint, forKey: "hint")
       coder.encode(question.isSaved, forKey: "isSaved")
       coder.encode(question.createdAt, forKey: "createdAt")
   }
   
   public required init?(coder: NSCoder) {
       guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
             let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
             let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
             let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
             let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
             let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
             let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
           return nil
       }
       
       let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
       let isSaved = coder.decodeBool(forKey: "isSaved")
       let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
       
       let question = Question(
           id: id,
           type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
           subject: DefaultSubject(rawValue: subjectRaw) ?? .math,  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
           question: questionText,
           options: options,
           correctAnswer: correctAnswer,
           explanation: explanation,
           hint: hint,
           isSaved: isSaved,
           createdAt: createdAt
       )
       
       self.question = question
       super.init()
   }
}

extension Question {
    var processedCorrectAnswer: String {
        switch type {
        case .trueFalse:
            return correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        case .multipleChoice:
            return correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines)
        }
    }
}


// ./AISnapStudy/Models/Subject.swift


import SwiftUI

// MARK: - Basic Subject Protocol
public protocol SubjectType: Codable {
   var id: String { get }
   var displayName: String { get }
   var color: Color { get }
   var icon: String { get }
   var rawValue: String { get }  // ì¶”ê°€
}



// MARK: - Default System Subjects
public enum DefaultSubject: String, Codable, CaseIterable, SubjectType {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    
    public var id: String {
        self.rawValue
    }
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        }
    }
    
    // ê¸°ì¡´ì˜ displayNameì„ baseDisplayNameìœ¼ë¡œ ë³€ê²½
    private var baseDisplayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        }
    }
}

// CustomSubject êµ¬ì¡°ì²´ ì¶”ê°€
public struct CustomSubject: SubjectType, Codable, Identifiable {
    public let id: String
    public var name: String  // letì„ varë¡œ ë³€ê²½
    public let icon: String
    public var isActive: Bool
    
    // SubjectType í”„ë¡œí† ì½œ ìš”êµ¬ì‚¬í•­
    public var displayName: String { name }
    public var color: Color { .green }  // ê³„ì‚° í”„ë¡œí¼í‹°ë¡œ ë³€ê²½
    public var rawValue: String { id }  // ì¶”ê°€: idë¥¼ rawValueë¡œ ì‚¬ìš©
    
    // ê¸°ë³¸ ì´ˆê¸°í™”ì
    public init(id: String = UUID().uuidString,
                name: String,
                icon: String,
                isActive: Bool = true) {
        self.id = id
        self.name = name
        self.icon = icon
        self.isActive = isActive
    }
    
    // Codable êµ¬í˜„
    enum CodingKeys: String, CodingKey {
        case id, name, icon, isActive
        // colorëŠ” ì œì™¸ - í•­ìƒ .greenì„ ì‚¬ìš©í•  ê²ƒì´ë¯€ë¡œ
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        icon = try container.decode(String.self, forKey: .icon)
        isActive = try container.decode(Bool.self, forKey: .isActive)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(icon, forKey: .icon)
        try container.encode(isActive, forKey: .isActive)
    }
}



// MARK: - Custom User Subject
public struct UserSubject: Identifiable, Codable, Hashable, SubjectType {
   public let id: String
   public var name: String
   public var colorHex: String
   public var iconName: String
   public var createdAt: Date
   public var isActive: Bool
   
   public var displayName: String {
       name
   }
   
   public var color: Color {
       Color(hex: colorHex) ?? .gray
   }
   
   public var icon: String {
       iconName
   }
    
    public var rawValue: String { id }  // ì¶”ê°€: idë¥¼ rawValueë¡œ ì‚¬ìš©
}

// MARK: - Education Level
public enum EducationLevel: String, Codable, CaseIterable {
   case elementary = "elementary"
   case middle = "middle"
   case high = "high"
   case college = "college"
   
   public var displayName: String {
       switch self {
       case .elementary:
           return "Elementary"
       case .middle:
           return "Middle"
       case .high:
           return "High"
       case .college:
           return "College"
       }
   }
   
   public var color: Color {
       switch self {
       case .elementary:
           return .green
       case .middle:
           return .green
       case .high:
           return .green
       case .college:
           return .green
       }
   }
}

public class SubjectManager: ObservableObject {
    public static let shared = SubjectManager()
    
    private init() {
        loadSettings()
        loadCustomSubjects()
    }
    
    @Published private(set) var customSubjects: [CustomSubject] = []
    @Published private(set) var hiddenDefaultSubjects: Set<String> = []
    @Published private(set) var modifiedDefaultSubjects: [String: String] = [:]
    
    // ìƒˆë¡œìš´ ê³¼ëª© ì¶”ê°€
    func addCustomSubject(name: String, icon: String = "book.circle") {
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveCustomSubjects()
    }
    
    // ê³¼ëª© ì œê±°
    func removeCustomSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveCustomSubjects()
    }
    
    // UserDefaultsë¥¼ ì‚¬ìš©í•œ ì €ì¥ ë° ë¡œë“œ
    private func saveCustomSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    private func loadCustomSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            self.customSubjects = decoded
        }
    }
    
    // "ì‚­ì œëœ" ê³¼ëª© ë³µì›ì„ ìœ„í•œ ë°±ì—… ì €ì¥
    private var deletedSubjectsBackup: Set<String> = []
    
    func isDeleted(_ subjectId: String) -> Bool {
            return hiddenDefaultSubjects.contains(subjectId)
        }
        
    func toggleDefaultSubject(_ subject: DefaultSubject) {
        print("ğŸ”„ Toggling subject visibility: \(subject.displayName)")
        if hiddenDefaultSubjects.contains(subject.id) {
            print("â– Removing from hidden: \(subject.id)")
            hiddenDefaultSubjects.remove(subject.id)
        } else {
            print("â• Adding to hidden: \(subject.id)")
            hiddenDefaultSubjects.insert(subject.id)
        }
        saveAndNotify()
        print("ğŸ“Š Current hidden subjects: \(hiddenDefaultSubjects)")
    }
        
    private func saveAndNotify() {
        saveSettings()
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    // ë¡œë“œ ì‹œ UserDefaultsì—ì„œ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
    private func loadSettings() {
        if let hidden = UserDefaults.standard.array(forKey: "hiddenDefaultSubjects") as? [String] {
            hiddenDefaultSubjects = Set(hidden)
        }
        modifiedDefaultSubjects = UserDefaults.standard.dictionary(forKey: "modifiedDefaultSubjects") as? [String: String] ?? [:]
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
        }
        // ë³€ê²½ì‚¬í•­ì„ ì•Œë¦¼
        notifySubjectsChange()
    }

    
    // ê³¼ëª© ì´ë¦„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
    func updateDefaultSubjectName(_ subject: DefaultSubject, newName: String) {
        print("âœï¸ Updating name for subject: \(subject.displayName) to: \(newName)")
        modifiedDefaultSubjects[subject.id] = newName
        print("ğŸ’¾ Current modified names: \(modifiedDefaultSubjects)")
        saveAndNotify()
    }
    
    // ê³¼ëª© ì´ë¦„ ì´ˆê¸°í™” í•¨ìˆ˜ ìˆ˜ì •
    func resetDefaultSubjectName(_ subject: DefaultSubject) {
        modifiedDefaultSubjects.removeValue(forKey: subject.id)
        saveAndNotify()
    }
    
    // ë³€ê²½ì‚¬í•­ ì•Œë¦¼ì„ ìœ„í•œ NotificationCenter í‚¤
    static let subjectsDidChangeNotification = Notification.Name("SubjectsDidChange")
    
    private func notifySubjectsChange() {
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    
    // ê³¼ëª© "ì‚­ì œ" (ì‹¤ì œë¡œëŠ” ìˆ¨ê¹€)
    func deleteDefaultSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.insert(subject.id)
        deletedSubjectsBackup.insert(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // ì‚­ì œëœ ê³¼ëª© ë³µì›
    func restoreDeletedSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.remove(subject.id)
        deletedSubjectsBackup.remove(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // ê³¼ëª©ì´ "ì‚­ì œ"ë˜ì—ˆëŠ”ì§€ í™•ì¸
    func isDeleted(_ subject: DefaultSubject) -> Bool {
        hiddenDefaultSubjects.contains(subject.id)
    }
    
    // ì‚¬ìš© ê°€ëŠ¥í•œ(ì‚­ì œë˜ì§€ ì•Šì€) ê³¼ëª©ë“¤ ê°€ì ¸ì˜¤ê¸°
    var availableSubjects: [any SubjectType] {
        let visibleDefaultSubjects = DefaultSubject.allCases.filter { !hiddenDefaultSubjects.contains($0.id) }
        let activeCustomSubjects = customSubjects.filter { $0.isActive }
        return visibleDefaultSubjects + activeCustomSubjects
    }
    
    // ì €ì¥ëœ ì„¤ì •ì— ì‚­ì œëœ ê³¼ëª© ì •ë³´ í¬í•¨
    private func saveSettings() {
        UserDefaults.standard.set(Array(hiddenDefaultSubjects), forKey: "hiddenDefaultSubjects")
        UserDefaults.standard.set(Array(deletedSubjectsBackup), forKey: "deletedSubjectsBackup")
        UserDefaults.standard.set(modifiedDefaultSubjects, forKey: "modifiedDefaultSubjects")
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    
    

    
    // ê¸°ë³¸ ê³¼ëª© ì´ë¦„ ê´€ë¦¬ ë©”ì„œë“œ ì¶”ê°€
    func getDisplayName(for subject: DefaultSubject) -> String {
        return modifiedDefaultSubjects[subject.id] ?? subject.displayName
    }
    

    
    // CustomSubject ê´€ë¦¬ ë©”ì„œë“œ
    func updateSubject(_ subject: CustomSubject, newName: String) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].name = newName
            saveSettings()
        }
    }
    
    func toggleSubjectActive(_ subject: CustomSubject) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].isActive.toggle()
            saveSettings()
        }
    }
    
    func deleteSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveSettings()
    }
    

    
    // ê¸°ë³¸ ê³¼ëª© ìˆ¨ê¹€ ìƒíƒœ ê´€ë¦¬
        func toggleSubjectVisibility(_ subject: DefaultSubject) {
            if hiddenDefaultSubjects.contains(subject.id) {
                hiddenDefaultSubjects.remove(subject.id)
            } else {
                hiddenDefaultSubjects.insert(subject.id)
            }
            saveSettings()
        }
        
        // ê³¼ëª©ì´ ìˆ¨ê²¨ì ¸ ìˆëŠ”ì§€ í™•ì¸
        func isHidden(_ subject: DefaultSubject) -> Bool {
            hiddenDefaultSubjects.contains(subject.id)
        }
        
        
        // ëª¨ë“  í™œì„±í™”ëœ ê³¼ëª© ê°€ì ¸ì˜¤ê¸° (ìˆ¨ê²¨ì§€ì§€ ì•Šì€ ê¸°ë³¸ ê³¼ëª© + í™œì„±í™”ëœ ì‚¬ìš©ì ì •ì˜ ê³¼ëª©)
    var allSubjects: [SubjectType] {
        var subjects: [SubjectType] = Array(DefaultSubject.allCases)
        subjects.append(contentsOf: customSubjects.filter { $0.isActive })
        return subjects
    }
    
    
    // ê³¼ëª© ì¶”ê°€ ë©”ì„œë“œ ìˆ˜ì •
    func addSubject(name: String, icon: String) {  // color ë§¤ê°œë³€ìˆ˜ ì œê±°
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveSubjects()
        
        print("""
        âœ… Added new custom subject:
        â€¢ Name: \(name)
        â€¢ ID: \(newSubject.id)
        â€¢ Total custom subjects: \(customSubjects.count)
        """)
    }
    
    // ì €ì¥ ë©”ì„œë“œ ìˆ˜ì •
    private func saveSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
            print("ğŸ’¾ Saved \(customSubjects.count) custom subjects to UserDefaults")
        }
    }
    
    // ë¡œë“œ ë©”ì„œë“œ ìˆ˜ì •
    private func loadSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
            print("ğŸ“¤ Loaded \(customSubjects.count) custom subjects from UserDefaults")
            print("ğŸ“š Custom Subjects: \(customSubjects.map { $0.displayName })")
        }
    }
    
}



// MARK: - Color Extension for Hex
extension Color {
    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components else { return nil }
        
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        let hex = String(format: "%02lX%02lX%02lX",
                        lroundf(r * 255),
                        lroundf(g * 255),
                        lroundf(b * 255))
        
        return hex
    }
    
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        
        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else {
            return nil
        }
        
        let r = Double((rgb & 0xFF0000) >> 16) / 255.0
        let g = Double((rgb & 0x00FF00) >> 8) / 255.0
        let b = Double(rgb & 0x0000FF) / 255.0
        
        self.init(red: r, green: g, blue: b)
    }
}


// ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì €ì¥ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


// ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


// ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


// ./AISnapStudy/Views/Question/QuestionSettingsView.swift



import SwiftUI
import PhotosUI
import UIKit
import AVFoundation

struct QuestionSettingsView: View {
    @StateObject private var viewModel: QuestionSettingsViewModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedTab: Int
    @State private var expandedSections: Set<SectionType> = []
    @State private var isTextInputSelected = false
    @State private var showNamePopup = false
    @State private var isGeneratingQuestions = false
    @State private var activeSheet: ActiveSheet?
    
    // ì—¬ê¸°ë¥¼ Subjectì—ì„œ DefaultSubjectë¡œ ë³€ê²½
    let subject: DefaultSubject  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
    
    public enum SectionType: Hashable {
        case questionAbout
        case learningSubject
        case questionTypes
        case educationLevel
    }
    
    private enum ActiveSheet: Identifiable {
        case camera, gallery
        
        var id: Int {
            switch self {
            case .camera: return 1
            case .gallery: return 2
            }
        }
    }
    
    
    init(subject: DefaultSubject, homeViewModel: HomeViewModel, selectedTab: Binding<Int>) {
        self.subject = subject
        self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
            subject: subject,
            homeViewModel: homeViewModel
        ))
        self._selectedTab = selectedTab
    }

    var body: some View {
        VStack(spacing: 0) {
            // Instructions Card
            Form {
                // Speed Up and Language Selection Section
                Section {
                    SpeedUpSection(useTextExtraction: $viewModel.useTextExtraction)
                }
                .listRowSpacing(0)

                Section {
                    LanguageSection(selectedLanguage: $viewModel.selectedLanguage)
                }
                .listRowSpacing(0)
                
                VStack(alignment: .leading, spacing: 10) {
                    Text("How to Generate Questions")
                        .font(.headline)
                        .padding(.bottom, 4)
                    
                    Text("Select one of these methods here and then choose Subject and Type to create questions:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    // Input Methods with descriptions
                    HStack(spacing: 12) {
                        Group {
                            InputMethodCard(
                                icon: "camera.fill",
                                title: "Camera",
                                isUsed: viewModel.hasSelectedCamera,
                                isDisabled: !viewModel.canUseImageInput,
                                action: {
                                    if viewModel.canUseImageInput {
                                        viewModel.isTextInputActive = false
                                        Task {
                                            if await viewModel.checkCameraPermission() {
                                                activeSheet = .camera
                                            }
                                        }
                                    }
                                }
                            )
                            .frame(maxWidth: .infinity)
                        }
                        
                        
                        Group {
                            InputMethodCard(
                                icon: "photo.fill",
                                title: "Gallery",
                                isUsed: viewModel.hasSelectedGallery,
                                isDisabled: !viewModel.canUseImageInput,
                                action: {
                                    if viewModel.canUseImageInput {
                                        viewModel.isTextInputActive = false
                                        Task {
                                            if await viewModel.checkGalleryPermission() {
                                                activeSheet = .gallery
                                            }
                                        }
                                    }
                                }
                            )
                            .frame(maxWidth: .infinity)
                        }
                        
                        Group {
                            InputMethodCard(
                                icon: "text.bubble.fill",
                                title: "Text",
                                isUsed: viewModel.isTextInputActive,
                                isDisabled: !viewModel.canUseTextInput,
                                action: {
                                    viewModel.toggleTextInput()
                                }
                            )
                            .frame(maxWidth: .infinity)
                        }
                    }
                }
                .padding()
                .background(Color(.systemBackground))
                .cornerRadius(12)
                
                // Text Input Field
                if viewModel.isTextInputActive {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .padding(.horizontal)
                }

                // Selected Images Display
                if !viewModel.selectedImages.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                SelectedImageCell(
                                    image: viewModel.selectedImages[index],
                                    onDelete: {
                                        viewModel.removeImage(at: index)
                                    }
                                )
                            }
                        }
                        .padding(.vertical, 8)
                    }
                }
                
                // Subject Section
                Section {
                    DisclosureGroup(
                        isExpanded: isExpandedBinding(for: .learningSubject)
                    ) {
                        LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                    } label: {
                        HStack {
                            Text("Subject")
                                .font(.headline)
                            Spacer()
                            Text(viewModel.selectedSubject.displayName)
                                .foregroundColor(.gray)
                        }
                    }
                }.listRowSpacing(0)
                
                if viewModel.isTextInputActive {
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .educationLevel)
                        ) {
                            EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                        } label: {
                            HStack {
                                Text("Education")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.educationLevel.displayName)
                                    .foregroundColor(.gray)
                            }
                        }
                    }.listRowSpacing(0)
                }

                
                // Question Types Section
                Section {
                    DisclosureGroup(
                        isExpanded: isExpandedBinding(for: .questionTypes)
                    ) {
                        QuestionTypesSelectionSection(viewModel: viewModel)
                    } label: {
                        HStack {
                            Text("Type")
                                .font(.headline)
                            Spacer()
                            Text("\(viewModel.totalQuestionCount) questions")
                                .foregroundColor(.gray)
                        }
                    }
                }.listRowSpacing(0)
                
                if isTextInputSelected {
                    // Education Level Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .educationLevel)
                        ) {
                            EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                        } label: {
                            HStack {
                                Text("Education")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.educationLevel.displayName)
                                    .foregroundColor(.gray)
                            }
                        }
                    }.listRowSpacing(0)
                }
            }
            .listSectionSpacing(4)
            
            // Generate Questions Button
            VStack {
                Button(action: {
                    showNamePopup = true
                    isGeneratingQuestions = true
                    Task {
                        await viewModel.sendAllImages()
                    }
                }) {
                    Text("Generate Questions")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                        .cornerRadius(10)
                }
                .disabled(!isGenerateButtonEnabled)
                .padding()
            }
            .background(Color(UIColor.systemGroupedBackground))
        }
        .overlay(popupOverlay)
        .navigationBarItems(leading: cancelButton)
        .navigationBarTitleDisplayMode(.inline)
        .sheet(item: $activeSheet) { sheet in
            switch sheet {
            case .camera:
                ImagePicker(
                    image: $viewModel.selectedImage,
                    sourceType: .camera,
                    onImageSelected: { image in
                        Task {
                            await viewModel.handleCameraImage(image)
                        }
                    }
                )
                .interactiveDismissDisabled()
                
            case .gallery:
                PhotoPicker(selectedImages: $viewModel.selectedImages)
                    .interactiveDismissDisabled()
            }
        }
        .alert(isPresented: $viewModel.showAlert) {
            Alert(
                title: Text(viewModel.alertTitle),
                message: Text(viewModel.alertMessage),
                dismissButton: .default(Text("OK")) {
                    if viewModel.alertTitle == "Success" {
                        dismiss()
                    }
                }
            )
        }
        .onChange(of: viewModel.shouldShowStudyView) { show in
            if show {
                dismiss()
                selectedTab = 1
            }
        }
    }
    
    private var cancelButton: some View {
        Button("Cancel") {
            viewModel.resetCounts()
            dismiss()
        }
    }
    
    private var popupOverlay: some View {
        Group {
            if showNamePopup {
                ProblemSetNamePopup(
                    isPresented: $showNamePopup,
                    problemSetName: $viewModel.problemSetName,
                    isGeneratingQuestions: $viewModel.isGeneratingQuestions,
                    defaultName: viewModel.generateDefaultName()
                ) {
                    viewModel.saveProblemSetName()
                    showNamePopup = false
                    viewModel.shouldShowStudyView = true
                }
                .transition(.opacity)
                .animation(.easeInOut, value: showNamePopup)
            }
        }
    }
    
    private var isGenerateButtonEnabled: Bool {
        let hasInput = !viewModel.selectedImages.isEmpty ||
            (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
        let hasQuestionType = viewModel.totalQuestionCount > 0
        return hasInput && hasQuestionType
    }
    
    private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
        Binding(
            get: { expandedSections.contains(section) },
            set: { isExpanded in
                withAnimation {
                    if isExpanded {
                        expandedSections.insert(section)
                    } else {
                        expandedSections.remove(section)
                    }
                }
            }
        )
    }
}




struct ProblemSetNamePopup: View {
    @Binding var isPresented: Bool
    @Binding var problemSetName: String
    @Binding var isGeneratingQuestions: Bool
    let defaultName: String
    let onSubmit: () -> Void
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 24) {
                Text("Name Your Question Set")
                    .font(.title2)
                    .fontWeight(.bold)
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("Enter a name for your question set:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("Enter name", text: $problemSetName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .font(.body)
                        .frame(height: 44)
                        .placeholder(when: problemSetName.isEmpty) {
                            Text("Default: \(defaultName)")
                                .foregroundColor(.gray)
                        }
                }
                
                Text(isGeneratingQuestions ?
                     "Questions are being generated... Please wait." :
                     "Questions are ready. Please save the name to continue.")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Button(action: {
                    if problemSetName.isEmpty {
                        problemSetName = defaultName
                    }
                    if !isGeneratingQuestions {
                        onSubmit()
                    }
                }) {
                    Text(isGeneratingQuestions ? "Generating Questions..." : "Save Name")
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(isGeneratingQuestions ? Color.gray : Color.blue)
                        .cornerRadius(10)
                }
                .disabled(isGeneratingQuestions)
            }
            .padding(32)
            .background(Color(.systemBackground))
            .cornerRadius(16)
            .shadow(radius: 10)
            .padding(.horizontal, 32)
        }
        // ë¶ˆí•„ìš”í•œ onChangeë‚˜ onReceive ëª¨ë””íŒŒì´ì–´ ì œê±°
    }
}

struct SubjectSelectionButton: View {
    let subject: any SubjectType
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.caption)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .padding(.horizontal, 8)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .foregroundColor(isSelected ? subject.color : .gray)
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}



struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // ì¶”ê°€
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSectionë„ ìˆ˜ì •
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // ì´ ë¬¸ì œ ìˆ˜ í‘œì‹œ
                HStack {
                    Text("Type")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/10")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    var body: some View {
        Section("Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    // ê¸°ë³¸ ê³¼ëª©
                    ForEach(DefaultSubject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected subject: \(subject.rawValue)")
                        }
                    }
                    
                    // ì‚¬ìš©ì ì •ì˜ ê³¼ëª©
                    ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected custom subject: \(subject.name)")
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// ImagePicker, PhotoPicker, LoadingView ë„ ì¶”ê°€
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = 10
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

class CustomImagePickerController: UIImagePickerController {
    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .all // ëª¨ë“  ë°©í–¥ ì§€ì›
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)?
    
    class CustomImagePickerController: UIImagePickerController {
        override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
            return .portrait // ì¹´ë©”ë¼ UIëŠ” í•­ìƒ ì„¸ë¡œ ëª¨ë“œë¡œ ìœ ì§€
        }
    }
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = CustomImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        
        if sourceType == .camera {
            picker.cameraDevice = .rear
            picker.cameraCaptureMode = .photo
            picker.allowsEditing = false
            
            // ì „ì²´ í™”ë©´ ëª¨ë“œë¡œ ì„¤ì •
            picker.modalPresentationStyle = .fullScreen
            
            // ì¹´ë©”ë¼ UIë¥¼ ì„¸ë¡œ ëª¨ë“œë¡œ ê³ ì •
            picker.navigationController?.navigationBar.isHidden = false
            picker.navigationController?.interactivePopGestureRecognizer?.isEnabled = false
        }
        
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController,
                                 didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                // ì´ë¯¸ì§€ëŠ” ì›ë˜ ë°©í–¥ ê·¸ëŒ€ë¡œ ìœ ì§€
                parent.image = image
                parent.onImageSelected?(image)
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

// UIImage extension for orientation fixing
extension UIImage {
    func fixedOrientation() -> UIImage {
        if imageOrientation == .up { return self }
        
        var transform = CGAffineTransform.identity
        
        switch imageOrientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: .pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: .pi/2)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: -.pi/2)
        case .up, .upMirrored:
            break
        @unknown default:
            break
        }
        
        guard let cgImage = self.cgImage else { return self }
        
        let context = CGContext(data: nil,
                              width: Int(size.width),
                              height: Int(size.height),
                              bitsPerComponent: cgImage.bitsPerComponent,
                              bytesPerRow: 0,
                              space: cgImage.colorSpace!,
                              bitmapInfo: cgImage.bitmapInfo.rawValue)!
        
        context.concatenate(transform)
        
        switch imageOrientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
        }
        
        guard let newCGImage = context.makeImage() else { return self }
        return UIImage(cgImage: newCGImage)
    }
}

struct InputMethodCard: View {
    let icon: String
    let title: String
    let isUsed: Bool
    let isDisabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .padding(.vertical, 16)
            .padding(.horizontal, 8)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isUsed ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isUsed ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(isDisabled)
        .opacity(isDisabled ? 0.5 : 1)
    }
}


// ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            VStack(alignment: .leading, spacing: 12) {
                TrueFalseButton(
                    title: "True",
                    isSelected: selectedAnswer?.lowercased() == "true",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "true"
                }
                
                TrueFalseButton(
                    title: "False",
                    isSelected: selectedAnswer?.lowercased() == "false",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "false"
                }
            }
            
            // Answer Result
            if showExplanation {
                HStack {
                    if let isCorrect = isCorrect {
                        HStack {
                            Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect ? .green : .red)
                            
                            Text(isCorrect ? "Correct!" : "Incorrect")
                                .foregroundColor(isCorrect ? .green : .red)
                                .fontWeight(.semibold)
                        }
                        .padding(.vertical, 4)
                        
                        Spacer()
                        
                    }
                }
                
                // Show correct answer if wrong
                if let isCorrect = isCorrect, !isCorrect {
                    Text("Answer: \(question.correctAnswer)")
                        .font(.subheadline)
                        .foregroundColor(.blue)
                        .padding(.vertical, 4)
                }
            }
            
            // Explanation Section
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}

// TrueFalseButton êµ¬ì¡°ì²´ëŠ” ë³€ê²½ ì—†ìŒ
struct TrueFalseButton: View {
    let title: String
    let isSelected: Bool
    let disabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .disabled(disabled)
    }
}


// ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            // ì§ˆë¬¸ í…ìŠ¤íŠ¸
            Text(question.question)
                .font(.title3)
                .fontWeight(.bold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 16)
            
            // ì„ íƒì§€
            VStack(spacing: 16) {
                ForEach(question.options, id: \.self) { option in
                    Button(action: { selectedAnswer = option }) {
                        HStack {
                            Text(option)
                                .font(.body)
                                .fontWeight(.medium)
                                .multilineTextAlignment(.leading)
                                .foregroundColor(getTextColor(for: option))
                            Spacer()
                            if selectedAnswer == option && showExplanation {
                                Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                    .foregroundColor(isCorrect == true ? .green : .red)
                                    .imageScale(.large)
                                    .transition(.scale.combined(with: .opacity))
                            }
                        }
                        .padding(.vertical, 16)
                        .padding(.horizontal, 20)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(getBackgroundColor(for: option))
                                .shadow(color: Color.black.opacity(0.05),
                                       radius: 4, x: 0, y: 2)
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    .disabled(showExplanation)
                }
            }
        }
        .padding()
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.15)
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.15)
            }
        }
        // ê¸°ë³¸ ë°°ê²½ìƒ‰ì„ ì¡°ê¸ˆ ë” ëª…í™•í•˜ê²Œ êµ¬ë¶„
        return Color(UIColor.systemGray6)
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue
            } else {
                return isCorrect == true ? .green : .red
            }
        }
        return .primary
    }
}


// ./AISnapStudy/Views/Question/Sections/EducationLevelSection.swift


import SwiftUI

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionTypesSection.swift


import SwiftUI

// Question Type Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Type") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "True/False",
                    count: $viewModel.trueFalseCount
                )
                
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionAboutSection.swift

import SwiftUI

import SwiftUI

struct QuestionAboutSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @Binding var isTextInputSelected: Bool

    var body: some View {
        VStack(spacing: 16) { // DisclosureGroup ì œê±°
            // ê¸°ì¡´ ì´ë¯¸ì§€ ì˜µì…˜ ì¹´ë“œ
            HStack(spacing: 12) {
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.takePhoto() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.selectFromGallery() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        isTextInputSelected.toggle()
                        viewModel.toggleTextInput()
                    }
                )
            }
            .padding(.horizontal)

            // ğŸŸ¢ useTextExtraction í† ê¸€ ì¶”ê°€
            Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                .padding(.horizontal)
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("ğŸ“± useTextExtraction changed to: \(newValue)")
                }

            // í…ìŠ¤íŠ¸ ì…ë ¥ í•„ë“œ
            if viewModel.isTextInputActive {
                TextField("Enter your question here...", text: $viewModel.questionText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }

            // ì„ íƒí•œ ì´ë¯¸ì§€ í‘œì‹œ
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                            SelectedImageCell(
                                image: viewModel.selectedImages[index],
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .listRowSpacing(0)
    }
}


// ./AISnapStudy/Views/Question/Sections/LearningSubjectSection.swift

import SwiftUI

struct LearningSubjectSection: View {
    @StateObject private var subjectManager = SubjectManager.shared
    @Binding var selectedSubject: SubjectType
    
    var visibleSubjects: [SubjectType] {
        // ê¸°ë³¸ ê³¼ëª© ì¤‘ ì‚­ì œë˜ì§€ ì•Šì€ ê²ƒë“¤ë§Œ í•„í„°ë§
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        // í™œì„±í™”ëœ ì»¤ìŠ¤í…€ ê³¼ëª©ë§Œ í•„í„°ë§
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        ğŸ“š LearningSubjectSection - Visible Subjects:
        â€¢ Total Subjects: \(subjects.count)
        â€¢ Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        â€¢ Active Custom Subjects: \(customSubjects.map { $0.displayName })
        â€¢ Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
    
    var body: some View {
        LazyVGrid(columns: [
            GridItem(.flexible()),
            GridItem(.flexible()),
            GridItem(.flexible())
        ], spacing: 12) {
            ForEach(visibleSubjects, id: \.id) { subject in
                SubjectSelectionButton(
                    subject: subject,
                    isSelected: selectedSubject.id == subject.id
                ) {
                    withAnimation(.spring()) {
                        selectedSubject = subject
                        print("ğŸ“ Selected subject: \(subject.displayName)")
                    }
                }
            }
        }
        .padding(.vertical, 8)
        .onAppear {
            // í˜„ì¬ ì„ íƒëœ ê³¼ëª©ì´ ì‚­ì œë˜ì—ˆê±°ë‚˜ ë¹„í™œì„±í™”ëœ ê²½ìš° ê¸°ë³¸ ê³¼ëª©ìœ¼ë¡œ ë³€ê²½
            if let defaultSubject = selectedSubject as? DefaultSubject,
               subjectManager.isDeleted(defaultSubject) {
                // ì²« ë²ˆì§¸ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ê³¼ëª©ì„ ì„ íƒ
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            } else if let customSubject = selectedSubject as? CustomSubject,
                      !subjectManager.customSubjects.contains(where: { $0.id == customSubject.id && $0.isActive }) {
                // ì²« ë²ˆì§¸ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ê³¼ëª©ì„ ì„ íƒ
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Components/AddSubjectView.swift



import SwiftUI


// Helper Views
struct IconSelectionButton: View {
    let icon: String
    let isSelected: Bool
    let color: Color
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .frame(width: 50, height: 50)
                .foregroundColor(isSelected ? .white : color)
                .background(
                    Circle()
                        .fill(isSelected ? color : Color.gray.opacity(0.1))
                )
                .overlay(
                    Circle()
                        .stroke(isSelected ? color : Color.clear, lineWidth: 2)
                )
        }
    }
}

struct ColorSelectionButton: View {
    let color: Color
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Circle()
                .fill(color)
                .frame(width: 50, height: 50)
                .overlay(
                    Circle()
                        .stroke(Color.white, lineWidth: isSelected ? 3 : 0)
                )
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        }
    }
}



// ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // ìƒë‹¨ í—¤ë”
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // íƒœê·¸ ëª©ë¡ (ì‘ê³  ê°„ê²°í•˜ê²Œ)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // ìµœëŒ€ 3ê°œì˜ íƒœê·¸ë§Œ í‘œì‹œ
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // ì •ë³´ ê·¸ë¦¬ë“œ
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
            }
            .font(.footnote)
            
            // ì„¤ëª… (ë” ì§§ê²Œ)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



// ./AISnapStudy/Views/Components/SpeedUpSection.swift


import SwiftUI

struct SpeedUpSection: View {
    @Binding var useTextExtraction: Bool
    @State private var isExpanded: Bool = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                Text("Automatically extracts text from images to generate questions faster. Recommended when images contain mostly text.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.vertical, 8)
            },
            label: {
                HStack {
                    Image(systemName: "bolt.fill")
                        .foregroundColor(.yellow)
                    Text("Speed Up")
                        .font(.headline)
                    Spacer()
                    Toggle("", isOn: $useTextExtraction)
                        .labelsHidden()
                }
            }
        )
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionsView.swift

import SwiftUI

struct SavedQuestionsView: View {
    let questions: [Question]
    let homeViewModel: HomeViewModel
    @State private var showStudyView = false
    
    var body: some View {
        List(questions) { question in
            SavedQuestionCard(question: question)
                .onTapGesture {
                    let problemSet = ProblemSet(
                        id: UUID().uuidString,
                        subject: question.subject,
                        subjectType: "default",  // ì €ì¥ëœ ë¬¸ì œëŠ” í•­ìƒ ê¸°ë³¸ ê³¼ëª©ìœ¼ë¡œ ì²˜ë¦¬
                        subjectId: question.subject.rawValue,
                        subjectName: question.subject.displayName,
                        questions: [question],
                        createdAt: Date(),
                        educationLevel: .elementary,
                        name: "Saved Question"
                    )
                    homeViewModel.setSelectedProblemSet(problemSet)
                    showStudyView = true
                }
        }
        .navigationTitle("Saved Questions")
        .background(
            NavigationLink(
                isActive: $showStudyView,
                destination: {
                    if let studyViewModel = homeViewModel.studyViewModel {
                        StudyView(
                            questions: [questions[0]],
                            studyViewModel: studyViewModel,
                            selectedTab: .constant(1)
                        )
                    }
                },
                label: { EmptyView() }
            )
        )
    }
}


// ./AISnapStudy/Views/Components/DraggableSubjectGrid.swift

import SwiftUI

struct DraggableSubjectGrid: View {
    @ObservedObject var subjectManager = SubjectManager.shared
    @State private var subjects: [SubjectType]
    @State private var draggingItem: SubjectType?
    @GestureState private var dragLocation: CGPoint = .zero
    
    // Grid layout settings
    let columns = [
        GridItem(.adaptive(minimum: 120), spacing: 12)
    ]
    
    init(subjects: [SubjectType]) {
        _subjects = State(initialValue: subjects)
    }
    
    var body: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(subjects, id: \.id) { subject in
                SubjectButton(subject: subject)
                    .overlay(draggingItem?.id == subject.id ? Color.blue.opacity(0.3) : Color.clear)
                    .onLongPressGesture(minimumDuration: 0.5) {
                        withAnimation(.spring()) {
                            self.draggingItem = subject
                        }
                    }
                    .gesture(
                        DragGesture()
                            .onChanged { value in
                                guard let draggingItem = draggingItem else { return }
                                let currentIndex = subjects.firstIndex { $0.id == draggingItem.id }
                                let targetIndex = computeTargetIndex(location: value.location)
                                
                                if let currentIndex = currentIndex,
                                   let targetIndex = targetIndex,
                                   currentIndex != targetIndex {
                                    withAnimation(.spring()) {
                                        subjects.move(fromOffsets: IndexSet(integer: currentIndex),
                                                    toOffset: targetIndex)
                                    }
                                }
                            }
                            .onEnded { _ in
                                self.draggingItem = nil
                                // Save new order to UserDefaults
                                saveSubjectOrder()
                            }
                    )
            }
        }
        .padding()
    }
    
    private func computeTargetIndex(location: CGPoint) -> Int? {
        // Convert point to index logic
        // ...
        return nil
    }
    
    private func saveSubjectOrder() {
        let subjectIds = subjects.map { $0.id }
        UserDefaults.standard.set(subjectIds, forKey: "subjectOrder")
    }
}

struct SubjectButton: View {
    let subject: SubjectType
    @State private var isPressed = false
    
    var body: some View {
        Button(action: {}) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.subheadline)
                    .lineLimit(1)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(subject.color.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(subject.color.opacity(0.2), lineWidth: 1)
                    )
            )
        }
        .scaleEffect(isPressed ? 1.05 : 1.0)
        .animation(.spring(), value: isPressed)
        .buttonStyle(PlainButtonStyle())
    }
}


// ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/LanguageButton.swift

import SwiftUI

// Add new supporting view for Language Button
struct LanguageButton: View {
    let language: Language
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 6) {
                Text(emoji(for: language))
                    .font(.title2)
                Text(displayName(for: language))
                    .font(.caption)
                    .foregroundColor(isSelected ? .white : .primary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.blue : Color.gray.opacity(0.1))
            )
        }
    }
    
    private func emoji(for language: Language) -> String {
        switch language {
        case .auto: return "ğŸŒ"
        case .english: return "ğŸ‡ºğŸ‡¸"
        case .korean: return "ğŸ‡°ğŸ‡·"
        case .japanese: return "ğŸ‡¯ğŸ‡µ"
        case .chinese: return "ğŸ‡¨ğŸ‡³"
        case .spanish: return "ğŸ‡ªğŸ‡¸"
        case .french: return "ğŸ‡«ğŸ‡·"
        case .german: return "ğŸ‡©ğŸ‡ª"
        case .russian: return "ğŸ‡·ğŸ‡º"
        case .italian: return "ğŸ‡®ğŸ‡¹"
        }
    }
    
    private func displayName(for language: Language) -> String {
        switch language {
        case .auto: return "Auto"
        default: return language.rawValue
        }
    }
}



struct LanguageSection: View {
    @Binding var selectedLanguage: Language
    @State private var isExpanded: Bool = false
    @State private var showLanguageMenu = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Choose the language in which you want the questions to be generated. The generated questions will appear in your selected language regardless of the input language.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                        
                    Text("Current: \(selectedLanguage.displayName) \(selectedLanguage.emoji)")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            },
            label: {
                HStack {
                    HStack {
                        Image(systemName: "globe")
                            .foregroundColor(.blue)
                        Text("Language")
                            .font(.headline)
                    }
                    
                    Spacer()
                    
                    // ë³„ë„ì˜ ë²„íŠ¼ìœ¼ë¡œ ë¶„ë¦¬
                    Button(action: {
                        showLanguageMenu = true
                    }) {
                        HStack(spacing: 4) {
                            Text(selectedLanguage.emoji)
                            Image(systemName: "chevron.down")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
            }
        )
        .sheet(isPresented: $showLanguageMenu) {
            LanguageSelectionView(selectedLanguage: $selectedLanguage)
        }
    }
}

// LanguageSelectionViewëŠ” ë” ê¹”ë”í•œ UIë¡œ ì—…ë°ì´íŠ¸
struct LanguageSelectionView: View {
    @Binding var selectedLanguage: Language
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            List {
                ForEach(Language.allCases) { language in
                    LanguageRow(
                        language: language,
                        isSelected: language == selectedLanguage,
                        onSelect: {
                            selectedLanguage = language
                            UserDefaults.standard.set(language.rawValue, forKey: "selectedLanguage")
                            dismiss()
                        }
                    )
                }
            }
            .navigationTitle("Select Language")
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
        }
        .presentationDetents([.medium, .large])
    }
}

// ë³„ë„ì˜ LanguageRow ì»´í¬ë„ŒíŠ¸
struct LanguageRow: View {
    let language: Language
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack(spacing: 12) {
                Text(language.emoji)
                    .font(.title3)
                
                VStack(alignment: .leading) {
                    Text(language.displayName)
                        .foregroundColor(.primary)
                    Text(language.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}


// Language.swift (ìƒˆë¡œìš´ íŒŒì¼)
enum Language: String, CaseIterable, Identifiable {
    case auto = "AUTO"
    case english = "english"
    case korean = "korean"
    case japanese = "japanese"
    case chinese = "chinese"
    case spanish = "spanish"
    case french = "french"
    case german = "german"
    case russian = "russian"
    case italian = "italian"
    
    var id: String { self.rawValue }
    
    // OpenAI APIì—ì„œ ì‚¬ìš©í•  ì–¸ì–´ ì½”ë“œ
    var languageCode: String {
        switch self {
        case .auto: return "auto"
        case .english: return "en"
        case .korean: return "ko"
        case .japanese: return "ja"
        case .chinese: return "zh"
        case .spanish: return "es"
        case .french: return "fr"
        case .german: return "de"
        case .russian: return "ru"
        case .italian: return "it"
        }
    }
}

// Update Language enum to include display names and emojis
extension Language {
    var displayName: String {
        switch self {
        case .auto: return "Automatic"
        case .english: return "English"
        case .korean: return "í•œêµ­ì–´"
        case .japanese: return "æ—¥æœ¬èª"
        case .chinese: return "ä¸­æ–‡"
        case .spanish: return "EspaÃ±ol"
        case .french: return "FranÃ§ais"
        case .german: return "Deutsch"
        case .russian: return "Ğ ÑƒÑÑĞºĞ¸Ğ¹"
        case .italian: return "Italiano"
        }
    }
    
    var emoji: String {
        switch self {
        case .auto: return "ğŸŒ"
        case .english: return "ğŸ‡ºğŸ‡¸"
        case .korean: return "ğŸ‡°ğŸ‡·"
        case .japanese: return "ğŸ‡¯ğŸ‡µ"
        case .chinese: return "ğŸ‡¨ğŸ‡³"
        case .spanish: return "ğŸ‡ªğŸ‡¸"
        case .french: return "ğŸ‡«ğŸ‡·"
        case .german: return "ğŸ‡©ğŸ‡ª"
        case .russian: return "ğŸ‡·ğŸ‡º"
        case .italian: return "ğŸ‡®ğŸ‡¹"
        }
    }
}

extension Language {
    var description: String {
        switch self {
        case .auto:
            return "Detect language automatically"
        case .english:
            return "English"
        case .korean:
            return "í•œêµ­ì–´ (Korean)"
        case .japanese:
            return "æ—¥æœ¬èª (Japanese)"
        case .chinese:
            return "ä¸­æ–‡ (Chinese)"
        case .spanish:
            return "EspaÃ±ol (Spanish)"
        case .french:
            return "FranÃ§ais (French)"
        case .german:
            return "Deutsch (German)"
        case .russian:
            return "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (Russian)"
        case .italian:
            return "Italiano (Italian)"
        }
    }
}


// ./AISnapStudy/Views/Components/SubjectManagementView.swift

import SwiftUI

struct SubjectManagementView: View {
   @StateObject private var subjectManager = SubjectManager.shared
   @State private var showingAddSubject = false
   @State private var showingDeleteAlert = false
   @State private var showingEditAlert = false
   @State private var showingRestoreAlert = false
   @State private var subjectToDelete: (any SubjectType)?
   @State private var newName = ""
   @State private var selectedSubject: (any SubjectType)?
   
   // ëª¨ë“  í™œì„± ê³¼ëª©ì„ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ ê²°í•©
   private var allSubjects: [SubjectType] {
       var subjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) } as [SubjectType]
       subjects.append(contentsOf: subjectManager.customSubjects)
       return subjects
   }
   
   var body: some View {
       List {
           // Combined Subjects Section
           Section(header: Text("SUBJECTS")) {
               ForEach(allSubjects, id: \.id) { subject in
                   if let defaultSubject = subject as? DefaultSubject {
                       DefaultSubjectRow(
                        subject: defaultSubject,
                        subjectManager: subjectManager,
                        onEdit: { subject in
                            selectedSubject = subject
                            newName = subjectManager.getDisplayName(for: subject)
                            showingEditAlert = true
                        },
                        onDelete: {
                            subjectToDelete = subject
                            showingDeleteAlert = true
                        }
                       )
                   } else if let customSubject = subject as? CustomSubject {
                       CustomSubjectRow(
                           subject: customSubject,
                           subjectManager: subjectManager,
                           onEdit: { subject in
                               selectedSubject = subject
                               newName = subject.name
                               showingEditAlert = true
                           },
                           onDelete: { subject in
                               subjectToDelete = subject
                               showingDeleteAlert = true
                           }
                       )
                   }
               }
               
               Button {
                   showingAddSubject = true
               } label: {
                   Label("Add Subject", systemImage: "plus")
               }
           }
           
           // Recently Deleted Section moved to bottom
           if !subjectManager.hiddenDefaultSubjects.isEmpty {
               Section(header: Text("RECENTLY DELETED")) {
                   Button(action: {
                       showingRestoreAlert = true
                   }) {
                       Label("Restore All Deleted Subjects", systemImage: "arrow.counterclockwise")
                           .foregroundColor(.blue)
                   }
               }
           }
       }
       .navigationTitle("Manage Subjects")
       .sheet(isPresented: $showingAddSubject) {
           AddSubjectView()
       }
       .alert("Rename Subject", isPresented: $showingEditAlert) {
           TextField("Subject Name", text: $newName)
           Button("Cancel", role: .cancel) { }
           Button("Save") {
               if let defaultSubject = selectedSubject as? DefaultSubject {
                   subjectManager.updateDefaultSubjectName(defaultSubject, newName: newName)
               } else if let customSubject = selectedSubject as? CustomSubject {  // ë³€ê²½
                              subjectManager.updateSubject(customSubject, newName: newName)
               }
           }
           .disabled(newName.isEmpty)
       }
       .alert("Delete Subject", isPresented: $showingDeleteAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Delete", role: .destructive) {
               if let subject = subjectToDelete as? DefaultSubject {
                   subjectManager.toggleDefaultSubject(subject)
               } else if let subject = subjectToDelete as? CustomSubject {  // ë³€ê²½
                   subjectManager.deleteSubject(subject)
               }
           }
       } message: {
           Text("Are you sure you want to delete this subject? You can restore it later from the Recently Deleted section.")
       }
       .alert("Restore Subjects", isPresented: $showingRestoreAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Restore All") {
               DefaultSubject.allCases.forEach { subject in
                   if subjectManager.isDeleted(subject) {
                       subjectManager.restoreDeletedSubject(subject)
                   }
               }
           }
       } message: {
           Text("Do you want to restore all deleted subjects?")
       }
       .onAppear {
           print("ğŸ“± SubjectManagementView appeared")
           print("ğŸ“š Active subjects: \(allSubjects.map { $0.displayName })")
           print("ğŸ—‘ï¸ Hidden subjects: \(subjectManager.hiddenDefaultSubjects)")
       }
   }
}

    
// ë³µì› ì„¹ì…˜ì„ ìœ„í•œ ë³„ë„ì˜ ë·°
struct RestoreSection: View {
    @ObservedObject var subjectManager: SubjectManager
    @Binding var showingRestoreAlert: Bool
    
    var body: some View {
        if !subjectManager.hiddenDefaultSubjects.isEmpty {
            Section(header: Text("Recently Deleted Subjects")) {
                Button(action: {
                    showingRestoreAlert = true
                }) {
                    Label("Restore All Deleted Subjects", systemImage: "arrow.counterclockwise")
                        .foregroundColor(.blue)
                }
            }
        }
    }
}

    // ê¸°ë³¸ ê³¼ëª© ì„¹ì…˜ì„ ìœ„í•œ ë³„ë„ì˜ ë·°
struct DefaultSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: (DefaultSubject) -> Void
    
    var body: some View {
        Section(header: Text("Default Subjects")) {
            ForEach(DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }, id: \.id) { subject in
                DefaultSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { _ in onEdit(subject) },  // ìˆ˜ì •ëœ ë¶€ë¶„
                    onDelete: { onDelete(subject) }     // ìˆ˜ì •ëœ ë¶€ë¶„
                )
            }
        }
    }
}

// ì»¤ìŠ¤í…€ ê³¼ëª© ì„¹ì…˜ì„ ìœ„í•œ ë³„ë„ì˜ ë·°
struct CustomSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    @Binding var showingAddSubject: Bool
    let onEdit: (CustomSubject) -> Void  // ë³€ê²½
    let onDelete: (CustomSubject) -> Void  // ë³€ê²½
    
    var body: some View {
        Section(header: Text("Custom Subjects")) {
            ForEach(subjectManager.customSubjects) { subject in
                CustomSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { customSubject in  // ë§¤ê°œë³€ìˆ˜ ì´ë¦„ ë³€ê²½
                        onEdit(customSubject)
                    },
                    onDelete: { customSubject in  // ë§¤ê°œë³€ìˆ˜ ì´ë¦„ ë³€ê²½
                        onDelete(customSubject)
                    }
                )
            }
            
            Button {
                showingAddSubject = true
            } label: {
                Label("Add Subject", systemImage: "plus")
            }
        }
    }
}

struct DefaultSubjectRow: View {
    let subject: DefaultSubject
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subjectManager.getDisplayName(for: subject))
            Spacer()
            
            Button(action: {
                onDelete()
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button(role: .destructive) {
                onDelete()
            } label: {
                Label("Delete", systemImage: "trash")
            }
            
            if subjectManager.modifiedDefaultSubjects[subject.id] != nil {
                Button {
                    subjectManager.resetDefaultSubjectName(subject)
                } label: {
                    Label("Reset Name", systemImage: "arrow.counterclockwise")
                }
            }
        }
    }
}

// ì‚¬ìš©ì ì •ì˜ ê³¼ëª© í–‰ì„ ìœ„í•œ ì»´í¬ë„ŒíŠ¸
struct CustomSubjectRow: View {
    let subject: CustomSubject  // ë³€ê²½
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (CustomSubject) -> Void  // ë³€ê²½
    let onDelete: (CustomSubject) -> Void  // ë³€ê²½
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subject.displayName)
            Spacer()
            
            // ì‚­ì œ ë²„íŠ¼ ì¶”ê°€
            Button(action: {
                onDelete(subject)
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
            
            if !subject.isActive {
                Image(systemName: "eye.slash")
                    .foregroundColor(.gray)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button {
                subjectManager.toggleSubjectActive(subject)
            } label: {
                if subject.isActive {
                    Label("Hide", systemImage: "eye.slash")
                } else {
                    Label("Show", systemImage: "eye")
                }
            }
            
            Button(role: .destructive) {
                onDelete(subject)
            } label: {
                Label("Delete", systemImage: "trash")
            }
        }
    }
}



struct AddSubjectView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var subjectName = ""
    @State private var selectedColor = Color.blue
    @State private var selectedIcon = "book.fill"
    
    let availableIcons = [
        "book.fill", "pencil", "function", "globe",
        "atom", "flask.fill", "keyboard", "music.note"
    ]
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Subject Details")) {
                    TextField("Subject Name", text: $subjectName)
                    
                    ColorPicker("Choose Color", selection: $selectedColor)
                    
                    Picker("Choose Icon", selection: $selectedIcon) {
                        ForEach(availableIcons, id: \.self) { icon in
                            Label(icon, systemImage: icon)
                                .tag(icon)
                        }
                    }
                    .pickerStyle(.menu)
                }
            }
            .navigationTitle("Add Subject")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        subjectManager.addSubject(
                            name: subjectName,
                            icon: selectedIcon
                        )
                        dismiss()
                    }
                    .disabled(subjectName.isEmpty)
                }
            }
        }
    }
}



// ./AISnapStudy/Views/Components/ReviewProblemSetCard.swift

import SwiftUI

struct ReviewProblemSetCard: View {
    let subject: SubjectType
    let problemSet: ProblemSet
    let onDelete: () -> Void
    let onRename: (String) -> Void
    
    @State private var isShowingRenameAlert = false
    @State private var newName = ""
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                    .font(.headline)
                    .foregroundColor(.primary)
                Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
            if problemSet.isFavorite {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
            }
        }
        .padding(10)
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(Color(UIColor.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        )
        .padding(.vertical, 4)
        .contextMenu {
            // Rename option
            Button(action: {
                newName = problemSet.name
                isShowingRenameAlert = true
            }) {
                Label("Rename", systemImage: "pencil")
            }
            
            // Delete option
            Button(role: .destructive, action: onDelete) {
                Label("Delete", systemImage: "trash")
            }
        }
        .alert("Rename Problem Set", isPresented: $isShowingRenameAlert) {
            TextField("New name", text: $newName)
            Button("Cancel", role: .cancel) { }
            Button("Save") {
                if !newName.isEmpty {
                    onRename(newName)
                }
            }
        } message: {
            Text("Enter a new name for this problem set")
        }
    }
}


// ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search Review...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


// ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


// ./AISnapStudy/Views/Components/InputMethodCard.swift


import SwiftUI




// ./AISnapStudy/Views/Components/ImageSelectionSection.swift



import SwiftUI
import PhotosUI
import UIKit

struct ImageSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @FocusState private var isTextFieldFocused: Bool
    @State private var keyboardHeight: CGFloat = 0
  
    var body: some View {
        VStack(spacing: 16) {
            // Quick Text Mode Toggle
            Group {
                VStack(alignment: .leading, spacing: 8) {
                    Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                        .padding()
                        .onAppear {
                            print("ğŸ”„ Toggle initialized with: \(viewModel.useTextExtraction)")
                        }

                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Quick Text Mode")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            if viewModel.useTextExtraction {
                                Image(systemName: "bolt.fill")
                                    .foregroundColor(.yellow)
                                    .imageScale(.small)
                            }
                        }
                        Text("Extracts text for faster processing")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .toggleStyle(SwitchToggleStyle(tint: .blue))
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("ğŸ“± Quick Text Mode changed to: \(newValue)")
                }
            }
            .padding(.horizontal)

            Divider()

            // Input Type Selection Buttons
            HStack(spacing: 12) {
                // Camera Button
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.takePhoto()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Gallery Button
                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.selectFromGallery()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Text Input Button
                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        if viewModel.canUseTextInput {
                            viewModel.onImageOptionSelected()
                            viewModel.toggleTextInput()
                            if viewModel.isTextInputActive {
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isTextFieldFocused = true
                                }
                            } else {
                                isTextFieldFocused = false
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal)

            // Text Input Field
            if viewModel.isTextInputActive {
                VStack(spacing: 12) {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .focused($isTextFieldFocused)
                }
                .padding(.horizontal)
            }

            // Selected Images Display
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(Array(zip(viewModel.selectedImages.indices, viewModel.selectedImages)), id: \.0) { index, image in
                            let imageId = viewModel.getImageId(for: image)
                            SelectedImageCell(
                                image: image,
                                isLoading: viewModel.isLoadingTexts[imageId] ?? false,
                                extractionStatus: viewModel.extractionStatus[imageId],
                                extractedText: viewModel.extractedTexts[imageId],
                                showExtractedText: viewModel.useTextExtraction,
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.horizontal)
                }
            }

            // Generate Button for Selected Content
            if !viewModel.selectedImages.isEmpty || !viewModel.questionText.isEmpty {
                Button {
                    Task {
                        await viewModel.sendAllImages()
                    }
                } label: {
                    HStack {
                        Spacer()
                        Image(systemName: "sparkles")
                        Text("Generate Questions")
                            .fontWeight(.semibold)
                        Spacer()
                    }
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(viewModel.isLoading ? Color.gray : Color.green)
                    )
                    .animation(.easeInOut, value: viewModel.isLoading)
                }
                .buttonStyle(BorderlessButtonStyle())
                .disabled(viewModel.isLoading)
                .padding(.horizontal)
            }
        }
    }
}



// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
   let icon: String
   let isUsed: Bool
   let isDisabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 12) {
               Image(systemName: icon)
                   .font(.system(size: 30))
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 20)
           .foregroundColor(foregroundColor)
           .background(
               RoundedRectangle(cornerRadius: 12)
                   .fill(backgroundColor)
           )
           .overlay(
               RoundedRectangle(cornerRadius: 12)
                   .stroke(strokeColor, lineWidth: 1)
           )
       }
       .disabled(isDisabled)
       .buttonStyle(PlainButtonStyle())
   }
   
   private var foregroundColor: Color {
       if isDisabled {
           return .gray.opacity(0.5)
       }
       return isUsed ? .green : .gray
   }
   
   private var backgroundColor: Color {
       if isDisabled {
           return Color.gray.opacity(0.1)
       }
       return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
   }
   
   private var strokeColor: Color {
       if isDisabled {
           return .clear
       }
       return isUsed ? Color.green.opacity(0.2) : .clear
   }
}

struct SelectedImageCell: View {
    let image: UIImage
    let isLoading: Bool
    let extractionStatus: Bool?
    let extractedText: String?
    let showExtractedText: Bool
    let onDelete: () -> Void
    
    init(
        image: UIImage,
        isLoading: Bool = false,
        extractionStatus: Bool? = nil,
        extractedText: String? = nil,
        showExtractedText: Bool = false,
        onDelete: @escaping () -> Void
    ) {
        self.image = image
        self.isLoading = isLoading
        self.extractionStatus = extractionStatus
        self.extractedText = extractedText
        self.showExtractedText = showExtractedText
        self.onDelete = onDelete
    }
    
    var body: some View {
        ZStack(alignment: .topTrailing) {
            VStack(alignment: .leading, spacing: 4) {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .frame(width: 100, height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                    )
                
                if showExtractedText {
                    if isLoading {
                        HStack(spacing: 4) {
                            ProgressView()
                                .scaleEffect(0.7)
                            Text("Extracting text...")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    } else if let status = extractionStatus {
                        HStack(spacing: 4) {
                            Image(systemName: status ? "doc.text.fill" : "exclamationmark.triangle.fill")
                                .foregroundColor(status ? .green : .orange)
                                .imageScale(.small)
                            Text(status ? "Text extracted" : "Extraction failed")
                                .font(.caption2)
                                .foregroundColor(status ? .green : .orange)
                        }
                    }
                }
            }
            
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 22))
                    .foregroundColor(.white)
                    .background(
                        Circle()
                            .fill(Color.black.opacity(0.5))
                            .frame(width: 24, height: 24)
                    )
            }
            .offset(x: 6, y: -6)
        }
    }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


// ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


// ./AISnapStudy/Views/Components/ReviewCard.swift



import SwiftUI

struct ReviewCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .foregroundColor(question.subject.color)
                    .cornerRadius(8)
                
                Spacer()
            }
            
            // Question Type
            Text(question.type.rawValue.replacingOccurrences(of: "_", with: " ").capitalized)
                .font(.caption)
                .foregroundColor(.secondary)
            
            // Question Text
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .padding(.vertical, 4)
            
            // Footer
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Image(systemName: "arrow.right.circle.fill")
                    .foregroundColor(.blue)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2)
        )
    }
}

#Preview {
    SavedQuestionCard(question: Question(
        id: UUID().uuidString,
        type: .multipleChoice,
        subject: .math,
        question: "Sample Question",
        options: ["A", "B", "C", "D"],
        correctAnswer: "A",
        explanation: "Sample explanation",
        hint: "Sample hint",
        isSaved: true,
        createdAt: Date()
    ))
    .padding()
}


// ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


// ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // ê° ë²„íŠ¼ì— ëŒ€í•œ ë³„ë„ì˜ ì•¡ì…˜ ì •ì˜
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // ì¤‘ìš”: ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë¶„ë¦¬
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // ì¤‘ìš”: ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë¶„ë¦¬
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @StateObject private var studyViewModel: StudyViewModel
    @StateObject private var reviewViewModel: ReviewViewModel  // ì¶”ê°€
    @State private var selectedTab = 0
    @StateObject private var statViewModel: StatViewModel
    
    
    init() {
        let homeVM = HomeViewModel.shared
        
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        
        // StudyViewModel ì´ˆê¸°í™” ì‹œì  ë³€ê²½
        let studyVM = StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        )
        self._studyViewModel = StateObject(wrappedValue: studyVM)
        
        let statVM = StatViewModel(
            context: CoreDataService.shared.viewContext,
            homeViewModel: homeVM,
            studyViewModel: studyVM
        )
        // ReviewViewModel ì´ˆê¸°í™” ì¶”ê°€
        let reviewVM = ReviewViewModel(homeViewModel: homeVM)
        self._reviewViewModel = StateObject(wrappedValue: reviewVM)
        
        // StatViewModelë„ studyViewModel ì°¸ì¡° ì¶”ê°€
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
             context: CoreDataService.shared.viewContext,
             homeViewModel: homeVM,  // homeViewModel ì „ë‹¬
             studyViewModel: studyVM // studyViewModel ì „ë‹¬
         ))
        
        
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
        
        // homeViewModelì— studyViewModel ì„¤ì •
        homeVM.setStudyViewModel(studyVM)
        
        // StatViewModelì„ StudyViewModelì— ì—°ê²°
        studyVM.setStatViewModel(statVM)
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            Group {
                if studyViewModel.isGeneratingQuestions {  // ë¬¸ì œ ìƒì„± ì¤‘ì¼ ë•Œ
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                } else if let problemSet = homeViewModel.selectedProblemSet {
                    StudyView(
                        questions: problemSet.questions,
                        studyViewModel: studyViewModel,
                        selectedTab: $selectedTab
                    )
                } else {
                    Text("No Problem Set Selected")
                }
            }
            .tabItem {
                Label("Study", systemImage: "book.fill")
            }
            .tag(1)
            
            ReviewView(
                viewModel: reviewViewModel,
                selectedTab: $selectedTab  // selectedTab ë°”ì¸ë”© ì „ë‹¬
            )
            .tabItem {
                Label("Review", systemImage: "clock.fill")
            }
            .tag(2)
            
            StatView(
                viewModel: statViewModel,
                selectedTab: $selectedTab,
                correctAnswers: studyViewModel.correctAnswers,
                totalQuestions: studyViewModel.totalQuestions
            )
            .tabItem {
                Label("Stats", systemImage: "chart.bar.fill")
            }
            .tag(3)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { newProblemSet in
            if let problemSet = newProblemSet,
               // Reviewì—ì„œ ì„ íƒëœ ê²½ìš°ì—ë§Œ íƒ­ ì „í™˜
               selectedTab == 2 {  // 2ëŠ” Review íƒ­
                studyViewModel.loadQuestions(problemSet.questions)
                selectedTab = 1  // Study íƒ­ìœ¼ë¡œ ì „í™˜
            }
        }
         .environmentObject(homeViewModel)
    }
}


// ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData


struct StatView: View {
    @ObservedObject var viewModel: StatViewModel
    @Binding var selectedTab: Int
    let correctAnswers: Int
    let totalQuestions: Int
    @EnvironmentObject private var homeViewModel: HomeViewModel
    
    // ì´ˆê¸°í™” í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ ìˆœì„œ ìˆ˜ì •
    init(
        viewModel: StatViewModel,
        selectedTab: Binding<Int>,
        correctAnswers: Int,
        totalQuestions: Int
    ) {
        self.viewModel = viewModel
        self._selectedTab = selectedTab
        self.correctAnswers = correctAnswers
        self.totalQuestions = totalQuestions
    }
    
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                Text("í•™ìŠµ í†µê³„")
                    .font(.title)
                    .padding(.top)
                
                // í˜„ì¬ ìŠ¤íŠ¸ë¦­
                HStack {
                    VStack(alignment: .leading) {
                        Text("í˜„ì¬ ìŠ¤íŠ¸ë¦­")
                            .font(.headline)
                        Text("\(viewModel.streak)ì¼")
                            .font(.title)
                            .foregroundColor(.blue)
                    }
                    Spacer()
                    Image(systemName: "flame.fill")
                        .font(.system(size: 40))
                        .foregroundColor(.orange)
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
                
                // í†µê³„ ê·¸ë¦¬ë“œ
                LazyVGrid(columns: [
                    GridItem(.flexible()),
                    GridItem(.flexible())
                ], spacing: 20) {
                    StatCard(
                        title: "ì´ë²ˆ ì„¸íŠ¸ ì ìˆ˜",
                        value: "\(correctAnswers * 10)ì ",  // correctAnswers ì§ì ‘ ì‚¬ìš©
                        icon: "star.fill",
                        color: .yellow
                    )
                    
                    StatCard(
                        title: "ì •ë‹µë¥ ",
                        value: String(format: "%.1f%%",
                            Double(correctAnswers) / Double(totalQuestions) * 100),
                        icon: "percent",
                        color: .blue
                    )
                    
                    StatCard(
                        title: "ì™„ë£Œí•œ ë¬¸ì œ",
                        value: "\(totalQuestions)ê°œ",
                        icon: "checkmark.circle.fill",
                        color: .green
                    )
                    
                    StatCard(
                        title: "ì •ë‹µ ìˆ˜",
                        value: "\(correctAnswers)ê°œ",
                        icon: "target",
                        color: .red
                    )
                }
                .padding()
                
                Spacer()  // ë‚˜ë¨¸ì§€ ê³µê°„ì„ ì±„ì›€
                
                // ë‹¤ì‹œ í’€ê¸° ë²„íŠ¼ì„ ë§¨ ì•„ë˜ì— ë°°ì¹˜
                Button(action: {
                    viewModel.resetProgress()
                    viewModel.logCurrentQuestionState()
                    withAnimation {
                        selectedTab = 1
                    }
                }) {
                    Text("ë‹¤ì‹œ í’€ê¸°")
                        .font(.headline)
                        .foregroundColor(.white)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(Color.blue)
                        .cornerRadius(10)
                }
                .padding(.horizontal)
                .padding(.bottom, 20)  // í•˜ë‹¨ ì—¬ë°± ì¶”ê°€
            }
        }
    }
}


// ./AISnapStudy/Views/Main/HomeView.swift




import SwiftUI
import Combine
import CoreData

struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Environment(\.managedObjectContext) private var context
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var selectedSubject: DefaultSubject = .math
    @StateObject private var subjectManager = SubjectManager.shared
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Create New Questions Button
                    MainActionButton(
                        title: "Create New Questions",
                        icon: "plus.circle.fill"
                    ) {
                        selectedSubject = .math
                        showQuestionSettings = true
                    }
                    
                    // Review Questions Button
                    MainActionButton(
                        title: "Review Questions",
                        icon: "book.fill"
                    ) {
                        if let problemSet = viewModel.selectedProblemSet {
                            viewModel.setSelectedProblemSet(problemSet)
                            selectedTab = 1
                        }
                    }
                    .disabled(viewModel.selectedProblemSet == nil)
                    .opacity(viewModel.selectedProblemSet == nil ? 0.5 : 1)
                    
                    // ì‚¬ìš©ì ì •ì˜ ê³¼ëª© ë¦¬ìŠ¤íŠ¸ (ì˜µì…˜)
                    if !subjectManager.customSubjects.isEmpty {
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Custom Subjects")
                                .font(.headline)
                                .padding(.horizontal)
                            
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: 12) {
                                    ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                                        CustomSubjectButton(subject: subject) {
                                            showQuestionSettings = true
                                        }
                                    }
                                }
                                .padding(.horizontal)
                            }
                        }
                    }
                }
                .padding(.vertical, 32)
            }
            .navigationTitle("Home")
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab
            )
        }
    }
}

struct CustomSubjectButton: View {
    let subject: CustomSubject  // SubjectManager.CustomSubjectì—ì„œ CustomSubjectë¡œ ë³€ê²½
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                    .foregroundColor(subject.color)
                Text(subject.displayName)
                    .font(.caption)
                    .foregroundColor(.primary)
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(10)
        }
    }
}

// SubjectType í™•ì¥
extension DefaultSubject {
    static var defaultSubject: DefaultSubject {
        return .math
    }
    
    public var displayName: String {
        SubjectManager.shared.modifiedDefaultSubjects[self.id] ?? defaultDisplayName
    }
    
    // ì›ë˜ì˜ displayNameì„ defaultDisplayNameìœ¼ë¡œ ì´ë™
    private var defaultDisplayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
}


// ./AISnapStudy/Views/Main/ReviewView.swift

import SwiftUI



struct ReviewView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @ObservedObject var viewModel: ReviewViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var showSubjectManagement = false
    @State private var searchText = ""
    @State private var selectedSubject: SubjectType?
    @Binding var selectedTab: Int  // ìƒˆë¡œ ì¶”ê°€
   
    // ì´ˆê¸°í™” êµ¬ë¬¸ ìˆ˜ì •
    public init(viewModel: ReviewViewModel, selectedTab: Binding<Int>) {
        self.viewModel = viewModel
        self._selectedTab = selectedTab
    }
    
    private var visibleSubjects: [SubjectType] {
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        ğŸ“š ReviewView - Visible Subjects:
        â€¢ Total Subjects: \(subjects.count)
        â€¢ Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        â€¢ Active Custom Subjects: \(customSubjects.map { $0.displayName })
        â€¢ Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
   
   private var allSubjects: [SubjectType] {
       var subjects: [SubjectType] = []
       
       let activeDefaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
       subjects.append(contentsOf: activeDefaultSubjects)
       
       let activeCustomSubjects = subjectManager.customSubjects.filter { $0.isActive }
       subjects.append(contentsOf: activeCustomSubjects)
       
       print("ğŸ“š Review - Active Default Subjects: \(activeDefaultSubjects.map { $0.displayName })")
       print("ğŸ“š Review - Active Custom Subjects: \(activeCustomSubjects.map { $0.displayName })")
       print("ğŸ”’ Review - Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)")
       
       return subjects
   }
   
    var body: some View {
        NavigationView {
            VStack(spacing: 16) {
                ScrollView {
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 16) {
                        // allSubjectsë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ê³¼ëª© í‘œì‹œ
                        ForEach(visibleSubjects, id: \.id) { subject in
                            NavigationLink(
                                destination: ProblemSetsListView(
                                    subject: subject,
                                    problemSets: filterProblemSets(subject: subject),
                                    selectedTab: $selectedTab  // selectedTab ì „ë‹¬
                                )
                            ) {
                                SubjectCardView(
                                    subject: subject,
                                    problemSetCount: filterProblemSets(subject: subject).count
                                )
                            }
                            .onAppear {
                                print("""
                            ğŸ“± Subject Card Appeared:
                            â€¢ Subject: \(subject.displayName)
                            """)
                            }
                        }
                    }
                    .padding()
                }
                .navigationTitle("Review")
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: {
                            showSubjectManagement = true
                        }) {
                            Image(systemName: "slider.horizontal.3")
                                .foregroundColor(.blue)
                        }
                    }
                }
                .sheet(isPresented: $showSubjectManagement) {
                    NavigationView {
                        SubjectManagementView()
                            .navigationTitle("Manage Subjects")
                            .navigationBarItems(
                                trailing: Button("Done") {
                                    showSubjectManagement = false
                                }
                            )
                    }
                }
                
            }}
        .onAppear {
            print("ğŸ“± ReviewView appeared")
            print("ğŸ“š Available subjects: \(visibleSubjects.map { $0.displayName })")
        }
    }
    // í•„í„°ë§ í•¨ìˆ˜ ìˆ˜ì •
    private func filterProblemSets(subject: SubjectType) -> [ProblemSet] {
        return homeViewModel.problemSets.filter { problemSet in
            if let defaultSubject = subject as? DefaultSubject {
                return problemSet.subjectType == "default" &&
                       problemSet.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return problemSet.subjectType == "custom" &&
                       problemSet.subjectId == customSubject.id
            }
            return false
        }
    }
}

struct SubjectCardView: View {
   let subject: SubjectType
   let problemSetCount: Int
   
   var body: some View {
       VStack(spacing: 12) {
           Image(systemName: subject.icon)
               .font(.system(size: 32))
               .foregroundColor(subject.color)
           
           Text(subject.displayName)
               .font(.headline)
               .foregroundColor(.primary)
               .lineLimit(1)
           
           Text("\(problemSetCount) sets")
               .font(.caption)
               .foregroundColor(.secondary)
       }
       .frame(maxWidth: .infinity)
       .padding(.vertical, 24)
       .background(
           RoundedRectangle(cornerRadius: 16)
               .fill(subject.color.opacity(0.1))
               .overlay(
                   RoundedRectangle(cornerRadius: 16)
                       .stroke(subject.color.opacity(0.2), lineWidth: 1)
               )
       )
       .contentShape(Rectangle())
   }
}

// SavedQuestionsRow ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬
struct SavedQuestionsRow: View {
    let savedQuestions: [Question]
    let homeViewModel: HomeViewModel
    
    var body: some View {
        NavigationLink(
            destination: SavedQuestionsView(
                questions: savedQuestions,
                homeViewModel: homeViewModel
            )
        ) {
            HStack {
                Image(systemName: "bookmark.fill")
                    .foregroundColor(.blue)
                Text("Saved Questions")
                    .font(.headline)
                Spacer()
                Text("\(savedQuestions.count)")
                    .foregroundColor(.secondary)
            }
        }
    }
}

// SubjectRow ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬
struct SubjectListRow: View {
    let subject: SubjectType
    let problemSets: [ProblemSet]
    let subjectManager: SubjectManager  // SubjectManager ì¸ìŠ¤í„´ìŠ¤ í•„ìš”
    @Binding var selectedTab: Int  // ì¶”ê°€
    
    var body: some View {
        if !subjectManager.isDeleted(subject.id) {
            NavigationLink(
                destination: ProblemSetsListView(
                    subject: subject,
                    problemSets: filterProblemSets(subject: subject, problemSets: problemSets),
                    selectedTab: $selectedTab  // ì¶”ê°€
                )
            ) {
                HStack {
                    Image(systemName: subject.icon)
                        .foregroundColor(subject.color)
                    // ì—¬ê¸°ë¥¼ ìˆ˜ì • - subject.displayName ëŒ€ì‹  subjectManager.getDisplayName ì‚¬ìš©
                    if let defaultSubject = subject as? DefaultSubject {
                        Text(subjectManager.getDisplayName(for: defaultSubject))
                    } else {
                        Text(subject.displayName)
                    }
                    Spacer()
                    Image(systemName: "chevron.right")
                        .foregroundColor(.gray)
                        .font(.system(size: 14))
                }
            }
        }
    }
    
    private func filterProblemSets(subject: SubjectType, problemSets: [ProblemSet]) -> [ProblemSet] {
        return problemSets.filter { problemSet in
            if let defaultSubject = subject as? DefaultSubject {
                return problemSet.subjectType == "default" &&
                       problemSet.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return problemSet.subjectType == "custom" &&
                       problemSet.subjectId == customSubject.id
            }
            return false
        }
    }
}
// ReviewViewìš© DefaultSubjectsSection ì»´í¬ë„ŒíŠ¸
struct ReviewDefaultSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let problemSets: [ProblemSet]
    @ObservedObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int  // ì¶”ê°€
    
    var body: some View {
        Section(header: Text("Default Subjects")) {
            ForEach(DefaultSubject.allCases, id: \.id) { subject in
                let filteredSets = problemSets.filter {
                    $0.subjectType == "default" &&
                    $0.subject.rawValue == subject.rawValue
                }.sorted(by: { $0.createdAt > $1.createdAt })
                
                NavigationLink(
                    destination: ProblemSetsListView(
                        subject: subject,
                        problemSets: filteredSets,
                        selectedTab: $selectedTab  // ì¶”ê°€
                    )
                ) {
                    SubjectRow(subject: subject)
                }
            }
        }
    }
}

// ReviewViewìš© CustomSubjectsSection ì»´í¬ë„ŒíŠ¸
struct ReviewCustomSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let problemSets: [ProblemSet]
    @ObservedObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int  // ì¶”ê°€
    
    var body: some View {
        Section(header: Text("Custom Subjects")) {
            ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                let filteredSets = problemSets.filter { $0.subject.displayName == subject.displayName }
                    .sorted(by: { $0.createdAt > $1.createdAt })
                
                NavigationLink(
                    destination: ProblemSetsListView(
                        subject: subject,
                        problemSets: filteredSets,
                        selectedTab: $selectedTab  // ì¶”ê°€
                    )
                ) {
                    SubjectRow(subject: subject)
                }
            }
        }
    }
}

extension SubjectType {
    func isDeleted(in subjectManager: SubjectManager) -> Bool {
        if let defaultSubject = self as? DefaultSubject {
            return subjectManager.isDeleted(defaultSubject)
        }
        return false
    }
}

// ProblemSetsListViewëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€


struct ProblemSetsListView: View {
    let subject: SubjectType
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var isShowingStudyView = false
    @State private var isShowingDeleteAlert = false
    @State private var problemSetToDelete: ProblemSet?
    @Binding var selectedTab: Int  // ìƒˆë¡œ ì¶”ê°€
    
    init(subject: SubjectType,
         problemSets: [ProblemSet],
         selectedTab: Binding<Int>) {  // ì´ˆê¸°í™” êµ¬ë¬¸ì— selectedTab ì¶”ê°€
        self.subject = subject
        self.problemSets = problemSets
        self._selectedTab = selectedTab
    }
    
    var body: some View {
        List {
            ForEach(problemSets) { problemSet in
                ProblemSetRow(
                    problemSet: problemSet,
                    isShowingStudyView: $isShowingStudyView,
                    isShowingDeleteAlert: $isShowingDeleteAlert,
                    problemSetToDelete: $problemSetToDelete,
                    selectedTab: $selectedTab  // selectedTab ì „ë‹¬
                )
            }
        }
        .listStyle(InsetGroupedListStyle())
        .navigationTitle("\(subject.displayName) Sets")
        .alert("Delete Problem Set", isPresented: $isShowingDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let problemSet = problemSetToDelete {
                    Task {
                        await homeViewModel.deleteProblemSet(problemSet)
                    }
                }
            }
        } message: {
            Text("Are you sure you want to delete this problem set? This action cannot be undone.")
        }
    }
}

// ë³„ë„ì˜ row ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬
struct ProblemSetRow: View {
    let problemSet: ProblemSet
    @Binding var isShowingStudyView: Bool
    @Binding var isShowingDeleteAlert: Bool
    @Binding var problemSetToDelete: ProblemSet?
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var refreshTrigger = RefreshTrigger()
    @Binding var selectedTab: Int  // ìƒˆë¡œ ì¶”ê°€
    
    // ì´ë¦„ ë³€ê²½ì„ ìœ„í•œ ìƒíƒœ ë³€ìˆ˜
    @State private var displayName: String
    
    init(problemSet: ProblemSet,
         isShowingStudyView: Binding<Bool>,
         isShowingDeleteAlert: Binding<Bool>,
         problemSetToDelete: Binding<ProblemSet?>,
         selectedTab: Binding<Int>) {  // ì´ˆê¸°í™” êµ¬ë¬¸ì— selectedTab ì¶”ê°€
        self.problemSet = problemSet
        self._isShowingStudyView = isShowingStudyView
        self._isShowingDeleteAlert = isShowingDeleteAlert
        self._problemSetToDelete = problemSetToDelete
        self._selectedTab = selectedTab  // ìƒˆë¡œ ì¶”ê°€
        self._displayName = State(initialValue: problemSet.name)
    }
    
    var body: some View {
        Button(action: {
            Task {
                // ProblemSet ì„¤ì •
                homeViewModel.setSelectedProblemSet(problemSet)
                
                // StudyViewModelì— ì§ì ‘ questions ì„¤ì •
                if let studyViewModel = homeViewModel.studyViewModel {
                    // ìƒíƒœ ë¦¬ì…‹
                    await studyViewModel.resetState()
                    // ë¬¸ì œ ë¡œë“œ
                    studyViewModel.loadQuestions(problemSet.questions)
                    
                    // íƒ­ ì „í™˜ ë° UI ì—…ë°ì´íŠ¸
                    await MainActor.run {
                        withAnimation {
                            selectedTab = 1  // Study íƒ­ìœ¼ë¡œ ì „í™˜
                            isShowingStudyView = true
                        }
                    }
                }
            }
        }) {
            ReviewProblemSetCard(
                subject: problemSet.resolvedSubject,
                problemSet: problemSet.copy(withName: displayName),
                onDelete: {
                    problemSetToDelete = problemSet
                    isShowingDeleteAlert = true
                },
                onRename: { newName in
                    Task {
                        await homeViewModel.renameProblemSet(problemSet, newName: newName)
                        // UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                        await MainActor.run {
                            displayName = newName
                        }
                    }
                }
            )
        }
        .onChange(of: problemSet.name) { newName in
            displayName = newName
        }
    }
}

extension ProblemSet {
    func copy(withName newName: String) -> ProblemSet {
        ProblemSet(
            id: self.id,
            subject: self.subject,
            subjectType: self.subjectType,
            subjectId: self.subjectId,
            subjectName: self.subjectName,
            questions: self.questions,
            createdAt: self.createdAt,
            educationLevel: self.educationLevel,
            name: newName  // ìƒˆ ì´ë¦„ ì‚¬ìš©
        )
    }
}


// StudyView destinationì„ ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬
// StudyDestinationView (ê¸°ì¡´ê³¼ ë™ì¼)
struct StudyDestinationView: View {
    let problemSet: ProblemSet
    @EnvironmentObject var homeViewModel: HomeViewModel
    
    var body: some View {
        Group {
            if let studyViewModel = homeViewModel.studyViewModel {
                StudyView(
                    questions: problemSet.questions,
                    studyViewModel: studyViewModel,
                    selectedTab: .constant(1)
                )
            } else {
                Text("Study ViewModel not available")
            }
        }
    }
}


class RefreshTrigger: ObservableObject {
    @Published var id = UUID()
    
    func refresh() {
        id = UUID()
    }
}


// ê³¼ëª© í–‰ ì»´í¬ë„ŒíŠ¸
struct SubjectRow: View {
    // Style enum to handle different display modes
    enum Style {
        case navigation
        case management
    }
    
    let subject: SubjectType
    let style: Style
    let isDefault: Bool
    
    // Default initializer for navigation style
    init(subject: SubjectType) {
        self.subject = subject
        self.style = .navigation
        self.isDefault = false
    }
    
    // Management style initializer
    init(subject: SubjectType, isDefault: Bool) {
        self.subject = subject
        self.style = .management
        self.isDefault = isDefault
    }
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
                .font(style == .management ? .title2 : .body)
            
            Text(subject.displayName)
                .foregroundColor(.primary)
                .font(style == .management ? .body : .headline)
                .padding(.leading, style == .management ? 0 : 8)
            
            if style == .management {
                if isDefault {
                    Spacer()
                    Text("Default")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(.vertical, style == .management ? 8 : 0)
    }
}


// ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
    @State private var isCorrect: Bool? = nil  // ì´ ë¶€ë¶„ì´ ì¤‘ìš”í•©ë‹ˆë‹¤
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // ì¶”ê°€
   @State private var previewIsCorrect: Bool? = nil        // ì¶”ê°€
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
    var body: some View {
        VStack {
            if studyViewModel.isGeneratingQuestions {
                VStack(spacing: 16) {
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.white)
                    .transition(.opacity)
                    
                    if !studyViewModel.generatedQuestions.isEmpty {
                        ScrollView {
                            LazyVStack(spacing: 12) {
                                ForEach(studyViewModel.generatedQuestions) { question in
                                    QuestionPreviewCard(
                                        question: question,
                                        selectedAnswer: $previewSelectedAnswer,
                                        isCorrect: $previewIsCorrect,
                                        onAnswerSelected: { correct in
                                            print("Answer selected: \(correct)")
                                        }
                                    )
                                    .transition(.slide)
                                }
                            }
                            .padding()
                        }
                    }
                }
            } else if !studyViewModel.hasQuestions {
                Text("No questions available")
                    .font(.title3)
                    .foregroundColor(.gray)
            } else {
                VStack {
                    Spacer()
                        .frame(height: 20)
                    
                    ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                               total: Double(studyViewModel.totalQuestions))
                        .progressViewStyle(CustomProgressViewStyle())
                        .padding(.horizontal, 20)
                        .padding(.bottom, 10)
                    
                    Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.secondary)
                        .padding(.bottom, 20)
                    
                    if !studyViewModel.hasQuestions {
                        Text("No questions available")
                            .font(.title3)
                            .foregroundColor(.gray)
                    } else {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 20) {
                                if let currentQuestion = studyViewModel.currentQuestion {
                                    switch currentQuestion.type {
                                    case .multipleChoice:
                                        MultipleChoiceView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect
                                        )
                                        
                                    case .trueFalse:
                                        TrueFalseView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect  // ì—¬ê¸° isCorrect ë°”ì¸ë”©ì´ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
                                        )
                                    }
                                    
                                    if showExplanation && studyViewModel.showExplanation {
                                        ExplanationView(explanation: currentQuestion.explanation)
                                    }
                                }
                            }
                            .padding()
                        }
                        
                        VStack {
                            Divider()
                            
                            HStack(spacing: 12) {
                                if studyViewModel.showExplanation {
                                    UtilityButtons(
                                        showExplanation: $showExplanation,
                                        isSaved: $isSaved,
                                        studyViewModel: studyViewModel
                                    )
                                }
                                
                                ActionButton(
                                    viewModel: studyViewModel,
                                    selectedTab: $selectedTab,
                                    isCorrect: $isCorrect,
                                    showExplanation: $showExplanation
                                )
                            }
                            .padding()
                            .background(Color(UIColor.systemBackground))
                        }
                    }
                }
            }
        }
        .onAppear {
            if let currentQuestion = studyViewModel.currentQuestion {
                isSaved = currentQuestion.isSaved
            }
        }
        .onChange(of: studyViewModel.currentQuestion) { newQuestion in
            if let question = newQuestion {
                isSaved = question.isSaved
            }
        }
    }
}

struct CustomProgressViewStyle: ProgressViewStyle {
    func makeBody(configuration: Configuration) -> some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 12)
                
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.blue)
                    .frame(width: CGFloat(configuration.fractionCompleted ?? 0) * geometry.size.width,
                           height: 12)
            }
        }
        .frame(height: 12)
    }
}

// ìƒˆë¡œ ì¶”ê°€ëœ ë¯¸ë¦¬ë³´ê¸° ì¹´ë“œ ë·°
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // ìƒë‹¨ ì •ë³´
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
          }
          
          // ì§ˆë¬¸
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // ë‹µë³€ ì˜µì…˜
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ë“¤ì€ ìœ ì§€
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil  // ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°ˆ ë•Œ ë¦¬ì…‹
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               if let currentQuestion = viewModel.currentQuestion,
                  let selectedAnswer = viewModel.selectedAnswer {
                   isCorrect = currentQuestion.correctAnswer.lowercased() == selectedAnswer.lowercased()
               }
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}

struct GeneratingQuestionsOverlay: View {
    let questionCount: Int  // í•„ìš”í•˜ì§€ë§Œ ì‚¬ìš©í•˜ì§€ ì•Šì„ ë§¤ê°œë³€ìˆ˜
    @State private var rotation: Double = 0
    @State private var dotScale: CGFloat = 1.0
    @State private var currentTipIndex = 0
    let timer = Timer.publish(every: 5, on: .main, in: .common).autoconnect()
    
    var body: some View {
        ZStack {
            // ë°°ê²½ìƒ‰ì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
            Color.white
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 30) {
                // Main Animation Circle
                ZStack {
                    // Outer rotating circle
                    Circle()
                        .stroke(lineWidth: 6)
                        .frame(width: 200, height: 200)
                        .foregroundColor(.blue.opacity(0.3))
                        .rotationEffect(.degrees(rotation))
                    
                    // Inner gradient circle
                    Circle()
                        .stroke(
                            LinearGradient(
                                gradient: Gradient(colors: [.blue, .purple]),
                                startPoint: .top,
                                endPoint: .bottom
                            ),
                            lineWidth: 10
                        )
                        .frame(width: 180, height: 180)
                        .rotationEffect(.degrees(-rotation))
                    
                    // Center content - í…ìŠ¤íŠ¸ ìƒ‰ìƒì„ ê²€ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ê³  Questions ìˆ˜ í‘œì‹œ ì œê±°
                    VStack(spacing: 8) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 40))
                            .foregroundColor(.blue)
                        Text("Generating")
                            .font(.title)
                            .foregroundColor(.black)  // ê²€ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½
                        Text("Questions")
                            .font(.title2)
                            .foregroundColor(.black)  // ê²€ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½
                    }
                }
                .onAppear {
                    withAnimation(
                        .linear(duration: 4)
                        .repeatForever(autoreverses: false)
                    ) {
                        rotation = 360
                    }
                }
                
                // Animated Dots
                HStack(spacing: 8) {
                    ForEach(0..<3) { index in
                        Circle()
                            .fill(Color.blue)
                            .frame(width: 12, height: 12)
                            .scaleEffect(dotScale)
                            .animation(
                                .easeInOut(duration: 0.6)
                                .repeatForever()
                                .delay(Double(index) * 0.2),
                                value: dotScale
                            )
                    }
                }
                .onAppear {
                    dotScale = 0.5
                }
                
                // Tips Section
                VStack(spacing: 12) {
                    Text(tips[currentTipIndex])
                        .font(.headline)
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                        .frame(height: 60)
                        .transition(.opacity.combined(with: .slide))
                        .id(currentTipIndex)
                        .animation(.easeInOut, value: currentTipIndex)
                    
                    // Progress Dots
                    HStack(spacing: 6) {
                        ForEach(0..<tips.count) { index in
                            Circle()
                                .fill(index == currentTipIndex ? Color.white : Color.gray)
                                .frame(width: 8, height: 8)
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 15)
                        .fill(Color.blue.opacity(0.8))
                )
            }
            .padding(30)
        }
        .onReceive(timer) { _ in
            withAnimation {
                currentTipIndex = (currentTipIndex + 1) % tips.count
            }
        }
    }
    
    private let tips = [
        "Creating personalized questions just for you...",
        "Analyzing content to ensure the best learning experience...",
        "Getting ready to challenge your knowledge...",
        "Preparing explanations to help you understand better...",
        "Almost there! Your questions are being finalized..."
    ]
}

struct GeneratedQuestionPreviewCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: question.type == .multipleChoice ? "list.bullet.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(.blue)
                Text(question.type == .multipleChoice ? "Multiple Choice" : "True/False")
                    .font(.caption)
                    .foregroundColor(.blue)
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .foregroundColor(.primary)
        }
        .padding()
        .background(Color.white)
        .cornerRadius(10)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
    }
}


// ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 512 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.8
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // ì´ë¯¸ì§€ì˜ í¬ê¸°ë¥¼ ìµœëŒ€ ì¹˜ìˆ˜ì— ë§ê²Œ ì¡°ì •
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // ì„¤ì •ëœ í’ˆì§ˆë¡œ ì••ì¶•
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // í¬ê¸°ê°€ ìµœëŒ€ íŒŒì¼ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš°, í’ˆì§ˆì„ ë‚®ì¶°ì„œ ì¶”ê°€ ì••ì¶• ì‹œë„
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera),
                  UIImagePickerController.isCameraDeviceAvailable(.rear) else {
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetailì˜ ì„¤ì • ê°’ì„ ì‚¬ìš©
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // ì˜ˆì¸¡ í† í° ìˆ˜ ê³„ì‚°
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        ğŸ“Š Image Optimization Results:
        â€¢ Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        â€¢ Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        â€¢ Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        â€¢ Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        â€¢ Estimated Tokens: \(estimatedTokens)
        â€¢ Processing Time: \(String(format: "%.3f", processingTime))s
        â€¢ Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}



// ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
    case fileProviderAccessDenied
    case fileCoordinationFailed
}

public class StorageService {
    // MARK: - Properties
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let fileCoordinator = NSFileCoordinator()
    private let fileManager = FileManager.default
    
    // MARK: - Constants
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    private let maxRetryCount = 3
    private let retryDelay: TimeInterval = 0.5
    
    // MARK: - File System
    private var documentDirectory: URL? {
        fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
    }
    
    private func getDirectoryURL(for type: String) -> URL? {
        documentDirectory?.appendingPathComponent(type)
    }
    
    // MARK: - FileProvider Handling
    private func handleFileProviderAccess<T>(_ operation: @escaping (URL) throws -> T) throws -> T {
        guard checkFileProviderAuthorization() else {
            throw StorageError.fileProviderAccessDenied
        }
        
        guard let url = documentDirectory else {
            throw StorageError.invalidData
        }
        
        var coordinationError: NSError?
        var result: T?
        var operationError: Error?
        
        fileCoordinator.coordinate(writingItemAt: url, options: .forMoving, error: &coordinationError) { coordinatedURL in
            do {
                result = try operation(coordinatedURL)
            } catch {
                operationError = error
            }
        }
        
        if let error = coordinationError {
            throw StorageError.fileCoordinationFailed
        }
        
        if let error = operationError {
            throw error
        }
        
        return result!
    }
    
    private func checkFileProviderAuthorization() -> Bool {
        // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì ì ˆí•œ ê¶Œí•œ ì²´í¬ ë¡œì§ êµ¬í˜„
        return true
    }
    
    // MARK: - Error Handling
    private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
        do {
            return try operation()
        } catch let error as NSError {
            Logger.logError(error, category: "FileOperation")
            
            // ì¬ì‹œë„ ë¡œì§
            for attempt in 1...maxRetryCount {
                Logger.log("Retrying operation (attempt \(attempt)/\(maxRetryCount))", category: "FileOperation")
                do {
                    return try operation()
                } catch {
                    if attempt == maxRetryCount {
                        throw error
                    }
                    Thread.sleep(forTimeInterval: retryDelay)
                }
            }
            throw error
        }
    }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var problemSets = try self.getProblemSets()
                problemSets.append(problemSet)
                
                let data = try self.encoder.encode(problemSets)
                self.defaults.set(data, forKey: self.problemSetsKey)
            }
        }
    }
    
    public func getProblemSets() throws -> [ProblemSet] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: problemSetsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([ProblemSet].self, from: data)
            } catch {
                Logger.logError(error, category: "ProblemSets")
                throw StorageError.loadFailed
            }
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                sessions.append(session)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: studySessionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([StudySession].self, from: data)
            } catch {
                Logger.logError(error, category: "StudySessions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.deleteFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                
                guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
                    throw StorageError.notFound
                }
                
                sessions.remove(at: index)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func saveQuestion(_ question: Question) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var savedQuestions = try self.getSavedQuestions()
                savedQuestions.append(question)
                
                let data = try self.encoder.encode(savedQuestions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: savedQuestionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([Question].self, from: data)
            } catch {
                Logger.logError(error, category: "SavedQuestions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func saveQuestions(_ questions: [Question]) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                let data = try self.encoder.encode(questions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("ğŸ“ [\(category)] \(message)")
        #endif
    }
    
    static func logError(_ error: Error, category: String) {
        #if DEBUG
        print("âŒ [\(category)] Error: \(error.localizedDescription)")
        #endif
    }
}


// ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    private let apiKey: String
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    
    static let shared: OpenAIService = {
        do {
            return try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAIService: \(error)")
        }
    }()
    
    
    func sendTextExtractionResult(_ extractedText: String) async throws -> String {
        print("ğŸ”„ Processing extracted text in OpenAI service...")
        print("ğŸ“ Input text: \(extractedText)")
        
        let url = URL(string: baseURL)!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        let body: [String: Any] = [
            "model": "gpt-4o",
            "messages": [
                ["role": "system", "content": "You are an expert at analyzing extracted text."],
                ["role": "user", "content": extractedText]
            ],
            "temperature": 0.7,
            "max_tokens": 2000
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        print("ğŸŒ Sending request to OpenAI API...")
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("âŒ Invalid response received")
            throw NetworkError.invalidResponse
        }
        
        print("ğŸ“¡ Response status code: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            print("âŒ API request failed with status code: \(httpResponse.statusCode)")
            throw NetworkError.apiError("API request failed with status \(httpResponse.statusCode)")
        }

        let result = String(data: data, encoding: .utf8) ?? "No response"
        print("âœ… OpenAI processing completed: \(result)")
        return result
    }


        func sendImageDataToOpenAI(_ imageData: Data) async throws {
            let url = URL(string: "https://api.openai.com/v1/images")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("Bearer YOUR_API_KEY", forHTTPHeaderField: "Authorization")

            let body: [String: Any] = [
                "image": imageData.base64EncodedString(),
                "purpose": "image-analysis"
            ]

            request.httpBody = try JSONSerialization.data(withJSONObject: body, options: [])

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw NSError(domain: "OpenAIService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to get valid response from OpenAI API"])
            }

            let result = String(data: data, encoding: .utf8) ?? "No response"
            print("âœ… Image sent to OpenAI. Response: \(result)")
        }
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public ìœ¼ë¡œ ë³€ê²½
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init ì¶”ê°€
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public ìœ¼ë¡œ ë³€ê²½
        let subject: DefaultSubject  // Subject -> DefaultSubjectë¡œ ë³€ê²½
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        let language: Language
        
        public init(    // public init ì¶”ê°€
            subject: DefaultSubject,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int],
            language: Language
        ) {
            self.subject = subject
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
            self.language = language
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("âŒ Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("ğŸ“¸ Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("âŒ Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }
    
    // StreamResponse êµ¬ì¡°ì²´ë„ í•„ìš”í•©ë‹ˆë‹¤
    private struct StreamResponse: Codable {
        struct Choice: Codable {
            struct Delta: Codable {
                let content: String?
            }
            let delta: Delta
        }
        let choices: [Choice]
    }

    // extractCompleteQuestion í•¨ìˆ˜ë„ ì¶”ê°€
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSONì´ ì™„ì „í•œ ê°ì²´ì¸ì§€ í™•ì¸
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSONì´ ì•„ì§ ì™„ì„±ë˜ì§€ ì•Šì•˜ê±°ë‚˜ íŒŒì‹±í•  ìˆ˜ ì—†ëŠ” ê²½ìš°
            return nil
        }
    }
    
    // ë‚˜ë¨¸ì§€ private êµ¬ì¡°ì²´ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Initialization
    init() throws {
        self.apiKey = try ConfigurationManager.shared.getValue(for: "OpenAIAPIKey")
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("âœ… Retrieved questions from cache")
            return cachedQuestions
        }
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // ì´ë¯¸ì§€ ë˜ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ëŠ” íƒœìŠ¤í¬ ì¶”ê°€
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            let questions = try await self.performQuestionGeneration(
                input: processedInput,                     // ì´ë¯¸ì§€ ë°ì´í„° ì „ë‹¬
                textInput: processedTextInput,             // í…ìŠ¤íŠ¸ ë°ì´í„° ì „ë‹¬
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(
        _ subject: SubjectType,
        isImageInput: Bool,
        isExtractedText: Bool,  // ìƒˆë¡œìš´ ë§¤ê°œë³€ìˆ˜ ì¶”ê°€
        educationLevel: EducationLevel,
        language: Language
    ) -> SubjectPrompt {
        let subjectName = if let customSubject = subject as? CustomSubject {  // ìˆ˜ì •ëœ ë¶€ë¶„
            customSubject.displayName
        } else {
            subject.displayName
        }
        
        let languageInstructionText = language == .auto ?
            "Generate questions in the exact same language as the input text." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.displayName) language.
            DO NOT use the input text's language. Even if the input is in another language, the output must be in \(language.displayName) only.
            """
        
        let languageInstructionImage = language == .auto ?
            "Generate questions in the same language as any visible text in the image." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.displayName) (\(language.rawValue)).
            DO NOT use the language of visible text in the image. All output must be in \(language.displayName) only.
            """

        // ìˆœìˆ˜ ì´ë¯¸ì§€ ê¸°ë°˜ ì…ë ¥
        if isImageInput && !isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained, image-based questions.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as visible text in the image" : language.displayName)
                    - Ensure consistent language usage throughout all content.
                    - Translate concepts accurately without losing meaning.
                    
                    FORMATTING REQUIREMENTS:
                    - Each question must be self-contained with all necessary context provided.
                    - Avoid ambiguous or overly broad questions.
                    - Ensure True/False answers are always lowercase ("true" or "false").
                    - Do not translate True/False answers into other languages.

                    ERROR PREVENTION:
                    - Avoid using "Yes", "No", or "That's correct" for True/False questions.
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Create high-quality, context-rich questions based on the given image.
                    \(languageInstructionImage)
                    Each question must include detailed explanations and hints.

                    Examples of good questions:
                    - "If the sum of the angles in a triangle is 180Â°, and one angle is 90Â°, what are the other two angles?"
                    - "The Roman Empire declined for many reasons. Which of the following factors contributed the most to its fall?"
                    
                    Examples of bad questions:
                    - "What does the text explain?"
                    - "Is this image interesting?"
                    """
            )
        }
        // ì´ë¯¸ì§€ì—ì„œ ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê¸°ë°˜ ì…ë ¥
        else if isImageInput && isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained questions based on extracted text from images.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as the extracted text" : language.displayName)
                    - Maintain consistent language usage across all questions, answers, and explanations.
                    - Preserve technical terms and proper nouns during translation.

                    FORMATTING REQUIREMENTS:
                    - Create questions with all necessary context included.
                    - True/False answers must be "true" or "false" (lowercase).
                    - Avoid "wh-" questions like "what", "who", or "how".

                    ERROR PREVENTION:
                    - Do not use variations like "Yes", "No", or "That's correct" for True/False questions.
                    - Avoid ambiguity in technical or academic concepts.
                    """,
                userPromptTemplate: """
                    Generate accurate and context-aware questions from the extracted text in the image.
                    \(languageInstructionImage)
                    Include hints and explanations for each question.

                    Examples of good questions:
                    - "The fall of the Roman Empire is often attributed to external invasions. Which of the following best explains this?"
                    - "In the Pythagorean theorem, if aÂ² + bÂ² = cÂ², what does 'c' represent in a right triangle?"

                    Examples of bad questions:
                    - "What does this text mean?"
                    - "Explain the context."
                    """
            )
        }
        // í…ìŠ¤íŠ¸ ê¸°ë°˜ ì…ë ¥
        else {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating questions for \(educationLevel.displayName) students.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as input text" : language.displayName)
                    - Maintain consistent language usage in all content.
                    - Translate concepts accurately and preserve their original meaning.

                    FORMATTING REQUIREMENTS:
                    - Include all necessary context within the questions.
                    - Avoid overly broad or simplistic questions.
                    - True/False answers must be "true" or "false" (lowercase) and must not be translated.

                    ERROR PREVENTION:
                    - Do not use "Yes", "No", or "That's correct" for True/False answers.
                    - Ensure clarity and precision in question phrasing.
                    """,
                userPromptTemplate: """
                    Create thoughtful and context-rich questions based on the input text.
                    \(languageInstructionText)
                    Create National Assessment of Educational Progress questions for \(educationLevel.displayName) school students
                    Include hints and detailed explanations.

                    Examples of good questions:
                    - "The Renaissance was a cultural movement in Europe. Which of the following innovations was NOT developed during this period?"
                    - "If a car travels 60 miles in one hour, how far will it travel in three hours at the same speed?"

                    Examples of bad questions:
                    - "What is the capital of France?"
                    - "Explain this text."
                    """
            )
        }
    }

    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            isExtractedText: !input.isImage && input.content.count > 0,  // í…ìŠ¤íŠ¸ ì¶”ì¶œ ì—¬ë¶€ í™•ì¸
            educationLevel: parameters.educationLevel,
            language: parameters.language
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": ["type": "array", "items": ["type": "string"]],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint" ]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        print("ğŸ¤– OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages ë°°ì—´ì„ ë¯¸ë¦¬ ì„ ì–¸
        var messages: [[String: Any]]

        // êµ¬ì¡°í™”ëœ ë©”ì‹œì§€ ìƒì„±
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI ê³µì‹ ë©€í‹°ëª¨ë‹¬ í¬ë§· ì‚¬ìš©
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        print("""
        ğŸŒ API Request:
        â€¢ URL: \(baseURL)
        â€¢ Method: POST
        â€¢ Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            ğŸŒ API Response:
            â€¢ Status Code: \(httpResponse.statusCode)
            â€¢ Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            // True/False ì§ˆë¬¸ì—ì„œ ì ‘ë‘ì‚¬ ì œê±°
            let processedQuestion = questionData.type == "true_false" ?
                questionData.question
                    .replacingOccurrences(
                        of: "^(True or False:|True/False:|T/F:|\\(True/False\\)|\\[True/False\\]|True or False\\?|Is it true or false:|True False:)\\s*",
                        with: "",
                        options: [.regularExpression, .caseInsensitive]
                    )
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)  // ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)   // ì¤„ë°”ê¿ˆì„ ê³µë°±ìœ¼ë¡œ
                    .trimmingCharacters(in: .whitespacesAndNewlines) :
                questionData.question
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)  // ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)   // ì¤„ë°”ê¿ˆì„ ê³µë°±ìœ¼ë¡œ
                    .trimmingCharacters(in: .whitespacesAndNewlines)

            // True/False ë‹µë³€ ì •ê·œí™”
            var correctAnswer = questionData.correctAnswer
            if questionData.type == "true_false" {
                correctAnswer = correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
                if ["yes", "ë„¤", "true", "correct", "that's right", "ë§ìŠµë‹ˆë‹¤", "ë„¤, ê·¸ë ‡ìŠµë‹ˆë‹¤", "ì‚¬ì‹¤ì…ë‹ˆë‹¤"].contains(correctAnswer) {
                    correctAnswer = "true"
                } else if ["no", "ì•„ë‹ˆì˜¤", "false", "incorrect", "that's wrong", "ì•„ë‹™ë‹ˆë‹¤", "ì•„ë‹ˆìš”", "ì‚¬ì‹¤ì´ ì•„ë‹ˆë‹¤", "ì‚¬ì‹¤ì´ ì•„ë‹™ë‹ˆë‹¤"].contains(correctAnswer) {
                    correctAnswer = "false"
                }
            }

            return Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                question: processedQuestion,  // ì²˜ë¦¬ëœ ì§ˆë¬¸ ì‚¬ìš©
                options: questionData.options,
                correctAnswer: correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        âœ… Questions Generated:
        â€¢ Count: \(questions.count)
        â€¢ Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


// ./AISnapStudy/Services/VisionService.swift

// Services/VisionService.swift

import Vision
import UIKit

// Vision ê´€ë ¨ ì—ëŸ¬ íƒ€ì… ì •ì˜
enum VisionError: Error {
    case invalidImage
    case processingFailed
    case noTextFound
    case unknown(Error)
}

class VisionService {
    static let shared = VisionService()
    
    private init() {}
    
    func extractText(from image: UIImage) async throws -> String {
        print("ğŸ” Starting universal text extraction...")
        
        guard let cgImage = image.cgImage else {
            print("âŒ Failed to get CGImage from UIImage")
            throw VisionError.invalidImage
        }

        let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        let request = VNRecognizeTextRequest()
        
        // Universal text recognition settings
        request.recognitionLevel = .accurate
        request.usesLanguageCorrection = true
        request.automaticallyDetectsLanguage = true // Enable automatic language detection
        
        print("ğŸ“ Configured for universal text recognition")
        
        do {
            try requestHandler.perform([request])
            
            let observations = request.results ?? []
            print("ğŸ“Š Found \(observations.count) text observations")
            
            var textBlocks: [(text: String, location: CGRect)] = []
            
            for observation in observations {
                if let candidate = observation.topCandidates(1).first {
                    let text = candidate.string
                    let confidence = candidate.confidence
                    
                    if confidence > 0.2 {
                        textBlocks.append((text, observation.boundingBox))
                    }
                }
            }
            
            let finalText = processTextBlocks(textBlocks)
            
            guard !finalText.isEmpty else {
                print("âš ï¸ No valid text extracted")
                throw VisionError.noTextFound
            }
            
            print("âœ… Successfully extracted text")
            return finalText
            
        } catch {
            print("âŒ Text extraction failed: \(error.localizedDescription)")
            throw VisionError.processingFailed
        }
    }
    
    private func processTextBlocks(_ blocks: [(text: String, location: CGRect)]) -> String {
        // Sort blocks by their position on the page
        let sortedBlocks = blocks.sorted { (block1, block2) -> Bool in
            // Different lines (threshold for line height difference)
            if abs(block1.location.minY - block2.location.minY) > 0.05 {
                return block1.location.minY > block2.location.minY
            }
            // Same line - left to right
            return block1.location.minX < block2.location.minX
        }
        
        // Process and join text blocks
        let processedText = sortedBlocks
            .map { block in
                var text = block.text
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Fix common punctuation issues
                text = text.replacingOccurrences(of: "\\s*([.,!?])\\s*", with: "$1 ", options: .regularExpression)
                text = text.replacingOccurrences(of: "([.,!?])\\1+", with: "$1", options: .regularExpression)
                
                return text
            }
            .joined(separator: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        return processedText
    }
}


// ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    // MARK: - Singleton
    static let shared = NetworkMonitor()
    
    // MARK: - Properties
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    private var timestampQueue: TimestampQueue
    
    // MARK: - Published Properties
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    // MARK: - Constants
    private let maxTimestamps = 1000
    private let cleanupInterval: TimeInterval = 300 // 5 minutes
    
    // MARK: - Debug Control
    private var shouldLog: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    // MARK: - Initialization
    private init() {
        self.timestampQueue = TimestampQueue(maxSize: maxTimestamps)
        setupPeriodicCleanup()
        startMonitoring()
    }
    
    // MARK: - Monitoring
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            self.timestampQueue.enqueue(Date().timeIntervalSince1970)
            
            DispatchQueue.main.async {
                self.updateNetworkStatus(path)
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    private func updateNetworkStatus(_ path: NWPath) {
        self.status = path.status
        self.isReachable = path.status == .satisfied
        self.connectionType = path.availableInterfaces.first?.type
        self.isExpensive = path.isExpensive
        self.isConstrained = path.isConstrained
        
        if shouldLog {
            switch path.status {
            case .satisfied:
                // ì¤‘ìš”í•œ ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€ê²½ë§Œ ë…¸í‹°í”¼ì¼€ì´ì…˜ ë°œì†¡
                if !isReachable {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            case .unsatisfied:
                Logger.log("Network disconnected", category: "Network")
            default:
                break
            }
        }
    }
    
    // MARK: - Network Status Check
    func checkNetworkAvailability() -> Bool {
        return status == .satisfied
    }
    
    func handleNetworkError(_ error: Error) async throws -> Bool {
        if !checkNetworkAvailability() {
            throw NetworkError.noConnection
        }
        return true
    }
    
    // MARK: - Timestamp Management
    private func setupPeriodicCleanup() {
        Timer.scheduledTimer(withTimeInterval: cleanupInterval, repeats: true) { [weak self] _ in
            self?.performTimestampCleanup()
        }
    }
    
    private func performTimestampCleanup() {
        let currentTime = Date().timeIntervalSince1970
        timestampQueue.removeTimestampsBefore(currentTime - cleanupInterval)
        if shouldLog {
            Logger.log("Timestamp cleanup completed", category: "Network")
        }
    }
    
    // MARK: - Utility Methods
    func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    // MARK: - Connection Management
    func getConnectionDetails() -> String {
        """
        Network Status:
        â€¢ Connection: \(isReachable ? "Connected" : "Disconnected")
        â€¢ Type: \(getInterfaceTypeString(connectionType))
        â€¢ Expensive: \(isExpensive ? "Yes" : "No")
        â€¢ Constrained: \(isConstrained ? "Yes" : "No")
        """
    }
    
    // MARK: - Cleanup
    func stopMonitoring() {
        monitor.cancel()
        if shouldLog {
            Logger.log("Network monitoring stopped", category: "Network")
        }
    }
    
    deinit {
        stopMonitoring()
    }
}

// MARK: - TimestampQueue
private class TimestampQueue {
    private var timestamps: [TimeInterval]
    private let maxSize: Int
    
    init(maxSize: Int) {
        self.maxSize = maxSize
        self.timestamps = []
        timestamps.reserveCapacity(maxSize)
    }
    
    func enqueue(_ timestamp: TimeInterval) {
        if timestamps.count >= maxSize {
            timestamps.removeFirst()
        }
        timestamps.append(timestamp)
    }
    
    func removeTimestampsBefore(_ time: TimeInterval) {
        timestamps.removeAll { $0 < time }
    }
    
    var count: Int {
        timestamps.count
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("ğŸ“± [\(category)] \(message)")
        #endif
    }
}


