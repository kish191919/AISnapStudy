// ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

@MainActor
class QuestionSettingsViewModel: ObservableObject {
    
    let openAIService: OpenAIService
    
    @Published var selectedSubject: any SubjectType {
        didSet {
            if let defaultSubject = selectedSubject as? DefaultSubject {
                UserDefaults.standard.set(defaultSubject.rawValue, forKey: "lastSelectedSubject")
            } else if let customSubject = selectedSubject as? CustomSubject {
                UserDefaults.standard.set("custom_" + customSubject.id, forKey: "lastSelectedSubject")
            }
        }
    }
    
    @Published var useTextExtraction: Bool = true {
        didSet {
            UserDefaults.standard.set(useTextExtraction, forKey: "useTextExtraction")
        }
    }
    
    @Published var selectedLanguage: Language = .auto {
        didSet {
            UserDefaults.standard.set(selectedLanguage.rawValue, forKey: "selectedLanguage")
        }
    }
    
    // TextExtraction ê´€ë ¨ ìƒíƒœë“¤
    @Published var extractedTexts: [String: String] = [:]
    @Published var isLoadingTexts: [String: Bool] = [:]
    @Published var extractionStatus: [String: Bool] = [:]
    @Published private(set) var isCameraAuthorized = false
    @Published private(set) var isGalleryAuthorized = false
    @Published var availableSubjects: [SubjectType] = []
    
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private let totalMaximumQuestions = 10
    private var studyViewModel: StudyViewModel?
    // StoreService ì¶”ê°€
    private let storeService = StoreService.shared
    
    // MARK: - UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    private func loadAvailableSubjects() {
        // DefaultSubjectë¥¼ ì§ì ‘ ì¶”ê°€
        var subjects: [any SubjectType] = DefaultSubject.allCases
        
        // í™œì„±í™”ëœ ì‚¬ìš©ì ì •ì˜ ê³¼ëª© ì¶”ê°€
        let activeUserSubjects = SubjectManager.shared.customSubjects
            .filter { $0.isActive }
        subjects.append(contentsOf: activeUserSubjects)
        
        availableSubjects = subjects
        
        // í˜„ì¬ ì„ íƒëœ ê³¼ëª©ì´ ì—†ê±°ë‚˜ ë¹„í™œì„±í™”ëœ ê²½ìš° ê¸°ë³¸ ê³¼ëª©ìœ¼ë¡œ ì„¤ì •
        if !subjects.contains(where: { $0.id == selectedSubject.id }) {
            selectedSubject = DefaultSubject.generalKnowledge  // ê¸°ë³¸ê°’ìœ¼ë¡œ math ì„¤ì •
        }
    }

    private var imageIds: [UIImage: String] = [:]
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView: Bool = false
    @Published var isGeneratingQuestions: Bool = false
    @Published var problemSetName: String = ""
    @Published var isLoading: Bool = false
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool = true
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool = false
    @Published var alertTitle: String = ""
    @Published var alertMessage: String = ""
    
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         }
     }
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
         }
     }
     
    let subject: DefaultSubject
    
     
     // MARK: - Initialization
    init(subject: any SubjectType, homeViewModel: HomeViewModel) {
        
        // 1. UserDefaults ê¸°ë³¸ê°’ì„ ë¨¼ì € ì„¤ì •
        UserDefaults.standard.register(defaults: [
            "useTextExtraction": true,
            UserDefaultsKeys.lastMultipleChoiceCount: 5,
            UserDefaultsKeys.lastTrueFalseCount: 5
        ])

        
        // 1. OpenAIService ì´ˆê¸°í™”
        self.openAIService = OpenAIService.shared
        
        // 2. ê¸°ë³¸ê°’ì´ í•„ìš”í•œ í”„ë¡œí¼í‹°ë“¤ ì´ˆê¸°í™”
        self.selectedSubject = subject
        self.subject = subject as? DefaultSubject ?? .generalKnowledge
        self.homeViewModel = homeViewModel
        self.studyViewModel = homeViewModel.studyViewModel
        
        // 3. @Published í”„ë¡œí¼í‹°ë“¤ ì´ˆê¸°í™”
        self.selectedLanguage = .auto
        self.useTextExtraction = UserDefaults.standard.bool(forKey: "useTextExtraction")
        self.educationLevel = EducationLevel(rawValue: UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel) ?? "") ?? .elementary
        self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
        self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
        self.isNetworkAvailable = networkMonitor.isReachable
        
        // 4. ê·¸ ì™¸ ë‚˜ë¨¸ì§€ @Published í”„ë¡œí¼í‹°ë“¤ ì´ˆê¸°í™”
        self.extractedTexts = [:]
        self.isLoadingTexts = [:]
        self.extractionStatus = [:]
        self.isCameraAuthorized = false
        self.isGalleryAuthorized = false
        self.availableSubjects = []
        self.selectedImages = []
        self.hasCameraImage = false
        self.hasGalleryImages = false
        self.questionText = ""
        self.isUsingTextInput = false
        self.isTextInputActive = false
        self.hasSelectedCamera = false
        self.hasSelectedGallery = false
        self.shouldCollapseQuestionTypes = false
        self.shouldShowStudyView = false
        self.isGeneratingQuestions = false
        self.problemSetName = ""
        self.isLoading = false
        self.showImagePicker = false
        self.showCamera = false
        self.selectedImage = nil
        self.showAlert = false
        self.alertTitle = ""
        self.alertMessage = ""
        

        
        // 6. Subject ê´€ë ¨ ì„¤ì • ì—…ë°ì´íŠ¸
        if let savedSubjectID = UserDefaults.standard.string(forKey: "lastSelectedSubject") {
            if savedSubjectID.starts(with: "custom_") {
                let customID = String(savedSubjectID.dropFirst(7))
                self.selectedSubject = SubjectManager.shared.customSubjects.first { $0.id == customID } ?? subject
            } else {
                self.selectedSubject = DefaultSubject(rawValue: savedSubjectID) ?? subject
            }
        }
        
        // 7. ì–¸ì–´ ì„¤ì • ì—…ë°ì´íŠ¸
        if let savedLanguage = UserDefaults.standard.string(forKey: "selectedLanguage"),
           let language = Language(rawValue: savedLanguage) {
            self.selectedLanguage = language
        }
    }
    // Add permission check methods
    func checkCameraPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .camera)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
    
    func checkGalleryPermission() async -> Bool {
        do {
            return try await imageService.requestPermission(for: .gallery)
        } catch {
            await MainActor.run {
                showError(error)
            }
            return false
        }
    }
     
     // MARK: - Image Management
     private func generateImageId() -> String {
         return UUID().uuidString
     }
     
    func getImageId(for image: UIImage) -> String {
        if let existingId = imageIds[image] {
            return existingId
        }
        let newId = generateImageId()
        imageIds[image] = newId
        return newId
    }

    // ìƒˆë¡œìš´ í•¨ìˆ˜ ì¶”ê°€
    private func sendExtractedTextToOpenAI(_ text: String) async throws {
        print("ğŸ“¤ Preparing to send extracted text to OpenAI")
        // OpenAIServiceëŠ” ì´ë¯¸ í”„ë¡œí¼í‹°ë¡œ ì¡´ì¬í•˜ë¯€ë¡œ ì§ì ‘ ì‚¬ìš©
        let response = try await openAIService.sendTextExtractionResult(text)
        print("âœ… OpenAI processing completed for extracted text")
        print("ğŸ“¥ OpenAI Response: \(response)")
    }

    private func sendImageToOpenAI(_ imageData: Data) async throws {
        print("ğŸ“¤ Preparing to send image to OpenAI")
        try await openAIService.sendImageDataToOpenAI(imageData)
        print("âœ… Image successfully sent to OpenAI")
    }

    
    func removeImage(at index: Int) {
        guard index < selectedImages.count else { return }
        
        let imageToRemove = selectedImages[index]
        if let imageId = imageIds[imageToRemove] {
            // Remove extracted text for this image
            extractedTexts.removeValue(forKey: imageId)
            imageIds.removeValue(forKey: imageToRemove)
            print("ğŸ—‘ï¸ Removed text for image: \(imageId)")
        }
        
        selectedImages.remove(at: index)
        
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false
            hasSelectedGallery = false
        }
    }
    
    
    func saveProblemSetName() {
        if problemSetName.isEmpty {
            problemSetName = generateDefaultName()
        }
        
        // ì´ë¦„ì´ ì €ì¥ë˜ì—ˆìŒì„ ì•Œë¦¬ëŠ” í”¼ë“œë°± ì œê³µ
        HapticManager.shared.impact(style: .medium)
        print("Problem Set name saved: \(problemSetName)")
        
        // ì§ˆë¬¸ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆê³  ì´ë¦„ì´ ì €ì¥ë˜ì—ˆì„ ë•Œë§Œ StudyViewë¡œ ì´ë™
        if !isGeneratingQuestions {
            shouldShowStudyView = true
        }
    }
    
    // ê¸°ë³¸ ì´ë¦„ ìƒì„± ë©”ì„œë“œ
    func generateDefaultName() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MM/dd_HH:mm"
        let dateString = dateFormatter.string(from: Date())
        let totalQuestions = multipleChoiceCount + trueFalseCount
        
        return "\(selectedSubject.displayName)_\(totalQuestions)Q_\(dateString)"
    }
     
     // ê¸°ì¡´ resetCounts ë©”ì„œë“œ ìˆ˜ì •
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults ì™„ì „ ì´ˆê¸°í™”ê°€ í•„ìš”í•œ ê²½ìš°ë¥¼ ìœ„í•œ ìƒˆë¡œìš´ ë©”ì„œë“œ
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         resetCounts()
     }
    
    // questionTextê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ì´ë¯¸ì§€ ì˜µì…˜ì„ ìˆ¨ê¸°ê¸° ìœ„í•œ ê³„ì‚° ì†ì„±
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // í…ìŠ¤íŠ¸ ì…ë ¥ì„ ë¦¬ì…‹í•˜ëŠ” ë©”ì„œë“œ
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // ì‹¤ì œ ì„ íƒëœ ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œë§Œ ì²´í¬
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // ë‹¤ìŒ ìƒíƒœ ë³€ê²½ì„ ìœ„í•´ ë¦¬ì…‹
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // ìƒíƒœ ë¦¬ì…‹
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    // ê³„ì‚° í”„ë¡œí¼í‹° ì¶”ê°€
    var canCreateQuestions: Bool {
        storeService.subscriptionStatus.dailyQuestionsRemaining > 0
    }
    
    var isPremium: Bool {
        storeService.subscriptionStatus.isPremium
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }

    @MainActor
    func addImage(_ image: UIImage) async {
       print("ğŸ“¸ Starting addImage processing...")
        if useTextExtraction && selectedImages.count >= 3 {
            self.alertTitle = "Image Limit Reached"
            self.alertMessage = "Speed Up mode allows maximum 3 images at once."
            self.showAlert = true
            return
        }
        
        if !useTextExtraction && selectedImages.count >= 1 {
            self.alertTitle = "Image Limit Reached"
            self.alertMessage = "When Speed Up is disabled, you can process only one image at a time."
            self.showAlert = true
            return
        }
       do {
           let compressedData = try await Task {
               try ImageService.shared.compressForAPI(image)
           }.value

           if let compressedImage = UIImage(data: compressedData) {
               selectedImages.append(compressedImage)
               let imageId = getImageId(for: compressedImage)

               if useTextExtraction {
                   print("ğŸ” Text extraction enabled for image: \(imageId)")
                   isLoadingTexts[imageId] = true
                   
                   // FileProvider ì—ëŸ¬ì™€ ìƒê´€ì—†ì´ Vision API ì‚¬ìš©
                   do {
                       // VisionServiceë¥¼ í†µí•œ í…ìŠ¤íŠ¸ ì¶”ì¶œ
                       print("ğŸ“ Starting Vision API text extraction...")
                       let extractedText = try await VisionService.shared.extractText(from: compressedImage)
                       
                       if !extractedText.isEmpty {
                           print("âœ… Text extracted successfully: \(extractedText)")
                           await MainActor.run {
                               extractedTexts[imageId] = extractedText
                               extractionStatus[imageId] = true
                               isLoadingTexts[imageId] = false
                           }
                       } else {
                           print("âš ï¸ No text extracted from image")
                           await MainActor.run {
                               extractionStatus[imageId] = false
                               isLoadingTexts[imageId] = false
                           }
                       }
                   } catch {
                       print("âŒ Text extraction failed: \(error.localizedDescription)")
                       await MainActor.run {
                           extractionStatus[imageId] = false
                           isLoadingTexts[imageId] = false
                       }
                   }
               } else {
                   print("â„¹ï¸ Text extraction disabled - using image directly")
               }
           }
       } catch {
           print("âŒ Error in image processing: \(error.localizedDescription)")
           self.error = error
           showError(error)
       }
    }
    
    
    @MainActor
    func sendAllImages() async {
       // ì§ˆë¬¸ ìƒì„± ê°€ëŠ¥ ì—¬ë¶€ ì²´í¬
       guard checkQuestionGenerationAvailability() else { return }

       print("ğŸš€ Starting sendAllImages process...")
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("âŒ No content to generate questions from")
           return
       }
       
       isLoading = true
       studyViewModel?.isGeneratingQuestions = true
       
       do {
           var allExtractedText = ""
           var imagesForDirectProcessing: [UIImage] = []
           
           // ì´ë¯¸ì§€ ì²˜ë¦¬
           for image in selectedImages {
               let imageId = getImageId(for: image)
               print("ğŸ“¸ Processing image: \(imageId)")
               
               if useTextExtraction {
                   print("ğŸ” Text extraction enabled - attempting to extract text...")
                   do {
                       let extractedText = try await VisionService.shared.extractText(from: image)
                       if !extractedText.isEmpty {
                           print("âœ… Successfully extracted text: \(extractedText)")
                           allExtractedText += extractedText + "\n"
                       } else {
                           print("âš ï¸ No text extracted, adding to direct processing queue")
                           imagesForDirectProcessing.append(image)
                       }
                   } catch {
                       print("âŒ Error extracting text from image: \(error)")
                       imagesForDirectProcessing.append(image)
                   }
               } else {
                   print("â„¹ï¸ Text extraction disabled - adding to direct processing queue")
                   imagesForDirectProcessing.append(image)
               }
           }

           // í…ìŠ¤íŠ¸ ì…ë ¥ ì²˜ë¦¬
           if !questionText.isEmpty {
               let textInput = OpenAIService.QuestionInput(
                   content: questionText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("ğŸ“ Processing text input")
               await generateQuestions(from: textInput, parameters: createParameters())
           }
           
           // ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ì²˜ë¦¬
           if !allExtractedText.isEmpty {
               let input = OpenAIService.QuestionInput(
                   content: allExtractedText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("ğŸ“¤ Sending extracted text to OpenAI")
               await generateQuestions(from: input, parameters: createParameters())
           }
           
           // ì§ì ‘ ì´ë¯¸ì§€ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš° ì²˜ë¦¬
           if !imagesForDirectProcessing.isEmpty {
               print("ğŸ“¸ Processing \(imagesForDirectProcessing.count) images directly")
               for image in imagesForDirectProcessing {
                   print("ğŸ–¼ï¸ Direct processing image")
                   try await processImageDirectly(image)
               }
           }
           
           // ì„±ê³µì ìœ¼ë¡œ ì§ˆë¬¸ì´ ìƒì„±ë˜ë©´ ë‚¨ì€ íšŸìˆ˜ ê°ì†Œ
           storeService.decrementRemainingQuestions()
           
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           showSuccess()
           shouldShowStudyView = true
           
       } catch {
           print("âŒ Error in sendAllImages: \(error.localizedDescription)")
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           self.error = error
           showError(error)
       }
    }
    
    // ì§ˆë¬¸ ìƒì„± ê°€ëŠ¥ ì—¬ë¶€ ì²´í¬ í•¨ìˆ˜ ì¶”ê°€
    private func checkQuestionGenerationAvailability() -> Bool {
        if !canCreateQuestions {
            alertTitle = "Daily Limit Reached"
            alertMessage = isPremium ?
                "You've used all your daily questions. Please wait until tomorrow." :
                "You've reached your daily free limit. Upgrade to Premium to create up to 30 question sets per day!"
            showAlert = true
            return false
        }
        return true
    }
    
    // generateQuestions(from:parameters:) ë³´ì¡° í•¨ìˆ˜
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
        print("ğŸ”„ Starting question generation from input")
        
        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            print("âœ… Successfully generated \(questions.count) questions")
            
            let name = problemSetName.isEmpty ? generateDefaultName() : problemSetName
            await processGeneratedQuestions(questions, name: name)
        } catch {
            print("âŒ Error generating questions: \(error)")
            await MainActor.run {
                self.error = error
                showError(error)
            }
        }
    }

    // ì§ì ‘ ì´ë¯¸ì§€ ì²˜ë¦¬ë¥¼ ìœ„í•œ í•¨ìˆ˜ë„ ìˆ˜ì •
    private func processImageDirectly(_ image: UIImage) async throws {
        print("ğŸ–¼ï¸ Processing image directly...")
        let compressedData = try await imageService.compressForAPI(image)
        let input = OpenAIService.QuestionInput(
            content: compressedData,
            isImage: true
        )
        print("ğŸ“¤ Sending image to OpenAI")
        let questions = try await openAIService.generateQuestions(from: input, parameters: createParameters())
        await processGeneratedQuestions(questions, name: problemSetName)
    }

    private func createParameters() -> OpenAIService.QuestionParameters {
        let subjectToUse = (selectedSubject as? DefaultSubject) ?? .generalKnowledge  // DefaultSubjectë¡œ ë³€í™˜
        
        return OpenAIService.QuestionParameters(
            subject: subjectToUse,
            educationLevel: educationLevel,
            questionTypes: [
                QuestionType.multipleChoice: multipleChoiceCount,
                QuestionType.trueFalse: trueFalseCount
            ],
            language: selectedLanguage
        )
    }
    
    // Update image handling methods
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("ğŸ“¸ Processing camera image...")
        guard let image = image else {
            print("âŒ No image captured")
            return
        }

        Task {
            do {
                let orientedImage = image.fixedOrientation()
                await addImage(orientedImage)
                hasCameraImage = true
                hasSelectedCamera = true
                hasSelectedGallery = false
                print("âœ… Camera image added successfully")
            } catch {
                print("âŒ Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }

    @MainActor
    func selectFromGallery() async {
        do {
            let hasPermission = try await imageService.requestPermission(for: .gallery)
            if hasPermission {
                hasSelectedCamera = false  // Reset camera selection
                hasSelectedGallery = true
                showImagePicker = true
                hasGalleryImages = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func takePhoto() async {
        print("ğŸ“¸ Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                hasSelectedGallery = false  // Reset gallery selection
                hasSelectedCamera = true
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }

    @MainActor
    func processGeneratedQuestions(_ questions: [Question], name: String) async {
        print("\nğŸ”„ Processing Generated Questions for subject: \(selectedSubject.displayName)")
        
        // 1. Subject ì •ë³´ ì¤€ë¹„
        var subjectType = "default"
        var subjectId = ""
        var subjectName = ""
        var defaultSubject = DefaultSubject.generalKnowledge
        
        if let customSubject = selectedSubject as? CustomSubject {
            subjectType = "custom"
            subjectId = customSubject.id
            subjectName = customSubject.displayName
            defaultSubject = .generalKnowledge
            
            print("""
            ğŸ“ Preparing Custom Subject:
            â€¢ Name: \(customSubject.displayName)
            â€¢ ID: \(customSubject.id)
            â€¢ Type: \(subjectType)
            """)
        } else if let defaultSubject = selectedSubject as? DefaultSubject {
            subjectType = "default"
            subjectId = defaultSubject.rawValue
            subjectName = defaultSubject.displayName
            
            print("""
            ğŸ“ Preparing Default Subject:
            â€¢ Name: \(defaultSubject.displayName)
            â€¢ ID: \(defaultSubject.rawValue)
            â€¢ Type: \(subjectType)
            """)
        }
        
        // 2. ì§ˆë¬¸ ì—…ë°ì´íŠ¸
        let updatedQuestions = questions.map { question in
            var updatedQuestion = question
            if let customSubject = selectedSubject as? CustomSubject {
                // CustomSubjectì¸ ê²½ìš° generalKnowledgeë¡œ ì„¤ì •
                updatedQuestion = Question(
                    id: question.id,
                    type: question.type,
                    subject: .generalKnowledge,
                    question: question.question,
                    options: question.options,
                    correctAnswer: question.correctAnswer,
                    explanation: question.explanation,
                    hint: question.hint,
                    isSaved: question.isSaved,
                    createdAt: question.createdAt
                )
            }
            return updatedQuestion
        }
        
        // 3. ProblemSet ìƒì„±
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            subject: selectedSubject,  // ì„ íƒëœ subject ê·¸ëŒ€ë¡œ ì‚¬ìš©
            subjectType: selectedSubject is DefaultSubject ? "default" : "custom",
            subjectId: selectedSubject.id,
            subjectName: selectedSubject.displayName,
            questions: questions,  // ì§ˆë¬¸ë“¤ì„ ìˆ˜ì •í•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ì‚¬ìš©
            createdAt: Date(),
            educationLevel: self.educationLevel,
            name: name
        )
        
        print("""
        ğŸ“¦ Created ProblemSet:
        â€¢ ID: \(problemSet.id)
        â€¢ Subject Type: \(problemSet.subjectType)
        â€¢ Subject ID: \(problemSet.subjectId)
        â€¢ Subject Name: \(problemSet.subjectName)
        â€¢ Questions Count: \(problemSet.questions.count)
        â€¢ Education Level: \(problemSet.educationLevel.rawValue)
        """)
        
        // 4. ProblemSet ì €ì¥ ë° ì„ íƒ
        await homeViewModel.saveProblemSet(problemSet)
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // 5. ì•Œë¦¼ ë°œì†¡
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
        
        print("âœ… Problem Set processing completed")
    }

    @MainActor
    private func showSuccess() {
        alertTitle = "Success"
        alertMessage = """
            Questions have been successfully generated.
            You have \(remainingQuestions) question sets remaining today.
            """
        showAlert = true
    }
    
    // ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ í‘œì‹œë¥¼ ìœ„í•œ í•¨ìˆ˜ ì¶”ê°€
    var subscriptionStatusText: String {
        if isPremium {
            return "Premium â€¢ \(remainingQuestions) sets remaining today"
        } else {
            return "Free â€¢ \(remainingQuestions) set remaining today"
        }
    }

    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


// ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    @Published var streak: Int = 0
    @Published var correctAnswers: Int = 0 {
        didSet {
            // ì ìˆ˜ê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì¶œë ¥ë˜ëŠ” ë””ë²„ê·¸ ë¡œê·¸
            print("ğŸ“Š StatViewModel score updated: \(correctAnswers * 10) points")
        }
    }
    private var isResetting: Bool = false
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var isLoading = false
    @Published var monthlyProgress: [DailyProgress] = []
    @Published var yearlyProgress: [DailyProgress] = []
    
    private var todaysSessionStats: (questions: Int, correct: Int) = (0, 0)
    private var existingStats: (questions: Int, correct: Int) = (0, 0)
    
    private weak var studyViewModel: StudyViewModel?
    private weak var homeViewModel: HomeViewModel?
    private var todayTotalQuestions: Int = 0
    private var todayCorrectAnswers: Int = 0

    
    @Published var totalPoints: Int = 0      // í˜„ì¬ ì„¸ì…˜ì˜ ì ìˆ˜
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    
    private var sessionStats: SessionStats = .init() // ìƒˆë¡œ ì¶”ê°€

    struct SessionStats {
        var completedQuestions: Int = 0
        var correctAnswers: Int = 0
        var startTime: Date = Date()
    }
    

    
    init(context: NSManagedObjectContext,
         homeViewModel: HomeViewModel? = nil,
         studyViewModel: StudyViewModel? = nil) {
        self.context = context
        self.homeViewModel = homeViewModel
        self.studyViewModel = studyViewModel
        
        // Move the loadStats() call to the end of the init method
        loadStats()
        setupObservers()
    }
    private func setupObservers() {
        // ê¸°ì¡´ observer ì œê±°
        NotificationCenter.default.removeObserver(self)
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleStudyProgressUpdate),
            name: .studyProgressDidUpdate,
            object: nil
        )
    }
    
    @MainActor
    func loadStatsByPeriod(_ period: StatsPeriod) async {
        isLoading = true
        
        do {
            let stats = try await CoreDataService.shared.fetchStatsByPeriod(period)
            await MainActor.run {
                switch period {
                case .day:
                    weeklyProgress = processStats(stats)
                case .month:
                    monthlyProgress = processStats(stats)
                case .year:
                    yearlyProgress = processStats(stats)
                }
                objectWillChange.send()
            }
        } catch {
            print("âŒ Failed to load \(period) stats: \(error)")
        }
        
        isLoading = false
    }
    
    private func processStats(_ stats: [DailyStats]) -> [DailyProgress] {
        return stats.map { stat in
            DailyProgress(
                date: stat.date,
                questionsCompleted: stat.totalQuestions,
                correctAnswers: stat.correctAnswers,
                totalTime: 0
            )
        }
    }
    
    @objc private func handleStudyProgressUpdate(_ notification: Notification) {
        guard let currentIndex = notification.userInfo?["currentIndex"] as? Int,
              let correctAnswers = notification.userInfo?["correctAnswers"] as? Int else {
            return
        }
        
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            let addedCorrect = correctAnswers - self.correctAnswers
            
            self.updateStats(
                correctAnswers: addedCorrect,
                totalQuestions: 1,
                isNewSession: false
            )
            
            self.correctAnswers = correctAnswers
        }
    }
    var currentSessionScore: Int {
        return correctAnswers * 10  // ê³„ì‚° ì†ì„±ìœ¼ë¡œ ë³€ê²½
    }
    
    // StudyViewModel ì„¤ì • ë©”ì„œë“œ
    func setStudyViewModel(_ viewModel: StudyViewModel?) {
        self.studyViewModel = viewModel
        print("ğŸ“± StudyViewModel connected to StatViewModel")
    }

    
    func updateScore() {
        if let studyVM = studyViewModel {
            // correctAnswers ê°’ì„ ì—…ë°ì´íŠ¸
            self.correctAnswers = studyVM.correctAnswers
            self.totalQuestions = studyVM.totalQuestions
            // ë””ë²„ê·¸ë¥¼ ìœ„í•œ ë¡œê·¸
            print("ğŸ“Š Score Updated - Correct: \(correctAnswers), Total: \(totalQuestions), Score: \(currentSessionScore)")
        }
    }
    
    func updateStats(correctAnswers: Int, totalQuestions: Int, isNewSession: Bool = false) {
        // ë¦¬ì…‹ ì¤‘ì´ë©´ í†µê³„ ì—…ë°ì´íŠ¸ ê±´ë„ˆë›°ê¸°
        guard !isResetting else { return }
        
        let today = Date()
        
        do {
            // 1. í˜„ì¬ ì €ì¥ëœ í†µê³„ ê°€ì ¸ì˜¤ê¸°
            let currentStats = try CoreDataService.shared.fetchDailyStats() ?? DailyStats(
                id: UUID(),
                date: today,
                totalQuestions: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                timeSpent: 0
            )
            
            // 2. ë‹¨ì¼ ë¬¸ì œì— ëŒ€í•œ í†µê³„ ëˆ„ì 
            let updatedStats = DailyStats(
                id: currentStats.id,
                date: today,
                totalQuestions: currentStats.totalQuestions + 1,  // í˜„ì¬ í†µê³„ì— 1 ì¶”ê°€
                correctAnswers: currentStats.correctAnswers + (correctAnswers > 0 ? 1 : 0),
                wrongAnswers: currentStats.wrongAnswers + (correctAnswers > 0 ? 0 : 1),
                timeSpent: currentStats.timeSpent
            )
            
            // 3. í†µê³„ ì €ì¥
            try CoreDataService.shared.saveDailyStats(updatedStats)
            
            print("""
            ğŸ“Š Stats updated:
            â€¢ Previous Total: \(currentStats.totalQuestions)
            â€¢ Added Questions: 1
            â€¢ New Total: \(updatedStats.totalQuestions)
            â€¢ Previous Correct: \(currentStats.correctAnswers)
            â€¢ Added Correct: \(correctAnswers > 0 ? 1 : 0)
            â€¢ New Correct: \(updatedStats.correctAnswers)
            """)
            
            // 4. UI ì—…ë°ì´íŠ¸
            weeklyProgress = weeklyProgress.map { progress in
                if Calendar.current.isDate(progress.date, inSameDayAs: today) {
                    return DailyProgress(
                        date: today,
                        questionsCompleted: updatedStats.totalQuestions,
                        correctAnswers: updatedStats.correctAnswers,
                        totalTime: progress.totalTime
                    )
                }
                return progress
            }
            
            objectWillChange.send()
            
        } catch {
            print("âŒ Failed to update stats: \(error)")
        }
    }
    
    private func updateWeeklyProgress() {
        let today = Date()
        if let index = weeklyProgress.firstIndex(where: { Calendar.current.isDate($0.date, inSameDayAs: today) }) {
            let updatedProgress = DailyProgress(
                date: today,
                questionsCompleted: completedQuestions,
                correctAnswers: correctAnswers,
                totalTime: weeklyProgress[index].totalTime
            )
            weeklyProgress[index] = updatedProgress
        } else {
            let newProgress = DailyProgress(
                date: today,
                questionsCompleted: completedQuestions,
                correctAnswers: correctAnswers,
                totalTime: 0.0  // New entry starts with 0 time
            )
            weeklyProgress.append(newProgress)
        }
        
        objectWillChange.send()
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("ğŸ”„ Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("ğŸ”„ Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    private func loadStats() {
        print("ğŸ“Š Starting stats loading...")
        isLoading = true
        
        do {
            // 1. CoreDataì—ì„œ ì˜¤ëŠ˜ì˜ í†µê³„ ë¶ˆëŸ¬ì˜¤ê¸°
            if let todayStats = try CoreDataService.shared.fetchDailyStats(for: Date()) {
                existingStats = (todayStats.totalQuestions, todayStats.correctAnswers)
                
                DispatchQueue.main.async { [weak self] in
                    self?.completedQuestions = todayStats.totalQuestions
                    self?.correctAnswers = todayStats.correctAnswers
                    self?.accuracyRate = todayStats.accuracy
                    print("""
                    ğŸ“Š Stats loaded from CoreData:
                    â€¢ Questions: \(todayStats.totalQuestions)
                    â€¢ Correct: \(todayStats.correctAnswers)
                    â€¢ Accuracy: \(todayStats.accuracy)%
                    """)
                }
            }
            
            // 2. ì£¼ê°„ ì§„í–‰ ìƒí™© ê³„ì‚°
            let calendar = Calendar.current
            let today = Date()
            let weekAgo = calendar.date(byAdding: .day, value: -6, to: today)!
            
            var weekProgress: [DailyProgress] = []
            
            // ì§€ë‚œ 7ì¼ê°„ì˜ í†µê³„ ë¶ˆëŸ¬ì˜¤ê¸°
            for dayOffset in 0...6 {
                let date = calendar.date(byAdding: .day, value: dayOffset, to: weekAgo)!
                if let stats = try CoreDataService.shared.fetchDailyStats(for: date) {
                    weekProgress.append(DailyProgress(
                        date: date,
                        questionsCompleted: stats.totalQuestions,
                        correctAnswers: stats.correctAnswers,
                        totalTime: 0.0  // ì‹œê°„ trackingì´ í•„ìš”í•˜ë‹¤ë©´ ë‚˜ì¤‘ì— ì¶”ê°€
                    ))
                } else {
                    // í•´ë‹¹ ë‚ ì§œì˜ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 0ìœ¼ë¡œ ì´ˆê¸°í™”
                    weekProgress.append(DailyProgress(
                        date: date,
                        questionsCompleted: 0,
                        correctAnswers: 0,
                        totalTime: 0.0
                    ))
                }
            }
            
            weeklyProgress = weekProgress
            
            print("""
            ğŸ“Š Weekly progress loaded:
            â€¢ Total days: \(weekProgress.count)
            â€¢ Total questions: \(weekProgress.reduce(0) { $0 + $1.questionsCompleted })
            â€¢ Total correct: \(weekProgress.reduce(0) { $0 + $1.correctAnswers })
            """)
            
        } catch {
            print("âŒ Failed to load stats: \(error)")
        }
        
        isLoading = false
    }
    
    
    private func calculateWeeklyProgress(from sessions: [CDStudySession]) {
        print("ğŸ“Š Starting weekly progress calculation...")
        let calendar = Calendar.current
        let today = Date()
        let weekAgo = calendar.date(byAdding: .day, value: -6, to: today)!
        
        var progress: [DailyProgress] = []
        
        for dayOffset in 0...6 {
            let date = calendar.date(byAdding: .day, value: dayOffset, to: weekAgo)!
            let dayStart = calendar.startOfDay(for: date)
            let dayEnd = calendar.date(byAdding: .day, value: 1, to: dayStart)!
            
            // Filter sessions for current day
            let daysSessions = sessions.filter { session in
                guard let sessionTime = session.startTime else { return false }
                return calendar.isDate(sessionTime, inSameDayAs: date)
            }
            
            let questionsCompleted = daysSessions.reduce(0) { sum, session in
                sum + (session.questions?.count ?? 0)
            }
            
            let correctAnswers = daysSessions.reduce(0) { sum, session in
                sum + ((session.questions?.allObjects as? [CDQuestion])?.filter { $0.isCorrect }.count ?? 0)
            }
            
            let totalTime = daysSessions.reduce(0.0) { sum, session in
                guard let start = session.startTime,
                      let end = session.endTime else { return sum }
                return sum + end.timeIntervalSince(start)
            }
            
            progress.append(DailyProgress(
                date: date,
                questionsCompleted: questionsCompleted,
                correctAnswers: correctAnswers,
                totalTime: totalTime
            ))
            
            // Log daily statistics
            print("""
            ğŸ“Š Daily Stats for \(date):
            â€¢ Sessions: \(daysSessions.count)
            â€¢ Questions: \(questionsCompleted)
            â€¢ Correct: \(correctAnswers)
            """)
        }
        
        weeklyProgress = progress
    }
    

    private func calculateStats(from sessions: [CDStudySession]) {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        
        let todaySessions = sessions.filter { session in
            guard let sessionTime = session.startTime else { return false }
            return calendar.isDate(sessionTime, inSameDayAs: today)
        }
        
        // ì´ì „ ì„¸ì…˜ í†µê³„ì— ìƒˆë¡œìš´ ì„¸ì…˜ í†µê³„ ì¶”ê°€
        let newCompletedQuestions = todaySessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        let newCorrectAnswers = todaySessions.reduce(0) { total, session in
            total + ((session.questions?.allObjects as? [CDQuestion])?.filter { $0.isCorrect }.count ?? 0)
        }
        
        // Calculate today's statistics
        let totalCompletedQuestions = todaySessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrectAnswers = todaySessions.reduce(0) { total, session in
            total + ((session.questions?.allObjects as? [CDQuestion])?.filter { $0.isCorrect }.count ?? 0)
        }
        
        // Calculate accuracy rate
        let calculatedAccuracyRate = totalCompletedQuestions > 0 ?
            (Double(totalCorrectAnswers) / Double(totalCompletedQuestions)) * 100 : 0
        
        // ê°’ ì—…ë°ì´íŠ¸ í›„ ëª…ì‹œì ìœ¼ë¡œ UI ì—…ë°ì´íŠ¸
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            self.objectWillChange.send()
            self.completedQuestions = newCompletedQuestions
            self.correctAnswers = newCorrectAnswers
            self.accuracyRate = self.completedQuestions > 0 ?
                (Double(self.correctAnswers) / Double(self.completedQuestions)) * 100 : 0
        }
        
        print("""
        ğŸ“Š Today's Stats Calculated:
        â€¢ Previous Questions: \(todaysSessionStats.questions)
        â€¢ New Total Questions: \(completedQuestions)
        â€¢ Correct Answers: \(correctAnswers)
        â€¢ Accuracy Rate: \(accuracyRate)%
        """)
    }
    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
        print("ğŸ”„ Starting resetProgress...")
        isResetting = true  // ë¦¬ì…‹ ì‹œì‘
    
        
        // í˜„ì¬ê¹Œì§€ì˜ í†µê³„ë¥¼ ì €ì¥
        let previousStats = (
            questions: completedQuestions,
            correct: correctAnswers
        )
        
        guard let homeVM = homeViewModel,
              let studyVM = homeVM.studyViewModel,
              let currentProblemSet = homeVM.selectedProblemSet else {
            print("âŒ Required view models not found")
            return
        }
        
        Task {
            print("ğŸ”„ Resetting study state...")
            await studyVM.resetState()
            
            // í†µê³„ë¥¼ ëˆ„ì í•˜ì—¬ ì—…ë°ì´íŠ¸
            updateStats(
                correctAnswers: previousStats.correct,
                totalQuestions: previousStats.questions,
                isNewSession: true  // ìƒˆë¡œìš´ ì„¸ì…˜ì„ì„ í‘œì‹œ
            )
            
            await MainActor.run {
                studyVM.loadQuestions(currentProblemSet.questions)
                
                print("""
                âœ… Reset complete:
                â€¢ Previous Questions: \(previousStats.questions)
                â€¢ Previous Correct: \(previousStats.correct)
                â€¢ Total Questions: \(completedQuestions)
                â€¢ New Session Questions: \(currentProblemSet.questions.count)
                """)
            }
            
            isResetting = false  // ë¦¬ì…‹ ì™„ë£Œ
        }
    }
}

extension Notification.Name {
    static let studyProgressDidUpdate = Notification.Name("studyProgressDidUpdate")
}


enum StatsPeriod {
   case day, month, year
}


// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    @Published var studyViewModel: StudyViewModel?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var selectedProblemSet: ProblemSet?
    @Published var totalQuestions: Int = 0
    private let remoteService = RemoteQuestionService.shared
    @Published private(set) var remoteSets: [RemoteQuestionSet] = []  // ì¶”ê°€
    @Published private(set) var isLoadingRemote = false  // ì¶”ê°€
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()
//    @Published private(set) var favoriteProblemSets: [ProblemSet] = []
    
    init() {
        Task {
            await loadInitialData()
        }
    }
    
    @MainActor
    func toggleFavorite(_ problemSet: ProblemSet) async {
        do {
            problemSet.isFavorite.toggle()
            
            try await coreDataService.updateProblemSetFavorite(
                problemSetId: problemSet.id,
                isFavorite: problemSet.isFavorite
            )
            
            // UI ì—…ë°ì´íŠ¸
            objectWillChange.send()
            
            print("â­ï¸ Problem Set favorite toggled: \(problemSet.id) - \(problemSet.name) - isFavorite: \(problemSet.isFavorite)")
        } catch {
            print("âŒ Failed to toggle favorite: \(error)")
        }
    }

    @MainActor
    public func fetchUpdatedProblemSet(_ id: String) async throws -> ProblemSet? {
        let problemSets = try await coreDataService.fetchProblemSets()
        return problemSets.first(where: { $0.id == id })
    }
    
    // ì¦ê²¨ì°¾ê¸°ëœ ë¬¸ì œ ì„¸íŠ¸ ê°€ì ¸ì˜¤ê¸°
    var favoriteProblemSets: [ProblemSet] {
        problemSets.filter { $0.isFavorite }
    }
    
    // ì§ˆë¬¸ ë¶ë§ˆí¬ í† ê¸€ ë©”ì„œë“œ ì¶”ê°€
    func toggleQuestionBookmark(_ question: Question) async {
        var updatedQuestion = question
        updatedQuestion.isSaved.toggle()
        
        if updatedQuestion.isSaved {
            await saveQuestion(updatedQuestion)
        } else {
            await deleteQuestion(updatedQuestion)
        }
    }

    

    // í˜„ì¬ ì„¸ì…˜ì˜ ì ìˆ˜ ê´€ë ¨ ì†ì„± ì¶”ê°€
    var currentSessionScore: Int {
        return studyViewModel?.correctAnswers ?? 0
    }
    
    var currentSessionTotalQuestions: Int {
        return selectedProblemSet?.questions.count ?? 0
    }
    
    func setStudyViewModel(_ viewModel: StudyViewModel) {
        print("ğŸ“± Setting StudyViewModel in HomeViewModel")
        self.studyViewModel = viewModel
    }
    
    @MainActor
    func resetAndSetProblemSet(_ problemSet: ProblemSet) async {
        print("ğŸ”„ Starting complete ProblemSet reset")
        
        // ìƒˆë¡œìš´ ProblemSet ì„¤ì •
        self.selectedProblemSet = problemSet
        
        // StudyViewModelì´ nilì´ ì•„ë‹Œì§€ í™•ì¸
        guard let studyVM = studyViewModel else {
            print("âŒ StudyViewModel is nil")
            return
        }
        
        // ìƒíƒœ ë¦¬ì…‹ ë° ë¬¸ì œ ë‹¤ì‹œ ë¡œë“œ
        await studyVM.resetState()
        studyVM.loadQuestions(problemSet.questions)
        
        print("""
        âœ… ProblemSet reset complete:
        â€¢ ID: \(problemSet.id)
        â€¢ Questions: \(problemSet.questions.count)
        â€¢ Index reset to 0
        â€¢ Current Question: \(studyVM.currentQuestion?.question ?? "none")
        """)
    }
    
    func updateProblemSetSubject(_ problemSet: ProblemSet, to newSubject: SubjectType) async {
        do {
            // 1. ìƒˆë¡œìš´ ProblemSet ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
            let updatedSet = ProblemSet(
                id: UUID().uuidString,  // ìƒˆë¡œìš´ ID ìƒì„±
                subject: newSubject,
                subjectType: newSubject is DefaultSubject ? "default" : "custom",
                subjectId: newSubject.id,
                subjectName: newSubject.displayName,
                questions: problemSet.questions,
                createdAt: problemSet.createdAt,
                educationLevel: problemSet.educationLevel,
                name: problemSet.name
            )
            
            // 2. ê¸°ì¡´ ProblemSet ì‚­ì œ
            try await coreDataService.deleteProblemSet(problemSet)
            
            // 3. ë©”ëª¨ë¦¬ì—ì„œ ê¸°ì¡´ ProblemSet ì œê±°
            problemSets.removeAll { $0.id == problemSet.id }
            
            // 4. ìƒˆë¡œìš´ ProblemSet ì €ì¥
            try await coreDataService.saveProblemSet(updatedSet)
            problemSets.append(updatedSet)
            
            // 5. selectedProblemSet ì—…ë°ì´íŠ¸
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = updatedSet
            }
            
            // 6. UI ì—…ë°ì´íŠ¸
            objectWillChange.send()
            
            print("""
            âœ… Problem Set subject updated:
            â€¢ Old Subject: \(problemSet.subjectName)
            â€¢ New Subject: \(newSubject.displayName)
            â€¢ Old ID: \(problemSet.id)
            â€¢ New ID: \(updatedSet.id)
            """)
        } catch {
            print("âŒ Failed to update problem set subject: \(error)")
        }
    }
    
    @MainActor
    func removeQuestionFromProblemSet(_ questionId: String, from problemSet: ProblemSet) async {
        let updatedProblemSet = problemSet.removeQuestion(questionId)
        
        do {
            try await coreDataService.saveProblemSet(updatedProblemSet)
            
            // UI ì—…ë°ì´íŠ¸ë¥¼ MainActorì—ì„œ í•œë²ˆì— ì²˜ë¦¬
            await MainActor.run {
                if let index = problemSets.firstIndex(where: { $0.id == problemSet.id }) {
                    problemSets[index] = updatedProblemSet
                }
                
                if selectedProblemSet?.id == problemSet.id {
                    selectedProblemSet = updatedProblemSet
                }
                
                // ëª…ì‹œì ìœ¼ë¡œ UI ì—…ë°ì´íŠ¸ ì•Œë¦¼
                objectWillChange.send()
            }
            
            print("""
            âœ… Question removed successfully:
            â€¢ Problem Set: \(problemSet.id)
            â€¢ Updated question count: \(updatedProblemSet.questions.count)
            """)
        } catch {
            print("âŒ Failed to remove question: \(error)")
        }
    }
    
    @MainActor
    func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("ğŸ”µ HomeViewModel - Initial data loading")
            // ë¡œì»¬ ë°ì´í„° ë¡œë“œ
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            // ì›ê²© ë©”íƒ€ë°ì´í„° ë¡œë“œ
            isLoadingRemote = true
            do {
                self.remoteSets = try await remoteService.fetchQuestionSets()
                print("âœ… Successfully loaded remote sets: \(remoteSets.count)")
            } catch {
                print("âš ï¸ Remote data loading failed: \(error.localizedDescription)")
                self.remoteSets = []
            }
            isLoadingRemote = false
            
            hasLoadedData = true
            print("âœ… Initial data loaded - Local sets: \(loadedProblemSets.count), Remote sets: \(remoteSets.count)")
            
        } catch {
            isLoadingRemote = false
            print("âŒ Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("ğŸ”µ HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // ìµœê·¼ ProblemSetì„ selectedProblemSetìœ¼ë¡œ ì„¤ì •
            if selectedProblemSet == nil && !problemSets.isEmpty {
                await setSelectedProblemSet(problemSets[0])  // await ì¶”ê°€
            }
            
            print("âœ… Loaded problem sets: \(problemSets.count)")
            print("âœ… Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("âŒ Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // ì›ê²© ì„¸íŠ¸ ë‹¤ìš´ë¡œë“œ ë©”ì„œë“œ ì¶”ê°€
    @MainActor
    func downloadQuestionSet(_ remoteSet: RemoteQuestionSet) async {
        do {
            print("ğŸŒ Downloading question set: \(remoteSet.id)")
            
            // ìƒì„¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            let detailedSet = try await remoteService.fetchQuestionSet(remoteSet.id)
            
            // ProblemSetìœ¼ë¡œ ë³€í™˜
            let problemSet = ProblemSet(
                subject: DefaultSubject.download,
                subjectType: "default",
                subjectId: DefaultSubject.download.rawValue,
                subjectName: "Downloaded Sets",
                questions: detailedSet.questions,
                createdAt: remoteSet.createdAt,
                educationLevel: determineEducationLevel(from: remoteSet.difficulty),
                name: remoteSet.title
            )
            
            // CoreDataì— ì €ì¥
            await saveProblemSet(problemSet)
            
            print("âœ… Successfully downloaded and saved question set: \(remoteSet.title)")
            
            // ë‹¤ìš´ë¡œë“œ ìƒíƒœ ì—…ë°ì´íŠ¸
            if let index = remoteSets.firstIndex(where: { $0.id == remoteSet.id }) {
                remoteSets[index].isDownloaded = true
            }
            
        } catch {
            print("âŒ Failed to download question set: \(error)")
        }
    }
    
    private func determineEducationLevel(from difficulty: String) -> EducationLevel {
        switch difficulty.lowercased() {
        case "elementary": return .elementary
        case "middle": return .middle
        case "high": return .high
        case "college": return .college
        default: return .elementary
        }
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            // 1. ê¸°ì¡´ ProblemSet ì°¾ê¸°
            if let existingSet = problemSets.first(where: {
                $0.questions == problemSet.questions && $0.id != problemSet.id
            }) {
                // 2. ê¸°ì¡´ ProblemSet ì‚­ì œ
                try await coreDataService.deleteProblemSet(existingSet)
                problemSets.removeAll { $0.id == existingSet.id }
            }

            // 3. ìƒˆë¡œìš´ ProblemSet ì €ì¥
            try await coreDataService.saveProblemSet(problemSet)
            problemSets.insert(problemSet, at: 0)
            
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = problemSet
            }
            
            print("âœ… Successfully updated ProblemSet with new subject: \(problemSet.subjectName)")
        } catch {
            self.error = error
            print("âŒ Failed to update ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) async {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("ğŸ”µ HomeViewModel - Setting selected problem set")
        
        if let problemSet = problemSet {
            let updatedProblemSets = try? await coreDataService.fetchProblemSets()
            if let updatedSet = updatedProblemSets?.first(where: { $0.id == problemSet.id }) {
                self.selectedProblemSet = updatedSet
                if let studyVM = studyViewModel {
                    await studyVM.resetState()
                    await studyVM.loadUpdatedQuestions(updatedSet.id)
                }
                print("âœ… ProblemSet set successfully with latest data:")
                print("â€¢ ID: \(updatedSet.id)")
                print("â€¢ Questions: \(updatedSet.questions.count)")
            }
        } else {
            self.selectedProblemSet = nil
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("âŒ Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("âŒ Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                ğŸ“ Stored ProblemSets:
                â€¢ Count: \(storedSets.count)
                â€¢ Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("âŒ Failed to verify storage: \(error)")
            }
        }
    }
}

extension HomeViewModel {
    @MainActor
    func renameProblemSet(_ problemSet: ProblemSet, newName: String) async {
        // ë¹ˆ ì´ë¦„ì´ë‚˜ ê³µë°±ë§Œ ìˆëŠ” ê²½ìš° ì²˜ë¦¬ ë°©ì§€
        let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else {
            print("âŒ Cannot rename problem set: Name is empty")
            return
        }

        do {
            // 1. CoreData ì—…ë°ì´íŠ¸
            try await coreDataService.updateProblemSet(problemSet, newName: trimmedName)
            
            await MainActor.run {
                // 2. ìƒˆë¡œìš´ ProblemSet ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
                let updatedSet = ProblemSet(
                    id: problemSet.id,
                    subject: problemSet.subject,
                    subjectType: problemSet.subjectType,
                    subjectId: problemSet.subjectId,
                    subjectName: problemSet.subjectName,
                    questions: problemSet.questions,
                    createdAt: problemSet.createdAt,
                    educationLevel: problemSet.educationLevel,
                    name: trimmedName  // trimmedëœ ì´ë¦„ ì‚¬ìš©
                )
                
                // 3. problemSets ë°°ì—´ ì—…ë°ì´íŠ¸
                if let index = self.problemSets.firstIndex(where: { $0.id == problemSet.id }) {
                    self.problemSets[index] = updatedSet
                }
                
                // 4. selectedProblemSet ì—…ë°ì´íŠ¸
                if self.selectedProblemSet?.id == problemSet.id {
                    self.selectedProblemSet = updatedSet
                }
            }
            
            print("""
            âœ… Problem Set renamed successfully:
            â€¢ ID: \(problemSet.id)
            â€¢ Old Name: \(problemSet.name)
            â€¢ New Name: \(trimmedName)
            â€¢ Memory Update: Success
            """)
        } catch {
            print("âŒ Failed to rename problem set: \(error)")
        }
    }
    
    @MainActor
    func deleteProblemSet(_ problemSet: ProblemSet) async {
        do {
            try await coreDataService.deleteProblemSet(problemSet)
            problemSets.removeAll { $0.id == problemSet.id }
            
            if selectedProblemSet?.id == problemSet.id {
                selectedProblemSet = nil
            }
            
            print("""
            âœ… Problem Set deleted:
            â€¢ ID: \(problemSet.id)
            â€¢ Name: \(problemSet.name)
            """)
        } catch {
            self.error = error
            print("âŒ Failed to delete problem set: \(error)")
        }
    }
}


// ./AISnapStudy/ViewModels/ReviewViewModel.swift


import Foundation

@MainActor
class ReviewViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            ğŸ“š Review Data Loaded:
            â€¢ Study Sessions: \(studySessions.count)
            â€¢ Problem Sets: \(problemSets.count)
            â€¢ Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("âŒ Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("âœ… Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("âŒ Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("ğŸ“± HomeViewModel reference set in ReviewViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


// ./AISnapStudy/ViewModels/DetailedStatsViewModel.swift


import Foundation
import SwiftUI
import Combine

@MainActor
class DetailedStatsViewModel: ObservableObject {
    @Published private(set) var dailyStats: [DailyStats] = []
    @Published private(set) var streakInfo: StreakInfo
    @Published private(set) var monthlyData: [Date: [DailyStats]] = [:]
    
    private let calendar = Calendar.current
    
    init() {
        self.streakInfo = StreakInfo(currentStreak: 0, longestStreak: 0, lastActiveDate: Date())
        loadStats()
    }
    
    func loadStats() {
        // Load saved stats from UserDefaults or CoreData
    }
    
    func updateDailyStats(correctAnswers: Int, totalQuestions: Int) {
        let today = Date()
        let newStats = DailyStats(
            id: UUID(), // UUID().uuidString ëŒ€ì‹  UUID() ì‚¬ìš©
            date: today,
            totalQuestions: totalQuestions,
            correctAnswers: correctAnswers,
            wrongAnswers: totalQuestions - correctAnswers,
            timeSpent: 0  // ê¸°ë³¸ê°’ ì‚¬ìš©
        )
        
        dailyStats.append(newStats)
        updateStreak(date: today)
        updateMonthlyData()
    }
    
    private func updateStreak(date: Date) {
        let yesterday = calendar.date(byAdding: .day, value: -1, to: date)!
        
        if calendar.isDate(date, inSameDayAs: streakInfo.lastActiveDate) {
            // Same day, no streak update needed
            return
        } else if calendar.isDate(yesterday, inSameDayAs: streakInfo.lastActiveDate) {
            // Consecutive day
            let newStreak = streakInfo.currentStreak + 1
            streakInfo = StreakInfo(
                currentStreak: newStreak,
                longestStreak: max(newStreak, streakInfo.longestStreak),
                lastActiveDate: date
            )
        } else {
            // Streak broken
            streakInfo = StreakInfo(
                currentStreak: 1,
                longestStreak: streakInfo.longestStreak,
                lastActiveDate: date
            )
        }
    }
    
    private func updateMonthlyData() {
        monthlyData = Dictionary(grouping: dailyStats) { stats in
            calendar.startOfMonth(for: stats.date)
        }
    }
}



// ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
    // OpenAIService íƒ€ì… ì°¸ì¡° ì¶”ê°€
    typealias QuestionInput = OpenAIService.QuestionInput
    typealias QuestionParameters = OpenAIService.QuestionParameters
    private weak var statViewModel: StatViewModel?

    @Published private(set) var loadedQuestions: [Question] = []
    @Published private(set) var loadingProgress = 0

    private let openAIService: OpenAIService

    @Published private(set) var currentQuestion: Question?
    @Published var selectedAnswer: String?
    @Published var showExplanation = false
    private var questions: [Question] = []
    private var cancellables = Set<AnyCancellable>()
    @Published private(set) var currentIndex = 0
    @Published var correctAnswers: Int = 0

    // ì§ˆë¬¸ ìƒì„± ê´€ë ¨ í”„ë¡œí¼í‹° ì¶”ê°€
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    
    func setStatViewModel(_ viewModel: StatViewModel) {
        self.statViewModel = viewModel
        print("StatViewModel connected: \(viewModel)")  // ì—°ê²° í™•ì¸ ë¡œê·¸
    }

    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }

    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }

    var totalQuestions: Int {
        questions.count
    }

    private let context: NSManagedObjectContext
    private var currentSession: CDStudySession?
    private let homeViewModel: HomeViewModel

    private var hasInitialized = false

    init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
        self.context = context
        self.homeViewModel = homeViewModel
        
        // OpenAIService ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ì‚¬ìš©
        self.openAIService = OpenAIService.shared

        Task { @MainActor in
            homeViewModel.$selectedProblemSet
                .compactMap { $0 }
                .removeDuplicates(by: { $0.id == $1.id })
                .receive(on: RunLoop.main)
                .sink { [weak self] problemSet in
                    guard let self = self else { return }
                    Task {
                        await self.resetState()
                        await MainActor.run {
                            self.loadQuestions(problemSet.questions)
                        }
                    }
                }
                .store(in: &self.cancellables)
        }

        setupCurrentSession()
    }


    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []

        // ì˜ˆìƒë˜ëŠ” ì´ ì§ˆë¬¸ ìˆ˜ ê³„ì‚°
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)

        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            await MainActor.run {
                questions.forEach { question in
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }

        await MainActor.run {
            isGeneratingQuestions = false
            loadedQuestions = generatedQuestions
            loadingProgress = 100
            isLoadingQuestions = false
        }
    }
    
    @MainActor
    func loadUpdatedQuestions(_ problemSetId: String) async {
        if let updatedSet = try? await homeViewModel.fetchUpdatedProblemSet(problemSetId) {
            questions = updatedSet.questions
            currentQuestion = questions.first
            print("ğŸ“ Loaded updated questions from CoreData - count: \(updatedSet.questions.count)")
        }
    }
    
   
    @MainActor
    func resetState() async {
        print("ğŸ”„ Performing complete state reset")
        currentIndex = 0
        selectedAnswer = nil
        showExplanation = false
        correctAnswers = 0
        
        questions.removeAll()
        
        if let problemSet = homeViewModel.selectedProblemSet {
            // CoreDataì—ì„œ ìµœì‹  ìƒíƒœ ê°€ì ¸ì˜¤ê¸° ì‹œë„
            if let updatedSet = try? await homeViewModel.fetchUpdatedProblemSet(problemSet.id) {
                questions = updatedSet.questions
                currentQuestion = updatedSet.questions.first
                print("ğŸ“ Updated questions loaded from CoreData - count: \(updatedSet.questions.count)")
            } else {
                // ì‹¤íŒ¨ ì‹œ ë©”ëª¨ë¦¬ì˜ ë¬¸ì œ ì„¸íŠ¸ ì‚¬ìš©
                questions = problemSet.questions
                currentQuestion = problemSet.questions.first
                print("âš ï¸ Using memory cached questions - count: \(problemSet.questions.count)")
            }
        }
        
        print("""
        âœ… State reset complete:
        â€¢ Questions count: \(questions.count)
        â€¢ Current index: \(currentIndex)
        â€¢ Current question: \(currentQuestion?.question ?? "No question loaded")
        """)
    }
   
    @MainActor
    func loadQuestions(_ newQuestions: [Question]) {
        guard questions != newQuestions else {
            print("âš ï¸ Same questions already loaded, skipping")
            return
        }
        
        print("ğŸ“ Loading fresh set of \(newQuestions.count) questions")
        questions = newQuestions
        currentIndex = 0
        currentQuestion = questions.isEmpty ? nil : questions[0]
        
        print("âœ… Questions loaded: \(currentQuestion?.question ?? "No question loaded")")
    }
   
    private func setupCurrentSession() {
        let session = CDStudySession(context: context)
        session.startTime = Date()
        session.questions = NSSet() // Initialize empty questions set
        currentSession = session
        saveContext()
        print("ğŸ“ New study session created at: \(session.startTime?.description ?? "unknown")")
    }
   
    func submitAnswer() {
        guard let currentQuestion = currentQuestion else { return }
        
        let trimmedSelected = selectedAnswer?.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedCorrect = currentQuestion.correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let isCorrect = trimmedSelected == trimmedCorrect
        
        if isCorrect {
            correctAnswers += 1
        }
        
        // StatViewModel ì—…ë°ì´íŠ¸ ë° CoreData ì €ì¥
        NotificationCenter.default.post(
            name: .studyProgressDidUpdate,
            object: nil,
            userInfo: [
                "currentIndex": currentIndex + 1,
                "correctAnswers": correctAnswers
            ]
        )
        
        showExplanation = true
    }
    
    
   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
    private func saveContext() {
        do {
            if context.hasChanges {
                try context.save()
                print("âœ… Context saved successfully")
            }
        } catch {
            print("âŒ Failed to save context: \(error)")
        }
    }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("âœ… Question save state toggled successfully")
       } catch {
           print("âŒ Failed to toggle question save state: \(error)")
       }
   }
}


// ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @State private var isLoading = true

    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
        setupMetal()
    }

    var body: some Scene {
        WindowGroup {
            if isLoading {
                AnimatedSplashScreen()
                    .onAppear {
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ë©”ì¸ í™”ë©´ìœ¼ë¡œ ì „í™˜
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                            withAnimation(.easeOut(duration: 0.3)) {
                                isLoading = false
                            }
                        }
                    }
            } else {
                MainTabView()
                    .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
            }
        }
    }
    
    private func setupMetal() {
        // Metal ë””ë°”ì´ìŠ¤ ì²´í¬
        guard MTLCreateSystemDefaultDevice() != nil else {
            print("Metal is not supported on this device")
            return
        }
        
        // MetalTools í”„ë ˆì„ì›Œí¬ ì´ˆê¸°í™” ì§€ì—°
        DispatchQueue.main.async {
            // MetalTools ê´€ë ¨ ì‘ì—…
        }
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        
        // OpenAI API Key ì´ˆê¸° ì„¤ì •
        Task {
            do {
                try await OpenAIService.shared.fetchAPIKey()
                print("âœ… Successfully initialized OpenAI API Key")
            } catch {
                print("âŒ Failed to fetch OpenAI API Key: \(error)")
            }
        }
        
        return true
    }
    
    // ì•± ì¢…ë£Œ ì‹œ API Key ì •ë¦¬
    func applicationWillTerminate(_ application: UIApplication) {
        OpenAIService.shared.cleanup()
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        ğŸ“Š CoreData Configuration:
        â€¢ Store Descriptions: \(container.persistentStoreDescriptions.count)
        â€¢ View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("âŒ No store URL found")
            return
        }
        
        print("â€¢ Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("âœ… Created CoreData directory")
        } catch {
            print("âŒ Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData ì˜µì…˜ ì„¤ì •
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // ì„±ëŠ¥ ìµœì í™” ì„¤ì •
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


struct AnimatedSplashScreen: View {
    @State private var isAnimating = false
    @State private var iconScale: CGFloat = 0.3
    @State private var titleOpacity = 0.0
    @State private var subtitleOpacity = 0.0
    
    var body: some View {
        ZStack {
            // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜
            LinearGradient(
                gradient: Gradient(colors: [Color.blue, Color.blue.opacity(0.8)]),
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
            
            VStack(spacing: 20) {
                // ì•„ì´ì½˜ ì• ë‹ˆë©”ì´ì…˜
                Image(systemName: "doc.text.viewfinder")
                    .font(.system(size: 80))
                    .foregroundColor(.white)
                    .scaleEffect(iconScale)
                    .rotationEffect(.degrees(isAnimating ? 360 : 0))
                
                // ì•± íƒ€ì´í‹€
                Text("AISnapStudy")
                    .font(.system(size: 36, weight: .bold))
                    .foregroundColor(.white)
                    .opacity(titleOpacity)
                
                // ì„œë¸Œíƒ€ì´í‹€
                Text("Learn Smarter with AI")
                    .font(.title3)
                    .foregroundColor(.white.opacity(0.8))
                    .opacity(subtitleOpacity)
                
                // ë¡œë”© ì¸ë””ì¼€ì´í„°
                if isAnimating {
                    LoadingDots()
                        .frame(height: 40)
                }
            }
        }
        .onAppear {
            withAnimation(.spring(response: 0.8, dampingFraction: 0.5)) {
                iconScale = 1.0
                isAnimating = true
            }
            
            withAnimation(.easeIn(duration: 0.4).delay(0.3)) {
                titleOpacity = 1.0
            }
            
            withAnimation(.easeIn(duration: 0.4).delay(0.5)) {
                subtitleOpacity = 1.0
            }
        }
    }
}

// ë¡œë”© ë‹· ì• ë‹ˆë©”ì´ì…˜
struct LoadingDots: View {
    @State private var animationStage = 0
    
    var body: some View {
        HStack(spacing: 8) {
            ForEach(0..<3) { index in
                Circle()
                    .fill(Color.white)
                    .frame(width: 8, height: 8)
                    .scaleEffect(animationStage == index ? 1.5 : 1)
                    .opacity(animationStage == index ? 1 : 0.5)
            }
        }
        .onAppear {
            Timer.scheduledTimer(withTimeInterval: 0.4, repeats: true) { timer in
                withAnimation(.spring()) {
                    animationStage = (animationStage + 1) % 3
                }
            }
        }
    }
}

// ì•± ìŠ¤íƒ€ì¼ ì„¤ì •
extension AISnapStudyApp {
    private func setupAppearance() {
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        appearance.backgroundColor = UIColor.systemBackground
        appearance.titleTextAttributes = [.foregroundColor: UIColor.label]
        appearance.largeTitleTextAttributes = [.foregroundColor: UIColor.label]
        
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        UINavigationBar.appearance().compactAppearance = appearance
        
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        tabBarAppearance.backgroundColor = UIColor.systemBackground
        
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}


// ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


// ./AISnapStudy/Utils/Extensions/Calendar+Extension.swift

import Foundation

extension Calendar {
    
    func monthDateRange(for date: Date) -> (start: Date, end: Date) {
        let components = dateComponents([.year, .month], from: date)
        let startOfMonth = self.date(from: components)!
        
        var nextMonthComponents = DateComponents()
        nextMonthComponents.month = 1
        let endOfMonth = self.date(
            byAdding: nextMonthComponents,
            to: startOfMonth
        )!
        
        return (startOfMonth, endOfMonth)
    }
    
    func startOfMonth(for date: Date) -> Date {
        let components = dateComponents([.year, .month], from: date)
        return self.date(from: components) ?? date
    }
    
    func endOfMonth(for date: Date) -> Date {
        guard let startOfNextMonth = self.date(
            byAdding: DateComponents(month: 1),
            to: startOfMonth(for: date)
        ) else { return date }
        
        return self.date(
            byAdding: DateComponents(second: -1),
            to: startOfNextMonth
        ) ?? date
    }
}


// ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


// ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


// ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



// ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


// ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


// ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    var questionsCompleted: Int
    var correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    var week: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MM/dd" // ì›”/ì¼ í˜•ì‹
        return formatter.string(from: date)
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


// ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // ì¶”ê°€: Structured Outputsì˜ refusal ì²˜ë¦¬ë¥¼ ìœ„í•´
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


// ./AISnapStudy/Models/ProblemSet.swift

import Foundation
import SwiftUI
import UniformTypeIdentifiers

public final class ProblemSet: Identifiable, Codable, Equatable {
    // Core properties
    public var isFavorite: Bool
    public let id: String
    public let subject: SubjectType
    public let subjectType: String
    public let subjectId: String
    public let subjectName: String
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?

    public var questionCount: Int {
        questions.count
    }
    
    // Equatable í”„ë¡œí† ì½œ êµ¬í˜„
    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id && lhs.createdAt == rhs.createdAt
    }
    
    // Hashable í”„ë¡œí† ì½œ êµ¬í˜„
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(createdAt)
    }

    public var resolvedSubject: SubjectType {
        if subjectType == "default" {
            return DefaultSubject(rawValue: subjectId) ?? .generalKnowledge
        } else {
            return SubjectManager.shared.customSubjects.first(where: { $0.id == subjectId }) ?? DefaultSubject.generalKnowledge
        }
    }
    

    // CustomSubjectë¥¼ ìœ„í•œ ìƒì„±ì
    public init(
        id: String = UUID().uuidString,
        subject: SubjectType,
        subjectType: String,
        subjectId: String,
        subjectName: String,
        questions: [Question],
        createdAt: Date = Date(),
        educationLevel: EducationLevel,
        name: String,
        isFavorite: Bool = false  // ê¸°ë³¸ê°’ falseë¡œ ì„¤ì •
    ) {
        self.id = id
        self.subject = subject
        self.subjectType = subjectType
        self.subjectId = subjectId
        self.subjectName = subjectName
        self.questions = questions
        self.createdAt = createdAt
        self.educationLevel = educationLevel
        self.name = name
        self.tags = []
        self.problemSetDescription = nil
        self.isFavorite = isFavorite
    }
    
    // toggleFavorite ë©”ì„œë“œ ì¶”ê°€
    public func toggleFavorite() -> ProblemSet {
        return ProblemSet(
            id: self.id,
            subject: self.subject,
            subjectType: self.subjectType,
            subjectId: self.subjectId,
            subjectName: self.subjectName,
            questions: self.questions,
            createdAt: self.createdAt,
            educationLevel: self.educationLevel,
            name: self.name,
            isFavorite: !self.isFavorite  // toggle the favorite status
        )
    }
    

    private enum CodingKeys: String, CodingKey {
        case id, subject, subjectType, subjectId, subjectName
        case questions, createdAt, lastAttempted
        case educationLevel, name, tags
        case problemSetDescription, isFavorite
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        
        // Properly decode subject based on subjectType
        subjectType = try container.decode(String.self, forKey: .subjectType)
        subjectId = try container.decode(String.self, forKey: .subjectId)
        subjectName = try container.decode(String.self, forKey: .subjectName)
        
        if subjectType == "custom" {
            subject = CustomSubject(id: subjectId, name: subjectName, icon: "book.fill")
        } else {
            subject = try container.decode(DefaultSubject.self, forKey: .subject)
        }
        
        // Decode remaining properties
        questions = try container.decode([Question].self, forKey: .questions)
        createdAt = try container.decode(Date.self, forKey: .createdAt)
        lastAttempted = try container.decodeIfPresent(Date.self, forKey: .lastAttempted)
        educationLevel = try container.decode(EducationLevel.self, forKey: .educationLevel)
        name = try container.decode(String.self, forKey: .name)
        tags = try container.decode([String].self, forKey: .tags)
        problemSetDescription = try container.decodeIfPresent(String.self, forKey: .problemSetDescription)
        isFavorite = try container.decode(Bool.self, forKey: .isFavorite)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(subject, forKey: .subject)
        try container.encode(subjectType, forKey: .subjectType)
        try container.encode(subjectId, forKey: .subjectId)
        try container.encode(subjectName, forKey: .subjectName)
        try container.encode(questions, forKey: .questions)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(lastAttempted, forKey: .lastAttempted)
        try container.encode(educationLevel, forKey: .educationLevel)
        try container.encode(name, forKey: .name)
        try container.encode(tags, forKey: .tags)
        try container.encodeIfPresent(problemSetDescription, forKey: .problemSetDescription)
        try container.encode(isFavorite, forKey: .isFavorite)
    }
    
    // ì§ˆë¬¸ ì‚­ì œ ë©”ì†Œë“œ ì¶”ê°€
    public func removeQuestion(_ questionId: String) -> ProblemSet {
        let updatedQuestions = questions.filter { $0.id != questionId }
        return ProblemSet(
            id: self.id,
            subject: self.subject,
            subjectType: self.subjectType,
            subjectId: self.subjectId,
            subjectName: self.subjectName,
            questions: updatedQuestions,
            createdAt: self.createdAt,
            educationLevel: self.educationLevel,
            name: self.name
        )
    }
    
    static func merge(problemSets: [ProblemSet], name: String) -> ProblemSet {
        let mergedQuestions = problemSets.flatMap { $0.questions }
        let firstSet = problemSets[0]
        
        return ProblemSet(
            id: UUID().uuidString,
            subject: firstSet.subject,
            subjectType: firstSet.subjectType,
            subjectId: firstSet.subjectId,
            subjectName: firstSet.subjectName,
            questions: mergedQuestions,
            createdAt: Date(),
            educationLevel: firstSet.educationLevel,
            name: name
        )
    }
}

// ProblemSet extension ì¶”ê°€
extension ProblemSet: Transferable {
    public static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .problemSet)
    }
}

// UTType extension ì¶”ê°€
extension UTType {
    static var problemSet: UTType {
        UTType(exportedAs: "com.aisnapquiz.problemset")
    }
}

extension ProblemSet {
    static func merge(_ sets: [ProblemSet], name: String) -> ProblemSet {
        let allQuestions = sets.flatMap { $0.questions }
        // ì²« ë²ˆì§¸ ì„¸íŠ¸ì˜ ì†ì„±ë“¤ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©
        let firstSet = sets[0]
        
        return ProblemSet(
            id: UUID().uuidString,
            subject: firstSet.subject,
            subjectType: firstSet.subjectType,
            subjectId: firstSet.subjectId,
            subjectName: firstSet.subjectName,
            questions: allQuestions,
            createdAt: Date(),
            educationLevel: firstSet.educationLevel,
            name: name,
            isFavorite: firstSet.isFavorite  // ì¦ê²¨ì°¾ê¸° ìƒíƒœ ìœ ì§€
        )
    }
}


// ./AISnapStudy/Models/ReviewFilter.swift


import Foundation

enum ReviewFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



// ./AISnapStudy/Models/PurchaseProduct.swift


import Foundation


struct UserSubscriptionStatus: Codable {
    var isPremium: Bool
    var dailyQuestionsRemaining: Int
    var lastResetDate: Date?
    
    static let defaultStatus = UserSubscriptionStatus(
        isPremium: false,
        dailyQuestionsRemaining: 1,
        lastResetDate: nil
    )
}


// ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
   case multipleChoice = "multiple_choice"
   case trueFalse = "true_false"
}

public struct Question: Identifiable, Codable, Hashable {
   public let id: String
   public let type: QuestionType
   public let subject: DefaultSubject  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
   public let question: String
   public let options: [String]
   public let correctAnswer: String
   public let explanation: String
   public let hint: String?
   public var isSaved: Bool
   public let createdAt: Date
   
   private enum CodingKeys: String, CodingKey {
       case id, type, subject, question, options
       case correctAnswer, explanation, hint
       case isSaved, createdAt
   }
   
   public init(
       id: String,
       type: QuestionType,
       subject: DefaultSubject,  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
       question: String,
       options: [String] = [],
       correctAnswer: String,
       explanation: String,
       hint: String? = nil,
       isSaved: Bool = false,
       createdAt: Date = Date()
   ) {
       self.id = id
       self.type = type
       self.subject = subject
       self.question = question
       self.options = options
       self.correctAnswer = correctAnswer
       self.explanation = explanation
       self.hint = hint
       self.isSaved = isSaved
       self.createdAt = createdAt
   }
   
   // Decodable êµ¬í˜„
   public init(from decoder: Decoder) throws {
       let container = try decoder.container(keyedBy: CodingKeys.self)
       
       id = try container.decode(String.self, forKey: .id)
       type = try container.decode(QuestionType.self, forKey: .type)
       subject = try container.decode(DefaultSubject.self, forKey: .subject)
       question = try container.decode(String.self, forKey: .question)
       options = try container.decode([String].self, forKey: .options)
       correctAnswer = try container.decode(String.self, forKey: .correctAnswer)
       explanation = try container.decode(String.self, forKey: .explanation)
       hint = try container.decodeIfPresent(String.self, forKey: .hint)
       isSaved = try container.decode(Bool.self, forKey: .isSaved)
       createdAt = try container.decode(Date.self, forKey: .createdAt)
   }
    // Hashable í”„ë¡œí† ì½œ ìš”êµ¬ì‚¬í•­ì„ ì—¬ê¸°ì— ì§ì ‘ êµ¬í˜„
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
   
   // Encodable êµ¬í˜„
   public func encode(to encoder: Encoder) throws {
       var container = encoder.container(keyedBy: CodingKeys.self)
       
       try container.encode(id, forKey: .id)
       try container.encode(type, forKey: .type)
       try container.encode(subject, forKey: .subject)
       try container.encode(question, forKey: .question)
       try container.encode(options, forKey: .options)
       try container.encode(correctAnswer, forKey: .correctAnswer)
       try container.encode(explanation, forKey: .explanation)
       try container.encodeIfPresent(hint, forKey: .hint)
       try container.encode(isSaved, forKey: .isSaved)
       try container.encode(createdAt, forKey: .createdAt)
   }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
   public static var supportsSecureCoding: Bool {
       return true
   }
   
   let question: Question
   
   init(question: Question) {
       self.question = question
       super.init()
   }
   
   public func encode(with coder: NSCoder) {
       coder.encode(question.id, forKey: "id")
       coder.encode(question.type.rawValue, forKey: "type")
       coder.encode(question.subject.rawValue, forKey: "subject")
       coder.encode(question.question, forKey: "question")
       coder.encode(question.options, forKey: "options")
       coder.encode(question.correctAnswer, forKey: "correctAnswer")
       coder.encode(question.explanation, forKey: "explanation")
       coder.encode(question.hint, forKey: "hint")
       coder.encode(question.isSaved, forKey: "isSaved")
       coder.encode(question.createdAt, forKey: "createdAt")
   }
   
   public required init?(coder: NSCoder) {
       guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
             let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
             let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
             let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
             let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
             let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
             let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
           return nil
       }
       
       let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
       let isSaved = coder.decodeBool(forKey: "isSaved")
       let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
       
       let question = Question(
           id: id,
           type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
           subject: DefaultSubject(rawValue: subjectRaw) ?? .generalKnowledge,  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
           question: questionText,
           options: options,
           correctAnswer: correctAnswer,
           explanation: explanation,
           hint: hint,
           isSaved: isSaved,
           createdAt: createdAt
       )
       
       self.question = question
       super.init()
   }
}

extension Question {
    var processedCorrectAnswer: String {
        switch type {
        case .trueFalse:
            return correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        case .multipleChoice:
            return correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines)
        }
    }
}


// ./AISnapStudy/Models/UserStats.swift

import Foundation

struct StreakInfo: Codable {
    let currentStreak: Int
    let longestStreak: Int
    let lastActiveDate: Date
}


// ./AISnapStudy/Models/Subject.swift


import SwiftUI

// MARK: - Basic Subject Protocol
public protocol SubjectType: Codable {
   var id: String { get }
   var displayName: String { get }
   var color: Color { get }
   var icon: String { get }
   var rawValue: String { get }  // ì¶”ê°€
}



// MARK: - Default System Subjects
public enum DefaultSubject: String, Codable, CaseIterable, SubjectType {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    case download = "download"  // ìƒˆë¡œìš´ case ì¶”ê°€
    
    public var id: String {
        self.rawValue
    }
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        case .download:
            return .blue  // ë‹¤ìš´ë¡œë“œ ì„¹ì…˜ì„ ìœ„í•œ ìƒˆë¡œìš´ ìƒ‰ìƒ
        }
    }
    
    static var defaultSubject: DefaultSubject {
        return .generalKnowledge
    }
    
    public var displayName: String {
        SubjectManager.shared.modifiedDefaultSubjects[self.id] ?? defaultDisplayName
    }
    
    private var defaultDisplayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        case .download:
            return "Downloaded Sets"  // ë‹¤ìš´ë¡œë“œëœ ì„¸íŠ¸ë¥¼ ìœ„í•œ í‘œì‹œ ì´ë¦„
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        case .download:
            return "square.and.arrow.down.fill"  // ë‹¤ìš´ë¡œë“œ ì•„ì´ì½˜
        }
    }
}

// CustomSubject êµ¬ì¡°ì²´ ì¶”ê°€
public struct CustomSubject: SubjectType, Codable, Identifiable {
    public let id: String
    public var name: String  // letì„ varë¡œ ë³€ê²½
    public let icon: String
    public var isActive: Bool
    
    // SubjectType í”„ë¡œí† ì½œ ìš”êµ¬ì‚¬í•­
    public var displayName: String { name }
    public var color: Color { .green }  // ê³„ì‚° í”„ë¡œí¼í‹°ë¡œ ë³€ê²½
    public var rawValue: String { id }  // ì¶”ê°€: idë¥¼ rawValueë¡œ ì‚¬ìš©
    
    // ê¸°ë³¸ ì´ˆê¸°í™”ì
    public init(id: String = UUID().uuidString,
                name: String,
                icon: String,
                isActive: Bool = true) {
        self.id = id
        self.name = name
        self.icon = icon
        self.isActive = isActive
    }
    
    // Codable êµ¬í˜„
    enum CodingKeys: String, CodingKey {
        case id, name, icon, isActive
        // colorëŠ” ì œì™¸ - í•­ìƒ .greenì„ ì‚¬ìš©í•  ê²ƒì´ë¯€ë¡œ
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        icon = try container.decode(String.self, forKey: .icon)
        isActive = try container.decode(Bool.self, forKey: .isActive)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(icon, forKey: .icon)
        try container.encode(isActive, forKey: .isActive)
    }
}



// MARK: - Custom User Subject
public struct UserSubject: Identifiable, Codable, Hashable, SubjectType {
   public let id: String
   public var name: String
   public var colorHex: String
   public var iconName: String
   public var createdAt: Date
   public var isActive: Bool
   
   public var displayName: String {
       name
   }
   
   public var color: Color {
       Color(hex: colorHex) ?? .gray
   }
   
   public var icon: String {
       iconName
   }
    
    public var rawValue: String { id }  // ì¶”ê°€: idë¥¼ rawValueë¡œ ì‚¬ìš©
}

// MARK: - Education Level
public enum EducationLevel: String, Codable, CaseIterable {
   case elementary = "elementary"
   case middle = "middle"
   case high = "high"
   case college = "college"
   
   public var displayName: String {
       switch self {
       case .elementary:
           return "Elementary"
       case .middle:
           return "Middle"
       case .high:
           return "High"
       case .college:
           return "College"
       }
   }
   
   public var color: Color {
       switch self {
       case .elementary:
           return .green
       case .middle:
           return .green
       case .high:
           return .green
       case .college:
           return .green
       }
   }
}

public class SubjectManager: ObservableObject {
    public static let shared = SubjectManager()
    
    private init() {
        loadSettings()
        loadCustomSubjects()
    }
    
    @Published private(set) var customSubjects: [CustomSubject] = []
    @Published private(set) var hiddenDefaultSubjects: Set<String> = []
    @Published private(set) var modifiedDefaultSubjects: [String: String] = [:]
    
    // ìƒˆë¡œìš´ ê³¼ëª© ì¶”ê°€
    func addCustomSubject(name: String, icon: String = "book.circle") {
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveCustomSubjects()
    }
    
    // ê³¼ëª© ì œê±°
    func removeCustomSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveCustomSubjects()
    }
    
    // UserDefaultsë¥¼ ì‚¬ìš©í•œ ì €ì¥ ë° ë¡œë“œ
    private func saveCustomSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    private func loadCustomSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            self.customSubjects = decoded
        }
    }
    
    // "ì‚­ì œëœ" ê³¼ëª© ë³µì›ì„ ìœ„í•œ ë°±ì—… ì €ì¥
    private var deletedSubjectsBackup: Set<String> = []
    
    func isDeleted(_ subjectId: String) -> Bool {
            return hiddenDefaultSubjects.contains(subjectId)
        }
        
    func toggleDefaultSubject(_ subject: DefaultSubject) {
        print("ğŸ”„ Toggling subject visibility: \(subject.displayName)")
        if hiddenDefaultSubjects.contains(subject.id) {
            print("â– Removing from hidden: \(subject.id)")
            hiddenDefaultSubjects.remove(subject.id)
        } else {
            print("â• Adding to hidden: \(subject.id)")
            hiddenDefaultSubjects.insert(subject.id)
        }
        saveAndNotify()
        print("ğŸ“Š Current hidden subjects: \(hiddenDefaultSubjects)")
    }
        
    private func saveAndNotify() {
        saveSettings()
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    // ë¡œë“œ ì‹œ UserDefaultsì—ì„œ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
    private func loadSettings() {
        if let hidden = UserDefaults.standard.array(forKey: "hiddenDefaultSubjects") as? [String] {
            hiddenDefaultSubjects = Set(hidden)
        }
        modifiedDefaultSubjects = UserDefaults.standard.dictionary(forKey: "modifiedDefaultSubjects") as? [String: String] ?? [:]
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
        }
        // ë³€ê²½ì‚¬í•­ì„ ì•Œë¦¼
        notifySubjectsChange()
    }

    
    // ê³¼ëª© ì´ë¦„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
    func updateDefaultSubjectName(_ subject: DefaultSubject, newName: String) {
        print("âœï¸ Updating name for subject: \(subject.displayName) to: \(newName)")
        modifiedDefaultSubjects[subject.id] = newName
        print("ğŸ’¾ Current modified names: \(modifiedDefaultSubjects)")
        saveAndNotify()
    }
    
    // ê³¼ëª© ì´ë¦„ ì´ˆê¸°í™” í•¨ìˆ˜ ìˆ˜ì •
    func resetDefaultSubjectName(_ subject: DefaultSubject) {
        modifiedDefaultSubjects.removeValue(forKey: subject.id)
        saveAndNotify()
    }
    
    // ë³€ê²½ì‚¬í•­ ì•Œë¦¼ì„ ìœ„í•œ NotificationCenter í‚¤
    static let subjectsDidChangeNotification = Notification.Name("SubjectsDidChange")
    
    private func notifySubjectsChange() {
        DispatchQueue.main.async {
            NotificationCenter.default.post(
                name: Self.subjectsDidChangeNotification,
                object: self
            )
        }
    }
    
    
    // ê³¼ëª© "ì‚­ì œ" (ì‹¤ì œë¡œëŠ” ìˆ¨ê¹€)
    func deleteDefaultSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.insert(subject.id)
        deletedSubjectsBackup.insert(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // ì‚­ì œëœ ê³¼ëª© ë³µì›
    func restoreDeletedSubject(_ subject: DefaultSubject) {
        hiddenDefaultSubjects.remove(subject.id)
        deletedSubjectsBackup.remove(subject.id)
        saveSettings()
        notifySubjectsChange()
    }
    
    // ê³¼ëª©ì´ "ì‚­ì œ"ë˜ì—ˆëŠ”ì§€ í™•ì¸
    func isDeleted(_ subject: DefaultSubject) -> Bool {
        hiddenDefaultSubjects.contains(subject.id)
    }
    
    // ì‚¬ìš© ê°€ëŠ¥í•œ(ì‚­ì œë˜ì§€ ì•Šì€) ê³¼ëª©ë“¤ ê°€ì ¸ì˜¤ê¸°
    var availableSubjects: [any SubjectType] {
        let visibleDefaultSubjects = DefaultSubject.allCases.filter { !hiddenDefaultSubjects.contains($0.id) }
        let activeCustomSubjects = customSubjects.filter { $0.isActive }
        return visibleDefaultSubjects + activeCustomSubjects
    }
    
    // ì €ì¥ëœ ì„¤ì •ì— ì‚­ì œëœ ê³¼ëª© ì •ë³´ í¬í•¨
    private func saveSettings() {
        UserDefaults.standard.set(Array(hiddenDefaultSubjects), forKey: "hiddenDefaultSubjects")
        UserDefaults.standard.set(Array(deletedSubjectsBackup), forKey: "deletedSubjectsBackup")
        UserDefaults.standard.set(modifiedDefaultSubjects, forKey: "modifiedDefaultSubjects")
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
        }
    }
    
    
    

    
    // ê¸°ë³¸ ê³¼ëª© ì´ë¦„ ê´€ë¦¬ ë©”ì„œë“œ ì¶”ê°€
    func getDisplayName(for subject: DefaultSubject) -> String {
        return modifiedDefaultSubjects[subject.id] ?? subject.displayName
    }
    

    
    // CustomSubject ê´€ë¦¬ ë©”ì„œë“œ
    func updateSubject(_ subject: CustomSubject, newName: String) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].name = newName
            saveSettings()
        }
    }
    
    func toggleSubjectActive(_ subject: CustomSubject) {
        if let index = customSubjects.firstIndex(where: { $0.id == subject.id }) {
            customSubjects[index].isActive.toggle()
            saveSettings()
        }
    }
    
    func deleteSubject(_ subject: CustomSubject) {
        customSubjects.removeAll { $0.id == subject.id }
        saveSettings()
    }
    

    
    // ê¸°ë³¸ ê³¼ëª© ìˆ¨ê¹€ ìƒíƒœ ê´€ë¦¬
        func toggleSubjectVisibility(_ subject: DefaultSubject) {
            if hiddenDefaultSubjects.contains(subject.id) {
                hiddenDefaultSubjects.remove(subject.id)
            } else {
                hiddenDefaultSubjects.insert(subject.id)
            }
            saveSettings()
        }
        
        // ê³¼ëª©ì´ ìˆ¨ê²¨ì ¸ ìˆëŠ”ì§€ í™•ì¸
        func isHidden(_ subject: DefaultSubject) -> Bool {
            hiddenDefaultSubjects.contains(subject.id)
        }
        
        
        // ëª¨ë“  í™œì„±í™”ëœ ê³¼ëª© ê°€ì ¸ì˜¤ê¸° (ìˆ¨ê²¨ì§€ì§€ ì•Šì€ ê¸°ë³¸ ê³¼ëª© + í™œì„±í™”ëœ ì‚¬ìš©ì ì •ì˜ ê³¼ëª©)
    var allSubjects: [SubjectType] {
        var subjects: [SubjectType] = Array(DefaultSubject.allCases)
        subjects.append(contentsOf: customSubjects.filter { $0.isActive })
        return subjects
    }
    
    
    // ê³¼ëª© ì¶”ê°€ ë©”ì„œë“œ ìˆ˜ì •
    func addSubject(name: String, icon: String) {  // color ë§¤ê°œë³€ìˆ˜ ì œê±°
        let newSubject = CustomSubject(
            id: UUID().uuidString,
            name: name,
            icon: icon,
            isActive: true
        )
        customSubjects.append(newSubject)
        saveSubjects()
        
        print("""
        âœ… Added new custom subject:
        â€¢ Name: \(name)
        â€¢ ID: \(newSubject.id)
        â€¢ Total custom subjects: \(customSubjects.count)
        """)
    }
    
    // ì €ì¥ ë©”ì„œë“œ ìˆ˜ì •
    private func saveSubjects() {
        if let encoded = try? JSONEncoder().encode(customSubjects) {
            UserDefaults.standard.set(encoded, forKey: "customSubjects")
            print("ğŸ’¾ Saved \(customSubjects.count) custom subjects to UserDefaults")
        }
    }
    
    // ë¡œë“œ ë©”ì„œë“œ ìˆ˜ì •
    private func loadSubjects() {
        if let data = UserDefaults.standard.data(forKey: "customSubjects"),
           let decoded = try? JSONDecoder().decode([CustomSubject].self, from: data) {
            customSubjects = decoded
            print("ğŸ“¤ Loaded \(customSubjects.count) custom subjects from UserDefaults")
            print("ğŸ“š Custom Subjects: \(customSubjects.map { $0.displayName })")
        }
    }
    
}



// MARK: - Color Extension for Hex
extension Color {
    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components else { return nil }
        
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        let hex = String(format: "%02lX%02lX%02lX",
                        lroundf(r * 255),
                        lroundf(g * 255),
                        lroundf(b * 255))
        
        return hex
    }
    
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        
        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else {
            return nil
        }
        
        let r = Double((rgb & 0xFF0000) >> 16) / 255.0
        let g = Double((rgb & 0x00FF00) >> 8) / 255.0
        let b = Double(rgb & 0x0000FF) / 255.0
        
        self.init(red: r, green: g, blue: b)
    }
}


// ./AISnapStudy/Models/DailyStats.swift



import Foundation

struct DailyStats: Identifiable, Codable {
    let id: UUID
    let date: Date
    let totalQuestions: Int
    let correctAnswers: Int
    let wrongAnswers: Int
    let timeSpent: TimeInterval
    
    var accuracy: Double {
        guard totalQuestions > 0 else { return 0 }
        return Double(correctAnswers) / Double(totalQuestions) * 100
    }
    
    // ì´ˆê¸°í™”ìë¥¼ ìˆ˜ì •
    init(
        id: UUID = UUID(),
        date: Date,
        totalQuestions: Int,
        correctAnswers: Int,
        wrongAnswers: Int,
        timeSpent: TimeInterval = 0
    ) {
        self.id = id
        self.date = date
        self.totalQuestions = totalQuestions
        self.correctAnswers = correctAnswers
        self.wrongAnswers = wrongAnswers
        self.timeSpent = timeSpent
    }
}


// ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì €ì¥ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/RemoteQuestionSet.swift

import Foundation

// MARK: - Models
struct RemoteQuestionSet: Codable, Identifiable {
    let id: String
    let title: String
    let description: String
    let category: String
    let difficulty: String
    let questionCount: Int
    let downloadCount: Int
    let createdAt: Date
    let updatedAt: Date
    var isDownloaded: Bool = false  // ê¸°ë³¸ê°’ ì„¤ì •
    
    // CodingKeysë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜í•˜ì—¬ isDownloadedë¥¼ ë””ì½”ë”©ì—ì„œ ì œì™¸
    private enum CodingKeys: String, CodingKey {
        case id, title, description, category
        case difficulty, questionCount, downloadCount
        case createdAt, updatedAt
        // isDownloadedëŠ” CodingKeysì—ì„œ ì œì™¸
    }
}


// ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


// ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


// ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    let onDelete: () -> Void // ì¶”ê°€
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text(question.question)
                    .font(.title3)
                    .fontWeight(.semibold)
                
                Spacer()
                
                Button(action: onDelete) {
                    Image(systemName: "trash")
                        .foregroundColor(.red)
                }
            }
            
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


// ./AISnapStudy/Views/Question/QuestionSettingsView.swift



import SwiftUI
import PhotosUI
import UIKit
import AVFoundation

struct QuestionSettingsView: View {
    @FocusState private var isTextFieldFocused: Bool // ì¶”ê°€
    @StateObject private var viewModel: QuestionSettingsViewModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedTab: Int
    @State private var expandedSections: Set<SectionType> = []
    @State private var isTextInputSelected = false
    @State private var showNamePopup = false
    @State private var isGeneratingQuestions = false
    @State private var activeSheet: ActiveSheet?
    
    // ì—¬ê¸°ë¥¼ Subjectì—ì„œ DefaultSubjectë¡œ ë³€ê²½
    let subject: DefaultSubject  // Subjectë¥¼ DefaultSubjectë¡œ ë³€ê²½
    
    public enum SectionType: Hashable {
        case questionAbout
        case learningSubject
        case questionTypes
        case educationLevel
    }
    
    private enum ActiveSheet: Identifiable {
        case camera, gallery
        
        var id: Int {
            switch self {
            case .camera: return 1
            case .gallery: return 2
            }
        }
    }
    
    
    init(subject: DefaultSubject, homeViewModel: HomeViewModel, selectedTab: Binding<Int>) {
        self.subject = subject
        self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
            subject: subject,
            homeViewModel: homeViewModel
        ))
        self._selectedTab = selectedTab
    }
    
    var body: some View {
        ScrollViewReader { proxy in
            VStack(spacing: 0) {
                // Instructions Card
                Form {
                    // Speed Up and Language Selection Section
                    Section {
                        SpeedUpSection(useTextExtraction: $viewModel.useTextExtraction)
                    }
                    .listRowSpacing(0)
                    
                    Section {
                        LanguageSection(selectedLanguage: $viewModel.selectedLanguage)
                    }
                    .listRowSpacing(0)
                    
                    VStack(alignment: .leading, spacing: 10) {
                        Text("How to Generate Questions")
                            .font(.headline)
                            .padding(.bottom, 4)
                        
                        Text("Select one of these methods here and then choose Subject and Type to create questions:")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        // Input Methods with descriptions
                        HStack(spacing: 12) {
                            Group {
                                InputMethodCard(
                                    icon: "camera.fill",
                                    title: "Camera",
                                    isUsed: viewModel.hasSelectedCamera,
                                    isDisabled: !viewModel.canUseImageInput,
                                    action: {
                                        if viewModel.canUseImageInput {
                                            viewModel.isTextInputActive = false
                                            Task {
                                                if await viewModel.checkCameraPermission() {
                                                    activeSheet = .camera
                                                }
                                            }
                                        }
                                    }
                                )
                                .frame(maxWidth: .infinity)
                            }
                            
                            Group {
                                InputMethodCard(
                                    icon: "photo.fill",
                                    title: "Gallery",
                                    isUsed: viewModel.hasSelectedGallery,
                                    isDisabled: !viewModel.canUseImageInput,
                                    action: {
                                        if viewModel.canUseImageInput {
                                            viewModel.isTextInputActive = false
                                            Task {
                                                if await viewModel.checkGalleryPermission() {
                                                    activeSheet = .gallery
                                                }
                                            }
                                        }
                                    }
                                )
                                .frame(maxWidth: .infinity)
                            }
                            
                            Group {
                                InputMethodCard(
                                    icon: "text.bubble.fill",
                                    title: "Text",
                                    isUsed: viewModel.isTextInputActive,
                                    isDisabled: !viewModel.canUseTextInput,
                                    action: {
                                        viewModel.toggleTextInput()
                                        isTextFieldFocused = viewModel.isTextInputActive
                                    }
                                )
                                .frame(maxWidth: .infinity)
                            }
                        }
                    }
                    .padding()
                    .background(Color(.systemBackground))
                    .cornerRadius(12)
                    
                    // Text Input Field
                    if viewModel.isTextInputActive {
                        TextField("Enter your question here...", text: $viewModel.questionText)
                            .textFieldStyle(RoundedBorderTextFieldStyle())
                            .focused($isTextFieldFocused)
                            .padding(.horizontal)
                    }
                    
                    // Selected Images Display
                    if !viewModel.selectedImages.isEmpty {
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 12) {
                                ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                    SelectedImageCell(
                                        image: viewModel.selectedImages[index],
                                        onDelete: {
                                            viewModel.removeImage(at: index)
                                        }
                                    )
                                }
                            }
                            .padding(.vertical, 8)
                        }
                    }
                    
                    // Subject Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .learningSubject)
                        ) {
                            LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                        } label: {
                            HStack {
                                Text("Subject")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.selectedSubject.displayName)
                                    .foregroundColor(.gray)
                            }
                        }.id(SectionType.learningSubject) // ID ì¶”ê°€
                    }.listRowSpacing(0)
                    
                    if viewModel.isTextInputActive {
                        Section {
                            DisclosureGroup(
                                isExpanded: isExpandedBinding(for: .educationLevel)
                            ) {
                                EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                            } label: {
                                HStack {
                                    Text("Education")
                                        .font(.headline)
                                    Spacer()
                                    Text(viewModel.educationLevel.displayName)
                                        .foregroundColor(.gray)
                                }
                            }.id(SectionType.educationLevel) // ID ì¶”ê°€
                        }.listRowSpacing(0)
                    }
                    
                    // Question Types Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .questionTypes)
                        ) {
                            QuestionTypesSelectionSection(viewModel: viewModel)
                        } label: {
                            HStack {
                                Text("Type")
                                    .font(.headline)
                                Spacer()
                                Text("\(viewModel.totalQuestionCount) questions")
                                    .foregroundColor(.gray)
                            }
                        }.id(SectionType.questionTypes)
                    }.listRowSpacing(0)
                }
                .listSectionSpacing(4)
                
                // Generate Questions Button and Keyboard Dismiss Button
                VStack {
                    HStack {
                        Button(action: {
                            showNamePopup = true
                            isGeneratingQuestions = true
                            isTextFieldFocused = false  // í‚¤ë³´ë“œ ë‚´ë¦¬ê¸°
                            Task {
                                await viewModel.sendAllImages()
                            }
                        }) {
                            Text("Generate Questions")
                                .font(.headline)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding()
                                .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                                .cornerRadius(10)
                        }
                        .disabled(!isGenerateButtonEnabled)
                        
                        // í…ìŠ¤íŠ¸ ì…ë ¥ì´ í™œì„±í™”ë˜ì–´ ìˆì„ ë•Œë§Œ í‚¤ë³´ë“œ ë‚´ë¦¬ê¸° ë²„íŠ¼ í‘œì‹œ
                        if viewModel.isTextInputActive {
                            Button(action: {
                                isTextFieldFocused = false  // í‚¤ë³´ë“œ ë‚´ë¦¬ê¸°
                            }) {
                                Image(systemName: "keyboard.chevron.compact.down")
                                    .font(.title2)
                                    .foregroundColor(.blue)
                                    .padding(12)
                                    .background(Color.gray.opacity(0.1))
                                    .cornerRadius(10)
                            }
                        }
                    }
                    .padding()
                }
                .background(Color(UIColor.systemGroupedBackground))
            }
            .overlay(popupOverlay)
            .navigationBarItems(leading: cancelButton)
            .navigationBarTitleDisplayMode(.inline)
            .sheet(item: $activeSheet) { sheet in
                switch sheet {
                case .camera:
                    ImagePicker(
                        image: $viewModel.selectedImage,
                        sourceType: .camera,
                        onImageSelected: { image in
                            Task {
                                await viewModel.handleCameraImage(image)
                            }
                        }
                    )
                    .interactiveDismissDisabled()
                    
                case .gallery:
                    PhotoPicker(
                        selectedImages: $viewModel.selectedImages,
                        useSpeedUp: viewModel.useTextExtraction
                    )
                    .interactiveDismissDisabled()
                    
                }
            }
            .alert(isPresented: $viewModel.showAlert) {
                Alert(
                    title: Text(viewModel.alertTitle),
                    message: Text(viewModel.alertMessage),
                    dismissButton: .default(Text("OK")) {
                        if viewModel.alertTitle == "Success" {
                            dismiss()
                        }
                    }
                )
            }
            .onChange(of: viewModel.shouldShowStudyView) { show in
                if show {
                    dismiss()
                    selectedTab = 1
                }
            }
                    .background(Color(UIColor.systemGroupedBackground))
                    .overlay(popupOverlay)
                    .navigationBarItems(leading: cancelButton)
                    .navigationBarTitleDisplayMode(.inline)
                    .onChange(of: expandedSections) { _ in
                        scrollToActiveSection(using: proxy)
                    }
            }
        }
    
    private func scrollToActiveSection(using proxy: ScrollViewProxy) {
        if let activeSection = expandedSections.first {
            withAnimation {
                proxy.scrollTo(activeSection, anchor: .top) // í™”ë©´ ìƒë‹¨ì— ê³ ì •
            }
        }
    }
    
        private var cancelButton: some View {
            Button("Cancel") {
                viewModel.resetCounts()
                dismiss()
            }
        }
        
        private var popupOverlay: some View {
            Group {
                if showNamePopup {
                    ProblemSetNamePopup(
                        isPresented: $showNamePopup,
                        problemSetName: $viewModel.problemSetName,
                        isGeneratingQuestions: $viewModel.isGeneratingQuestions,
                        defaultName: viewModel.generateDefaultName()
                    ) {
                        viewModel.saveProblemSetName()
                        showNamePopup = false
                        viewModel.shouldShowStudyView = true
                    }
                    .transition(.opacity)
                    .animation(.easeInOut, value: showNamePopup)
                }
            }
        }
        
        private var isGenerateButtonEnabled: Bool {
            let hasInput = !viewModel.selectedImages.isEmpty ||
            (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
            let hasQuestionType = viewModel.totalQuestionCount > 0
            return hasInput && hasQuestionType
        }
        
    private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
        Binding(
            get: { expandedSections.contains(section) },
            set: { isExpanded in
                withAnimation {
                    if isExpanded {
                        expandedSections.insert(section)
                    } else {
                        expandedSections.remove(section)
                    }
                }
            }
        )
    }


}




import SwiftUI

struct ProblemSetNamePopup: View {
    @Binding var isPresented: Bool
    @Binding var problemSetName: String
    @Binding var isGeneratingQuestions: Bool
    let defaultName: String
    let onSubmit: () -> Void

    var body: some View {
        ZStack {
            // ë°˜íˆ¬ëª… ë°°ê²½
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)

            VStack(spacing: 20) {
                // íŒì—… ì œëª©
                Text("Name Your Question Set")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)

                // í…ìŠ¤íŠ¸ ì…ë ¥ í•„ë“œ
                VStack(alignment: .leading, spacing: 8) {
                    Text("Enter a name for your question set:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    ZStack(alignment: .leading) {
                        // Placeholder í…ìŠ¤íŠ¸
                        if problemSetName.isEmpty {
                            Text(defaultName)
                                .foregroundColor(.gray)
                                .padding(.leading, 8)
                        }

                        // ì‹¤ì œ TextField
                        TextField("", text: $problemSetName)
                            .textFieldStyle(PlainTextFieldStyle())
                            .padding(10)
                            .background(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(Color.gray, lineWidth: 1)
                            )
                            .font(.body)
                    }
                }

                // ë²„íŠ¼ ì„¹ì…˜
                Button(action: {
                    if problemSetName.isEmpty {
                        problemSetName = defaultName
                    }
                    if !isGeneratingQuestions {
                        onSubmit()
                    }
                }) {
                    Text(isGeneratingQuestions ? "Generating Questions..." : "Save Name")
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(isGeneratingQuestions ? Color.gray : Color.blue)
                        .cornerRadius(8)
                        .shadow(radius: 5)
                }
                .disabled(isGeneratingQuestions)
            }
            .padding(20)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(.systemBackground))
                    .shadow(color: Color.black.opacity(0.2), radius: 10, x: 0, y: 5)
            )
            .padding(.horizontal, 32)
        }
    }
}





struct SubjectSelectionButton: View {
    let subject: any SubjectType
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.caption)
                    .lineLimit(1)
                    .minimumScaleFactor(0.8)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .padding(.horizontal, 8)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .foregroundColor(isSelected ? subject.color : .gray)
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}



struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // ì¶”ê°€
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSectionë„ ìˆ˜ì •
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // ì´ ë¬¸ì œ ìˆ˜ í‘œì‹œ
                HStack {
                    Text("Type")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/10")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    var body: some View {
        Section("Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    // ê¸°ë³¸ ê³¼ëª©
                    ForEach(DefaultSubject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected subject: \(subject.rawValue)")
                        }
                    }
                    
                    // ì‚¬ìš©ì ì •ì˜ ê³¼ëª©
                    ForEach(subjectManager.customSubjects.filter { $0.isActive }) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject.id == subject.id
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected custom subject: \(subject.name)")
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// ImagePicker, PhotoPicker, LoadingView ë„ ì¶”ê°€
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    let useSpeedUp: Bool // ì¶”ê°€
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = useSpeedUp ? 3 : 1 // Speed Up ì„¤ì •ì— ë”°ë¼ ì œí•œ
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

class CustomImagePickerController: UIImagePickerController {
    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .all // ëª¨ë“  ë°©í–¥ ì§€ì›
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)?
    
    class CustomImagePickerController: UIImagePickerController {
        override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
            return .portrait // ì¹´ë©”ë¼ UIëŠ” í•­ìƒ ì„¸ë¡œ ëª¨ë“œë¡œ ìœ ì§€
        }
    }
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = CustomImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        
        if sourceType == .camera {
            picker.cameraDevice = .rear
            picker.cameraCaptureMode = .photo
            picker.allowsEditing = false
            
            // ì „ì²´ í™”ë©´ ëª¨ë“œë¡œ ì„¤ì •
            picker.modalPresentationStyle = .fullScreen
            
            // ì¹´ë©”ë¼ UIë¥¼ ì„¸ë¡œ ëª¨ë“œë¡œ ê³ ì •
            picker.navigationController?.navigationBar.isHidden = false
            picker.navigationController?.interactivePopGestureRecognizer?.isEnabled = false
        }
        
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController,
                                 didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                // ì´ë¯¸ì§€ëŠ” ì›ë˜ ë°©í–¥ ê·¸ëŒ€ë¡œ ìœ ì§€
                parent.image = image
                parent.onImageSelected?(image)
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

// UIImage extension for orientation fixing
extension UIImage {
    func fixedOrientation() -> UIImage {
        if imageOrientation == .up { return self }
        
        var transform = CGAffineTransform.identity
        
        switch imageOrientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: .pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: .pi/2)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: -.pi/2)
        case .up, .upMirrored:
            break
        @unknown default:
            break
        }
        
        guard let cgImage = self.cgImage else { return self }
        
        let context = CGContext(data: nil,
                              width: Int(size.width),
                              height: Int(size.height),
                              bitsPerComponent: cgImage.bitsPerComponent,
                              bytesPerRow: 0,
                              space: cgImage.colorSpace!,
                              bitmapInfo: cgImage.bitmapInfo.rawValue)!
        
        context.concatenate(transform)
        
        switch imageOrientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
        }
        
        guard let newCGImage = context.makeImage() else { return self }
        return UIImage(cgImage: newCGImage)
    }
}

struct InputMethodCard: View {
    let icon: String
    let title: String
    let isUsed: Bool
    let isDisabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .padding(.vertical, 16)
            .padding(.horizontal, 8)
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isUsed ? Color.blue.opacity(0.1) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isUsed ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(isDisabled)
        .opacity(isDisabled ? 0.5 : 1)
    }
}


// ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
   let question: Question
   @Binding var selectedAnswer: String?
   let showExplanation: Bool
   let isCorrect: Bool?
   
   @State private var isExplanationVisible = false
   
   var body: some View {
       VStack(alignment: .leading, spacing: 16) {
           // Question Text
           Text(question.question)
               .font(.system(size: 22, weight: .semibold))
               .lineSpacing(4)
               .frame(maxWidth: .infinity, alignment: .leading)
               .padding(.bottom, 8)
           
           VStack(alignment: .leading, spacing: 12) {
               TrueFalseButton(
                   title: "True",
                   isSelected: selectedAnswer?.lowercased() == "true",
                   disabled: showExplanation
               ) {
                   selectedAnswer = "true"
               }
               
               TrueFalseButton(
                   title: "False",
                   isSelected: selectedAnswer?.lowercased() == "false",
                   disabled: showExplanation
               ) {
                   selectedAnswer = "false"
               }
           }
           
           // Answer Result
           if showExplanation {
               HStack {
                   if let isCorrect = isCorrect {
                       HStack {
                           Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                               .foregroundColor(isCorrect ? .green : .red)
                           
                           Text(isCorrect ? "Correct!" : "Incorrect")
                               .foregroundColor(isCorrect ? .green : .red)
                               .fontWeight(.semibold)
                       }
                       .padding(.vertical, 4)
                       
                       Spacer()
                   }
               }
               
               // Show correct answer if wrong
               if let isCorrect = isCorrect, !isCorrect {
                   Text("Answer: \(question.correctAnswer)")
                       .font(.subheadline)
                       .foregroundColor(.blue)
                       .padding(.vertical, 4)
               }
           }
           
           // Explanation Section
           if showExplanation && isExplanationVisible {
               VStack(alignment: .leading, spacing: 8) {
                   Text("Explanation")
                       .font(.headline)
                   Text(question.explanation)
                       .font(.body)
                       .foregroundColor(.secondary)
               }
               .padding()
               .frame(maxWidth: .infinity, alignment: .leading)
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .transition(.move(edge: .top).combined(with: .opacity))
           }
       }
       .padding()
       .animation(.spring(), value: showExplanation)
       .animation(.spring(), value: isExplanationVisible)
       .onChange(of: question.id) { _ in
           isExplanationVisible = false
       }
   }
}

struct TrueFalseButton: View {
   let title: String
   let isSelected: Bool
   let disabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           HStack {
               Text(title)
                   .font(.body)
               Spacer()
           }
           .padding()
           .frame(maxWidth: .infinity, alignment: .leading)
           .background(
               RoundedRectangle(cornerRadius: 10)
                   .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
           )
           .overlay(
               RoundedRectangle(cornerRadius: 10)
                   .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
           )
       }
       .disabled(disabled)
   }
}


// ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            // ì§ˆë¬¸ í…ìŠ¤íŠ¸
            Text(question.question)
                .font(.title3)
                .fontWeight(.bold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 16)
            
            // ì„ íƒì§€
            VStack(spacing: 16) {
                ForEach(question.options, id: \.self) { option in
                    Button(action: { selectedAnswer = option }) {
                        HStack {
                            Text(option)
                                .font(.body)
                                .fontWeight(.medium)
                                .multilineTextAlignment(.leading)
                                .foregroundColor(getTextColor(for: option))
                            Spacer()
                            if selectedAnswer == option && showExplanation {
                                Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                    .foregroundColor(isCorrect == true ? .green : .red)
                                    .imageScale(.large)
                                    .transition(.scale.combined(with: .opacity))
                            }
                        }
                        .padding(.vertical, 16)
                        .padding(.horizontal, 20)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(getBackgroundColor(for: option))
                                .shadow(color: Color.black.opacity(0.05),
                                       radius: 4, x: 0, y: 2)
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    .disabled(showExplanation)
                }
            }
        }
        .padding()
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.15)
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.15)
            }
        }
        // ê¸°ë³¸ ë°°ê²½ìƒ‰ì„ ì¡°ê¸ˆ ë” ëª…í™•í•˜ê²Œ êµ¬ë¶„
        return Color(UIColor.systemGray6)
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue
            } else {
                return isCorrect == true ? .green : .red
            }
        }
        return .primary
    }
}


// ./AISnapStudy/Views/Question/Sections/EducationLevelSection.swift


import SwiftUI

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionTypesSection.swift


import SwiftUI

// Question Type Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Type") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "True/False",
                    count: $viewModel.trueFalseCount
                )
                
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionAboutSection.swift

import SwiftUI

import SwiftUI

struct QuestionAboutSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @Binding var isTextInputSelected: Bool

    var body: some View {
        VStack(spacing: 16) { // DisclosureGroup ì œê±°
            // ê¸°ì¡´ ì´ë¯¸ì§€ ì˜µì…˜ ì¹´ë“œ
            HStack(spacing: 12) {
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.takePhoto() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.selectFromGallery() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        isTextInputSelected.toggle()
                        viewModel.toggleTextInput()
                    }
                )
            }
            .padding(.horizontal)

            // ğŸŸ¢ useTextExtraction í† ê¸€ ì¶”ê°€
            Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                .padding(.horizontal)
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("ğŸ“± useTextExtraction changed to: \(newValue)")
                }

            // í…ìŠ¤íŠ¸ ì…ë ¥ í•„ë“œ
            if viewModel.isTextInputActive {
                TextField("Enter your question here...", text: $viewModel.questionText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .frame(height: 50) // ì›í•˜ëŠ” ë†’ì´ë¥¼ ì§€ì •
                    .padding(.horizontal)
            }

            // ì„ íƒí•œ ì´ë¯¸ì§€ í‘œì‹œ
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                            SelectedImageCell(
                                image: viewModel.selectedImages[index],
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .listRowSpacing(0)
    }
}


// ./AISnapStudy/Views/Question/Sections/LearningSubjectSection.swift

import SwiftUI

struct LearningSubjectSection: View {
    @StateObject private var subjectManager = SubjectManager.shared
    @Binding var selectedSubject: SubjectType
    
    var visibleSubjects: [SubjectType] {
        // ê¸°ë³¸ ê³¼ëª© ì¤‘ ì‚­ì œë˜ì§€ ì•Šì€ ê²ƒë“¤ë§Œ í•„í„°ë§
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        // í™œì„±í™”ëœ ì»¤ìŠ¤í…€ ê³¼ëª©ë§Œ í•„í„°ë§
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        ğŸ“š LearningSubjectSection - Visible Subjects:
        â€¢ Total Subjects: \(subjects.count)
        â€¢ Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        â€¢ Active Custom Subjects: \(customSubjects.map { $0.displayName })
        â€¢ Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
    
    var body: some View {
        LazyVGrid(columns: [
            GridItem(.flexible()),
            GridItem(.flexible()),
            GridItem(.flexible())
        ], spacing: 12) {
            ForEach(visibleSubjects, id: \.id) { subject in
                SubjectSelectionButton(
                    subject: subject,
                    isSelected: selectedSubject.id == subject.id
                ) {
                    withAnimation(.spring()) {
                        selectedSubject = subject
                        print("ğŸ“ Selected subject: \(subject.displayName)")
                    }
                }
            }
        }
        .padding(.vertical, 8)
        .onAppear {
            // í˜„ì¬ ì„ íƒëœ ê³¼ëª©ì´ ì‚­ì œë˜ì—ˆê±°ë‚˜ ë¹„í™œì„±í™”ëœ ê²½ìš° ê¸°ë³¸ ê³¼ëª©ìœ¼ë¡œ ë³€ê²½
            if let defaultSubject = selectedSubject as? DefaultSubject,
               subjectManager.isDeleted(defaultSubject) {
                // ì²« ë²ˆì§¸ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ê³¼ëª©ì„ ì„ íƒ
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            } else if let customSubject = selectedSubject as? CustomSubject,
                      !subjectManager.customSubjects.contains(where: { $0.id == customSubject.id && $0.isActive }) {
                // ì²« ë²ˆì§¸ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ê³¼ëª©ì„ ì„ íƒ
                if let firstAvailableSubject = visibleSubjects.first {
                    selectedSubject = firstAvailableSubject
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Components/AddSubjectView.swift



import SwiftUI


// Helper Views
struct IconSelectionButton: View {
    let icon: String
    let isSelected: Bool
    let color: Color
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .frame(width: 50, height: 50)
                .foregroundColor(isSelected ? .white : color)
                .background(
                    Circle()
                        .fill(isSelected ? color : Color.gray.opacity(0.1))
                )
                .overlay(
                    Circle()
                        .stroke(isSelected ? color : Color.clear, lineWidth: 2)
                )
        }
    }
}

struct ColorSelectionButton: View {
    let color: Color
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Circle()
                .fill(color)
                .frame(width: 50, height: 50)
                .overlay(
                    Circle()
                        .stroke(Color.white, lineWidth: isSelected ? 3 : 0)
                )
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
        }
    }
}



// ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    // Add selection state
    @Binding var isSelected: Bool
    let selectionEnabled: Bool // ìƒˆë¡œìš´ í”„ë¡œí¼í‹° ì¶”ê°€
    
    // ê¸°ë³¸ê°’ì„ ê°€ì§„ ìƒì„±ì ì¶”ê°€
    init(problemSet: ProblemSet, isSelected: Binding<Bool> = .constant(false), selectionEnabled: Bool = false) {
        self.problemSet = problemSet
        self._isSelected = isSelected
        self.selectionEnabled = selectionEnabled
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                if selectionEnabled {  // isSelectable ëŒ€ì‹  selectionEnabled ì‚¬ìš©
                    Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(.blue)
                        .onTapGesture {
                            isSelected.toggle()
                        }
                }
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // íƒœê·¸ ëª©ë¡ (ì‘ê³  ê°„ê²°í•˜ê²Œ)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // ìµœëŒ€ 3ê°œì˜ íƒœê·¸ë§Œ í‘œì‹œ
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // ì •ë³´ ê·¸ë¦¬ë“œ
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
            }
            .font(.footnote)
            
            // ì„¤ëª… (ë” ì§§ê²Œ)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



// ./AISnapStudy/Views/Components/SpeedUpSection.swift


import SwiftUI

struct SpeedUpSection: View {
    @Binding var useTextExtraction: Bool 
    @State private var isExpanded: Bool = false
    @State private var showHelp = false
    
    var body: some View {
        VStack {
            DisclosureGroup(
                isExpanded: $isExpanded,
                content: {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Automatically extracts text from images to generate questions faster. Recommended when images contain mostly text.")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        // ì´ë¯¸ì§€ ì œí•œ ì„¤ëª… ì¶”ê°€
                        HStack(alignment: .top, spacing: 8) {
                            Image(systemName: "info.circle.fill")
                                .foregroundColor(.blue)
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Image Selection Limits:")
                                    .font(.caption)
                                    .fontWeight(.semibold)
                                
                                Text("â€¢ When enabled: Up to 3 images")
                                Text("â€¢ When disabled: Single image only")
                            }
                            .font(.caption)
                            .foregroundColor(.secondary)
                        }
                        .padding(.top, 4)
                    }
                    .padding(.vertical, 8)
                },
                label: {
                    HStack {
                        Image(systemName: "bolt.fill")
                            .foregroundColor(.yellow)
                        Text("Speed Up")
                            .font(.headline)
                        Spacer()
                        Toggle("", isOn: $useTextExtraction)
                            .labelsHidden()
                        
                        Button(action: { showHelp = true }) {
                            Image(systemName: "questionmark.circle")
                                .foregroundColor(.blue)
                        }
                    }
                }
            )
        }
        .alert("Speed Up Mode", isPresented: $showHelp) {
            Button("OK", role: .cancel) { }
        } message: {
            Text("Speed Up mode allows batch processing of multiple images (up to 3) with text extraction. When disabled, you can process one image at a time for more detailed analysis.")
        }
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionsView.swift

import SwiftUI

struct SavedQuestionsView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int
    @State private var selectedQuestions: Set<String> = []
    @State private var showCreateSetDialog = false
    @State private var setName = "Saved Questions Set"
    @State private var selectedSubject: DefaultSubject = .generalKnowledge

    var body: some View {
        VStack {
            if homeViewModel.savedQuestions.isEmpty {
                EmptyStateView()
            } else {
                SavedQuestionsList(
                    questions: homeViewModel.savedQuestions,
                    selectedQuestions: $selectedQuestions,
                    homeViewModel: homeViewModel
                )
            }
            
            if !selectedQuestions.isEmpty {
                CreateSetButton(
                    count: selectedQuestions.count,
                    action: { showCreateSetDialog = true }
                )
            }
        }
        .navigationTitle("Saved Questions")
        .sheet(isPresented: $showCreateSetDialog) {  // alert ëŒ€ì‹  sheet ì‚¬ìš©
            CreateSetView(
                setName: $setName,
                selectedSubject: $selectedSubject,
                onCreate: {
                    createNewSet()
                    showCreateSetDialog = false
                }
            )
        }
    }

    private func createNewSet() {
        // ì„ íƒëœ ì§ˆë¬¸ë“¤ì˜ ID ë¦¬ìŠ¤íŠ¸
        let selectedQuestionIds = selectedQuestions

        let selectedQuestionsList = homeViewModel.savedQuestions
            .filter { selectedQuestions.contains($0.id) }
            .map { question in
                Question(
                    id: UUID().uuidString,
                    type: question.type,
                    subject: selectedSubject,
                    question: question.question,
                    options: question.options,
                    correctAnswer: question.correctAnswer,
                    explanation: question.explanation,
                    hint: question.hint,
                    isSaved: false,  // ìƒˆ ì§ˆë¬¸ì€ ë¶ë§ˆí¬ í•´ì œëœ ìƒíƒœë¡œ ìƒì„±
                    createdAt: Date()
                )
            }
        
        let newProblemSet = ProblemSet(
            subject: selectedSubject,
            subjectType: "default",
            subjectId: selectedSubject.rawValue,
            subjectName: selectedSubject.displayName,
            questions: selectedQuestionsList,
            educationLevel: .elementary,
            name: setName
        )

        Task {
            // ë¨¼ì € ìƒˆ ë¬¸ì œ ì„¸íŠ¸ ì €ì¥
            await homeViewModel.saveProblemSet(newProblemSet)
            await homeViewModel.setSelectedProblemSet(newProblemSet)
            
            // ì„ íƒëœ ì›ë³¸ ì§ˆë¬¸ë“¤ì˜ ë¶ë§ˆí¬ í•´ì œ
            for questionId in selectedQuestionIds {
                if let originalQuestion = homeViewModel.savedQuestions.first(where: { $0.id == questionId }) {
                    await homeViewModel.toggleQuestionBookmark(originalQuestion)
                }
            }
            
            selectedTab = 1
            showCreateSetDialog = false
            selectedQuestions.removeAll()
        }
    }
}

// ìƒˆë¡œìš´ CreateSetView êµ¬í˜„
struct CreateSetView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var setName: String
    @Binding var selectedSubject: DefaultSubject
    let onCreate: () -> Void
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Set Name")) {
                    TextField("Enter set name", text: $setName)
                }
                
                Section(header: Text("Subject")) {
                    Picker("Select Subject", selection: $selectedSubject) {
                        ForEach(DefaultSubject.allCases, id: \.self) { subject in
                            Text(subject.displayName)
                                .tag(subject)
                        }
                    }
                }
            }
            .navigationTitle("Create New Set")
            .navigationBarItems(
                leading: Button("Cancel") {
                    dismiss()
                },
                trailing: Button("Create") {
                    onCreate()
                }
            )
        }
    }
}

private struct CreateSetAlert: View {
    @Binding var setName: String
    @Binding var selectedSubject: DefaultSubject
    let onCreate: () -> Void

    var body: some View {
        Group {
            TextField("Set Name", text: $setName)
            
            Picker("Subject", selection: $selectedSubject) {
                ForEach(DefaultSubject.allCases, id: \.self) { subject in
                    Text(subject.displayName)
                        .tag(subject)
                }
            }
            
            Button("Cancel", role: .cancel) { }
            Button("Create") {
                onCreate()
            }
        }
    }
}

// MARK: - Supporting Views
private struct EmptyStateView: View {
    var body: some View {
        Text("No saved questions")
            .foregroundColor(.secondary)
    }
}

private struct SavedQuestionsList: View {
    let questions: [Question]
    @Binding var selectedQuestions: Set<String>
    @ObservedObject var homeViewModel: HomeViewModel

    var body: some View {
        List {
            ForEach(Array(questions.enumerated()), id: \.offset) { index, question in
                SavedQuestionCard(
                    question: question,
                    isSelected: selectedQuestions.contains(question.id)
                )
                .contentShape(Rectangle())
                .onTapGesture {
                    toggleSelection(for: question)
                }
                .swipeActions(edge: .trailing, allowsFullSwipe: true) {
                    UnsaveButton(question: question, homeViewModel: homeViewModel)
                }
                .swipeActions(edge: .leading, allowsFullSwipe: true) {
                    UnsaveButton(question: question, homeViewModel: homeViewModel, tint: .blue)
                }
            }
        }
        .listStyle(PlainListStyle())
    }

    private func toggleSelection(for question: Question) {
        if selectedQuestions.contains(question.id) {
            selectedQuestions.remove(question.id)
        } else {
            selectedQuestions.insert(question.id)
        }
    }
}

private struct UnsaveButton: View {
    let question: Question
    let homeViewModel: HomeViewModel
    var tint: Color? = nil

    var body: some View {
        Button {
            Task {
                await homeViewModel.toggleQuestionBookmark(question)
                HapticManager.shared.impact(style: .medium)
            }
        } label: {
            Label("Unsave", systemImage: "bookmark.slash.fill")
        }
        .tint(tint)
    }
}

private struct CreateSetButton: View {
    let count: Int
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Text("Create New Set (\(count))")
                .font(.headline)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue)
                .cornerRadius(10)
        }
        .padding()
    }
}


// ./AISnapStudy/Views/Components/DraggableSubjectGrid.swift

import SwiftUI

struct DraggableSubjectGrid: View {
    @ObservedObject var subjectManager = SubjectManager.shared
    @State private var subjects: [SubjectType]
    @State private var draggingItem: SubjectType?
    @GestureState private var dragLocation: CGPoint = .zero
    
    // Grid layout settings
    let columns = [
        GridItem(.adaptive(minimum: 120), spacing: 12)
    ]
    
    init(subjects: [SubjectType]) {
        _subjects = State(initialValue: subjects)
    }
    
    var body: some View {
        LazyVGrid(columns: columns, spacing: 12) {
            ForEach(subjects, id: \.id) { subject in
                SubjectButton(subject: subject)
                    .overlay(draggingItem?.id == subject.id ? Color.blue.opacity(0.3) : Color.clear)
                    .onLongPressGesture(minimumDuration: 0.5) {
                        withAnimation(.spring()) {
                            self.draggingItem = subject
                        }
                    }
                    .gesture(
                        DragGesture()
                            .onChanged { value in
                                guard let draggingItem = draggingItem else { return }
                                let currentIndex = subjects.firstIndex { $0.id == draggingItem.id }
                                let targetIndex = computeTargetIndex(location: value.location)
                                
                                if let currentIndex = currentIndex,
                                   let targetIndex = targetIndex,
                                   currentIndex != targetIndex {
                                    withAnimation(.spring()) {
                                        subjects.move(fromOffsets: IndexSet(integer: currentIndex),
                                                    toOffset: targetIndex)
                                    }
                                }
                            }
                            .onEnded { _ in
                                self.draggingItem = nil
                                // Save new order to UserDefaults
                                saveSubjectOrder()
                            }
                    )
            }
        }
        .padding()
    }
    
    private func computeTargetIndex(location: CGPoint) -> Int? {
        // Convert point to index logic
        // ...
        return nil
    }
    
    private func saveSubjectOrder() {
        let subjectIds = subjects.map { $0.id }
        UserDefaults.standard.set(subjectIds, forKey: "subjectOrder")
    }
}

struct SubjectButton: View {
    let subject: SubjectType
    @State private var isPressed = false
    
    var body: some View {
        Button(action: {}) {
            VStack(spacing: 8) {
                Image(systemName: subject.icon)
                    .font(.system(size: 24))
                Text(subject.displayName)
                    .font(.subheadline)
                    .lineLimit(1)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(subject.color.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(subject.color.opacity(0.2), lineWidth: 1)
                    )
            )
        }
        .scaleEffect(isPressed ? 1.05 : 1.0)
        .animation(.spring(), value: isPressed)
        .buttonStyle(PlainButtonStyle())
    }
}


// ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/LanguageButton.swift

import SwiftUI

// Add new supporting view for Language Button
struct LanguageButton: View {
    let language: Language
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 6) {
                Text(emoji(for: language))
                    .font(.title2)
                Text(displayName(for: language))
                    .font(.caption)
                    .foregroundColor(isSelected ? .white : .primary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.blue : Color.gray.opacity(0.1))
            )
        }
    }
    
    private func emoji(for language: Language) -> String {
        switch language {
        case .auto: return "ğŸŒ"
        case .english: return "ğŸ‡ºğŸ‡¸"
        case .korean: return "ğŸ‡°ğŸ‡·"
        case .japanese: return "ğŸ‡¯ğŸ‡µ"
        case .chinese: return "ğŸ‡¨ğŸ‡³"
        case .spanish: return "ğŸ‡ªğŸ‡¸"
        case .french: return "ğŸ‡«ğŸ‡·"
        case .german: return "ğŸ‡©ğŸ‡ª"
        case .russian: return "ğŸ‡·ğŸ‡º"
        case .italian: return "ğŸ‡®ğŸ‡¹"
        }
    }
    
    private func displayName(for language: Language) -> String {
        switch language {
        case .auto: return "Auto"
        default: return language.rawValue
        }
    }
}



struct LanguageSection: View {
    @Binding var selectedLanguage: Language
    @State private var isExpanded: Bool = false
    @State private var showLanguageMenu = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Choose the language in which you want the questions to be generated. The generated questions will appear in your selected language regardless of the input language.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                        
                    Text("Current: \(selectedLanguage.displayName) \(selectedLanguage.emoji)")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            },
            label: {
                HStack {
                    HStack {
                        Image(systemName: "globe")
                            .foregroundColor(.blue)
                        Text("Language")
                            .font(.headline)
                    }
                    
                    Spacer()
                    
                    // ë³„ë„ì˜ ë²„íŠ¼ìœ¼ë¡œ ë¶„ë¦¬
                    Button(action: {
                        showLanguageMenu = true
                    }) {
                        HStack(spacing: 4) {
                            Text(selectedLanguage.emoji)
                            Image(systemName: "chevron.down")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
            }
        )
        .sheet(isPresented: $showLanguageMenu) {
            LanguageSelectionView(selectedLanguage: $selectedLanguage)
        }
    }
}

// LanguageSelectionViewëŠ” ë” ê¹”ë”í•œ UIë¡œ ì—…ë°ì´íŠ¸
struct LanguageSelectionView: View {
    @Binding var selectedLanguage: Language
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            List {
                ForEach(Language.allCases) { language in
                    LanguageRow(
                        language: language,
                        isSelected: language == selectedLanguage,
                        onSelect: {
                            selectedLanguage = language
                            UserDefaults.standard.set(language.rawValue, forKey: "selectedLanguage")
                            dismiss()
                        }
                    )
                }
            }
            .navigationTitle("Select Language")
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
        }
        .presentationDetents([.medium, .large])
    }
}

// ë³„ë„ì˜ LanguageRow ì»´í¬ë„ŒíŠ¸
struct LanguageRow: View {
    let language: Language
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack(spacing: 12) {
                Text(language.emoji)
                    .font(.title3)
                
                VStack(alignment: .leading) {
                    Text(language.displayName)
                        .foregroundColor(.primary)
                    Text(language.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}


// Language.swift (ìƒˆë¡œìš´ íŒŒì¼)
enum Language: String, CaseIterable, Identifiable {
    case auto = "AUTO"
    case english = "english"
    case korean = "korean"
    case japanese = "japanese"
    case chinese = "chinese"
    case spanish = "spanish"
    case french = "french"
    case german = "german"
    case russian = "russian"
    case italian = "italian"
    
    var id: String { self.rawValue }
    
    // OpenAI APIì—ì„œ ì‚¬ìš©í•  ì–¸ì–´ ì½”ë“œ
    var languageCode: String {
        switch self {
        case .auto: return "auto"
        case .english: return "en"
        case .korean: return "ko"
        case .japanese: return "ja"
        case .chinese: return "zh"
        case .spanish: return "es"
        case .french: return "fr"
        case .german: return "de"
        case .russian: return "ru"
        case .italian: return "it"
        }
    }
}

// Update Language enum to include display names and emojis
extension Language {
    var displayName: String {
        switch self {
        case .auto: return "Automatic"
        case .english: return "English"
        case .korean: return "í•œêµ­ì–´"
        case .japanese: return "æ—¥æœ¬èª"
        case .chinese: return "ä¸­æ–‡"
        case .spanish: return "EspaÃ±ol"
        case .french: return "FranÃ§ais"
        case .german: return "Deutsch"
        case .russian: return "Ğ ÑƒÑÑĞºĞ¸Ğ¹"
        case .italian: return "Italiano"
        }
    }
    
    var emoji: String {
        switch self {
        case .auto: return "ğŸŒ"
        case .english: return "ğŸ‡ºğŸ‡¸"
        case .korean: return "ğŸ‡°ğŸ‡·"
        case .japanese: return "ğŸ‡¯ğŸ‡µ"
        case .chinese: return "ğŸ‡¨ğŸ‡³"
        case .spanish: return "ğŸ‡ªğŸ‡¸"
        case .french: return "ğŸ‡«ğŸ‡·"
        case .german: return "ğŸ‡©ğŸ‡ª"
        case .russian: return "ğŸ‡·ğŸ‡º"
        case .italian: return "ğŸ‡®ğŸ‡¹"
        }
    }
    var codeName: String {
        switch self {
        case .auto: return "automatic"
        case .english: return "english"
        case .korean: return "korean"
        case .japanese: return "japanese"
        case .chinese: return "chinese"
        case .spanish: return "spanish"
        case .french: return "french"
        case .german: return "german"
        case .russian: return "russian"
        case .italian: return "italian"
        }
    }
}

extension Language {
    var description: String {
        switch self {
        case .auto:
            return "Detect language automatically"
        case .english:
            return "English"
        case .korean:
            return "í•œêµ­ì–´ (Korean)"
        case .japanese:
            return "æ—¥æœ¬èª (Japanese)"
        case .chinese:
            return "ä¸­æ–‡ (Chinese)"
        case .spanish:
            return "EspaÃ±ol (Spanish)"
        case .french:
            return "FranÃ§ais (French)"
        case .german:
            return "Deutsch (German)"
        case .russian:
            return "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (Russian)"
        case .italian:
            return "Italiano (Italian)"
        }
    }
}


// ./AISnapStudy/Views/Components/SubjectManagementView.swift

import SwiftUI

struct SubjectManagementView: View {
   @StateObject private var subjectManager = SubjectManager.shared
   @State private var showingAddSubject = false
   @State private var showingDeleteAlert = false
   @State private var showingEditAlert = false
   @State private var showingRestoreAlert = false
   @State private var subjectToDelete: (any SubjectType)?
   @State private var newName = ""
   @State private var selectedSubject: (any SubjectType)?
   
   // ëª¨ë“  í™œì„± ê³¼ëª©ì„ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ ê²°í•©
   private var allSubjects: [SubjectType] {
       var subjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) } as [SubjectType]
       subjects.append(contentsOf: subjectManager.customSubjects)
       return subjects
   }
   
   var body: some View {
       List {
           // Combined Subjects Section
           Section(header: Text("SUBJECTS")) {
               ForEach(allSubjects, id: \.id) { subject in
                   if let defaultSubject = subject as? DefaultSubject {
                       DefaultSubjectRow(
                        subject: defaultSubject,
                        subjectManager: subjectManager,
                        onEdit: { subject in
                            selectedSubject = subject
                            newName = subjectManager.getDisplayName(for: subject)
                            showingEditAlert = true
                        },
                        onDelete: {
                            subjectToDelete = subject
                            showingDeleteAlert = true
                        }
                       )
                   } else if let customSubject = subject as? CustomSubject {
                       CustomSubjectRow(
                           subject: customSubject,
                           subjectManager: subjectManager,
                           onEdit: { subject in
                               selectedSubject = subject
                               newName = subject.name
                               showingEditAlert = true
                           },
                           onDelete: { subject in
                               subjectToDelete = subject
                               showingDeleteAlert = true
                           }
                       )
                   }
               }
               
               Button {
                   showingAddSubject = true
               } label: {
                   Label("Add Subject", systemImage: "plus")
               }
           }
           
           // Recently Deleted Section moved to bottom
           if !subjectManager.hiddenDefaultSubjects.isEmpty {
               Section(header: Text("RECENTLY DELETED")) {
                   Button(action: {
                       showingRestoreAlert = true
                   }) {
                       Label("Restore All Deleted Subjects", systemImage: "arrow.counterclockwise")
                           .foregroundColor(.blue)
                   }
               }
           }
       }
       .navigationTitle("Manage Subjects")
       .sheet(isPresented: $showingAddSubject) {
           AddSubjectView()
       }
       .alert("Rename Subject", isPresented: $showingEditAlert) {
           TextField("Subject Name", text: $newName)
           Button("Cancel", role: .cancel) { }
           Button("Save") {
               if let defaultSubject = selectedSubject as? DefaultSubject {
                   subjectManager.updateDefaultSubjectName(defaultSubject, newName: newName)
               } else if let customSubject = selectedSubject as? CustomSubject {  // ë³€ê²½
                              subjectManager.updateSubject(customSubject, newName: newName)
               }
           }
           .disabled(newName.isEmpty)
       }
       .alert("Delete Subject", isPresented: $showingDeleteAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Delete", role: .destructive) {
               if let subject = subjectToDelete as? DefaultSubject {
                   subjectManager.toggleDefaultSubject(subject)
               } else if let subject = subjectToDelete as? CustomSubject {  // ë³€ê²½
                   subjectManager.deleteSubject(subject)
               }
           }
       } message: {
           Text("Are you sure you want to delete this subject? You can restore it later from the Recently Deleted section.")
       }
       .alert("Restore Subjects", isPresented: $showingRestoreAlert) {
           Button("Cancel", role: .cancel) { }
           Button("Restore All") {
               DefaultSubject.allCases.forEach { subject in
                   if subjectManager.isDeleted(subject) {
                       subjectManager.restoreDeletedSubject(subject)
                   }
               }
           }
       } message: {
           Text("Do you want to restore all deleted subjects?")
       }
       .onAppear {
           print("ğŸ“± SubjectManagementView appeared")
           print("ğŸ“š Active subjects: \(allSubjects.map { $0.displayName })")
           print("ğŸ—‘ï¸ Hidden subjects: \(subjectManager.hiddenDefaultSubjects)")
       }
   }
}


    // ê¸°ë³¸ ê³¼ëª© ì„¹ì…˜ì„ ìœ„í•œ ë³„ë„ì˜ ë·°
struct DefaultSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: (DefaultSubject) -> Void
    
    var body: some View {
        Section(header: Text("Default Subjects")) {
            ForEach(DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }, id: \.id) { subject in
                DefaultSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { _ in onEdit(subject) },  // ìˆ˜ì •ëœ ë¶€ë¶„
                    onDelete: { onDelete(subject) }     // ìˆ˜ì •ëœ ë¶€ë¶„
                )
            }
        }
    }
}

// ì»¤ìŠ¤í…€ ê³¼ëª© ì„¹ì…˜ì„ ìœ„í•œ ë³„ë„ì˜ ë·°
struct CustomSubjectsSection: View {
    @ObservedObject var subjectManager: SubjectManager
    @Binding var showingAddSubject: Bool
    let onEdit: (CustomSubject) -> Void  // ë³€ê²½
    let onDelete: (CustomSubject) -> Void  // ë³€ê²½
    
    var body: some View {
        Section(header: Text("Custom Subjects")) {
            ForEach(subjectManager.customSubjects) { subject in
                CustomSubjectRow(
                    subject: subject,
                    subjectManager: subjectManager,
                    onEdit: { customSubject in  // ë§¤ê°œë³€ìˆ˜ ì´ë¦„ ë³€ê²½
                        onEdit(customSubject)
                    },
                    onDelete: { customSubject in  // ë§¤ê°œë³€ìˆ˜ ì´ë¦„ ë³€ê²½
                        onDelete(customSubject)
                    }
                )
            }
            
            Button {
                showingAddSubject = true
            } label: {
                Label("Add Subject", systemImage: "plus")
            }
        }
    }
}

struct DefaultSubjectRow: View {
    let subject: DefaultSubject
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (DefaultSubject) -> Void
    let onDelete: () -> Void
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subjectManager.getDisplayName(for: subject))
            Spacer()
            
            Button(action: {
                onDelete()
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button(role: .destructive) {
                onDelete()
            } label: {
                Label("Delete", systemImage: "trash")
            }
            
            if subjectManager.modifiedDefaultSubjects[subject.id] != nil {
                Button {
                    subjectManager.resetDefaultSubjectName(subject)
                } label: {
                    Label("Reset Name", systemImage: "arrow.counterclockwise")
                }
            }
        }
    }
}

// ì‚¬ìš©ì ì •ì˜ ê³¼ëª© í–‰ì„ ìœ„í•œ ì»´í¬ë„ŒíŠ¸
struct CustomSubjectRow: View {
    let subject: CustomSubject  // ë³€ê²½
    @ObservedObject var subjectManager: SubjectManager
    let onEdit: (CustomSubject) -> Void  // ë³€ê²½
    let onDelete: (CustomSubject) -> Void  // ë³€ê²½
    
    var body: some View {
        HStack {
            Image(systemName: subject.icon)
                .foregroundColor(subject.color)
            Text(subject.displayName)
            Spacer()
            
            // ì‚­ì œ ë²„íŠ¼ ì¶”ê°€
            Button(action: {
                onDelete(subject)
            }) {
                Image(systemName: "trash")
                    .foregroundColor(.red)
            }
            
            if !subject.isActive {
                Image(systemName: "eye.slash")
                    .foregroundColor(.gray)
            }
        }
        .contentShape(Rectangle())
        .contextMenu {
            Button {
                onEdit(subject)
            } label: {
                Label("Rename", systemImage: "pencil")
            }
            
            Button {
                subjectManager.toggleSubjectActive(subject)
            } label: {
                if subject.isActive {
                    Label("Hide", systemImage: "eye.slash")
                } else {
                    Label("Show", systemImage: "eye")
                }
            }
            
            Button(role: .destructive) {
                onDelete(subject)
            } label: {
                Label("Delete", systemImage: "trash")
            }
        }
    }
}



struct AddSubjectView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var subjectName = ""
    @State private var selectedColor = Color.blue
    @State private var selectedIcon = "book.fill"
    
    let availableIcons = [
        "book.fill", "pencil", "function", "globe",
        "atom", "flask.fill", "keyboard", "music.note"
    ]
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Subject Details")) {
                    TextField("Subject Name", text: $subjectName)
                    
                    ColorPicker("Choose Color", selection: $selectedColor)
                    
                    Picker("Choose Icon", selection: $selectedIcon) {
                        ForEach(availableIcons, id: \.self) { icon in
                            Label(icon, systemImage: icon)
                                .tag(icon)
                        }
                    }
                    .pickerStyle(.menu)
                }
            }
            .navigationTitle("Add Subject")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        subjectManager.addSubject(
                            name: subjectName,
                            icon: selectedIcon
                        )
                        dismiss()
                    }
                    .disabled(subjectName.isEmpty)
                }
            }
        }
    }
}



// ./AISnapStudy/Views/Components/SubjectPickerView.swift


import SwiftUI

struct SubjectPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    let problemSet: ProblemSet
    let currentSubject: SubjectType
    
    private func updateProblemSetSubject(to newSubject: SubjectType) async {
        await homeViewModel.updateProblemSetSubject(problemSet, to: newSubject)
        dismiss()
    }
    
    var body: some View {
        NavigationView {
            List {
                ForEach(subjectManager.availableSubjects, id: \.id) { subject in
                    Button(action: {
                        Task {
                            await updateProblemSetSubject(to: subject)
                            dismiss()
                        }
                    }) {
                        HStack {
                            Image(systemName: subject.icon)
                                .foregroundColor(subject.color)
                            
                            Text(subject.displayName)
                                .foregroundColor(.primary)
                            
                            Spacer()
                            
                            if subject.id == currentSubject.id {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .navigationTitle("Change Subject")
            .navigationBarItems(trailing: Button("Cancel") {
                dismiss()
            })
        }
    }

}


// ./AISnapStudy/Views/Components/ReviewProblemSetCard.swift

import SwiftUI

struct ReviewProblemSetCard: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    
    let subject: SubjectType
    let problemSet: ProblemSet
    let isEditMode: Bool
    let onDelete: () -> Void
    let onRename: (String) -> Void
    let onFavoriteToggle: () -> Void
    
    @State private var isShowingRenameAlert = false
    @State private var isShowingSubjectPicker = false
    @State private var newName = ""
    @State private var isShowingMergeAlert = false
    @State private var isTargeted = false
    @State private var mergingProblemSets: (source: ProblemSet, target: ProblemSet)?
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Spacer()
                    
                    Button(action: {
                        Task {
                            await homeViewModel.toggleFavorite(problemSet)
                        }
                    }) {
                        Image(systemName: problemSet.isFavorite ? "star.fill" : "star")
                            .foregroundColor(.yellow)
                            .imageScale(.large)
                    }
                }
                HStack {
                    Text("\(problemSet.questions.count) EA")
                        .font(.headline)
                        .foregroundColor(.primary)
                    
                    Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            if isEditMode {
                HStack(spacing: 12) {
                    Button(action: {
                        isShowingSubjectPicker = true
                    }) {
                        Image(systemName: "arrow.triangle.swap")
                            .foregroundColor(.blue)
                            .imageScale(.large)
                    }
                    
                    Button(action: {
                        newName = problemSet.name
                        isShowingRenameAlert = true
                    }) {
                        Image(systemName: "pencil.circle.fill")
                            .foregroundColor(.blue)
                            .imageScale(.large)
                    }
                    
                    Button(action: onDelete) {
                        Image(systemName: "trash.circle.fill")
                            .foregroundColor(.red)
                            .imageScale(.large)
                    }
                }
                .transition(.move(edge: .trailing).combined(with: .opacity))
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 8)
                .fill(Color(UIColor.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1)
                .background(isTargeted ? Color.blue.opacity(0.1) : Color.clear)
        )
        .sheet(isPresented: $isShowingSubjectPicker) {
            SubjectPickerView(
                problemSet: problemSet,
                currentSubject: subject
            )
        }
        .alert("Rename Problem Set", isPresented: $isShowingRenameAlert) {
            TextField("New name", text: $newName)
            Button("Cancel", role: .cancel) {
                newName = ""
            }
            Button("Save") {
                let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
                guard !trimmedName.isEmpty else { return }
                
                Task {
                    await homeViewModel.renameProblemSet(problemSet, newName: trimmedName)
                    onRename(trimmedName)
                }
                newName = ""
            }
        } message: {
            Text("Enter a new name for this problem set")
        }
        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥
        .draggable(problemSet) {
            DragPreviewView(problemSet: problemSet)
        }
        .dropDestination(for: ProblemSet.self) { droppedItems, location in
            guard let droppedSet = droppedItems.first,
                  droppedSet.id != problemSet.id else { return false }
            
            mergingProblemSets = (droppedSet, problemSet)
            newName = "\(droppedSet.name) + \(problemSet.name)"
            isShowingMergeAlert = true
            HapticManager.shared.impact(style: .medium)
            return true
        } isTargeted: { inDropArea in
            withAnimation(.easeInOut(duration: 0.2)) {
                isTargeted = inDropArea
            }
        }
        .alert("Create Combined Set", isPresented: $isShowingMergeAlert) {
            TextField("New set name", text: $newName)
            Button("Cancel", role: .cancel) {
                mergingProblemSets = nil
                newName = ""
            }
            Button("Create") {
                if let (source, target) = mergingProblemSets {
                    let mergedSet = ProblemSet.merge([source, target], name: newName)
                    Task {
                        // ìƒˆë¡œìš´ ë³‘í•©ëœ ì„¸íŠ¸ë§Œ ì €ì¥í•˜ê³  ì›ë³¸ì€ ìœ ì§€
                        await homeViewModel.saveProblemSet(mergedSet)
                        mergingProblemSets = nil
                        HapticManager.shared.notification(type: .success)  // ì—¬ê¸°ë¥¼ ìˆ˜ì •
                    }
                }
                newName = ""
            }
        } message: {
            if let sets = mergingProblemSets {
                Text("Create a new set by combining '\(sets.source.name)' with '\(sets.target.name)'\nOriginal sets will be preserved.")
            }
        }
    }
}

struct DragPreviewView: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(spacing: 4) {
            Text(problemSet.name)
                .font(.headline)
            Text("\(problemSet.questions.count) questions")
                .font(.caption)
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(8)
        .shadow(radius: 3)
    }
}


// ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search Review...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


// ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


// ./AISnapStudy/Views/Components/InputMethodCard.swift


import SwiftUI




// ./AISnapStudy/Views/Components/ImageSelectionSection.swift



import SwiftUI
import PhotosUI
import UIKit

struct ImageSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @FocusState private var isTextFieldFocused: Bool
    @State private var keyboardHeight: CGFloat = 0
  
    var body: some View {
        VStack(spacing: 16) {
            // Quick Text Mode Toggle
            Group {
                VStack(alignment: .leading, spacing: 8) {
                    Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                        .padding()
                        .onAppear {
                            print("ğŸ”„ Toggle initialized with: \(viewModel.useTextExtraction)")
                        }

                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Quick Text Mode")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            if viewModel.useTextExtraction {
                                Image(systemName: "bolt.fill")
                                    .foregroundColor(.yellow)
                                    .imageScale(.small)
                            }
                        }
                        Text("Extracts text for faster processing")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .toggleStyle(SwitchToggleStyle(tint: .blue))
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("ğŸ“± Quick Text Mode changed to: \(newValue)")
                }
            }
            .padding(.horizontal)

            Divider()

            // Input Type Selection Buttons
            HStack(spacing: 12) {
                // Camera Button
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.takePhoto()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Gallery Button
                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.selectFromGallery()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Text Input Button
                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        if viewModel.canUseTextInput {
                            viewModel.onImageOptionSelected()
                            viewModel.toggleTextInput()
                            if viewModel.isTextInputActive {
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isTextFieldFocused = true
                                }
                            } else {
                                isTextFieldFocused = false
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal)

            // Text Input Field
            if viewModel.isTextInputActive {
                VStack(spacing: 12) {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .focused($isTextFieldFocused)
                }
                .padding(.horizontal)
            }

            // Selected Images Display
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(Array(zip(viewModel.selectedImages.indices, viewModel.selectedImages)), id: \.0) { index, image in
                            let imageId = viewModel.getImageId(for: image)
                            SelectedImageCell(
                                image: image,
                                isLoading: viewModel.isLoadingTexts[imageId] ?? false,
                                extractionStatus: viewModel.extractionStatus[imageId],
                                extractedText: viewModel.extractedTexts[imageId],
                                showExtractedText: viewModel.useTextExtraction,
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.horizontal)
                }
            }

            // Generate Button for Selected Content
            if !viewModel.selectedImages.isEmpty || !viewModel.questionText.isEmpty {
                Button {
                    Task {
                        await viewModel.sendAllImages()
                    }
                } label: {
                    HStack {
                        Spacer()
                        Image(systemName: "sparkles")
                        Text("Generate Questions")
                            .fontWeight(.semibold)
                        Spacer()
                    }
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(viewModel.isLoading ? Color.gray : Color.green)
                    )
                    .animation(.easeInOut, value: viewModel.isLoading)
                }
                .buttonStyle(BorderlessButtonStyle())
                .disabled(viewModel.isLoading)
                .padding(.horizontal)
            }
        }
    }
}



// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
   let icon: String
   let isUsed: Bool
   let isDisabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 12) {
               Image(systemName: icon)
                   .font(.system(size: 30))
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 20)
           .foregroundColor(foregroundColor)
           .background(
               RoundedRectangle(cornerRadius: 12)
                   .fill(backgroundColor)
           )
           .overlay(
               RoundedRectangle(cornerRadius: 12)
                   .stroke(strokeColor, lineWidth: 1)
           )
       }
       .disabled(isDisabled)
       .buttonStyle(PlainButtonStyle())
   }
   
   private var foregroundColor: Color {
       if isDisabled {
           return .gray.opacity(0.5)
       }
       return isUsed ? .green : .gray
   }
   
   private var backgroundColor: Color {
       if isDisabled {
           return Color.gray.opacity(0.1)
       }
       return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
   }
   
   private var strokeColor: Color {
       if isDisabled {
           return .clear
       }
       return isUsed ? Color.green.opacity(0.2) : .clear
   }
}

struct SelectedImageCell: View {
    let image: UIImage
    let isLoading: Bool
    let extractionStatus: Bool?
    let extractedText: String?
    let showExtractedText: Bool
    let onDelete: () -> Void
    
    init(
        image: UIImage,
        isLoading: Bool = false,
        extractionStatus: Bool? = nil,
        extractedText: String? = nil,
        showExtractedText: Bool = false,
        onDelete: @escaping () -> Void
    ) {
        self.image = image
        self.isLoading = isLoading
        self.extractionStatus = extractionStatus
        self.extractedText = extractedText
        self.showExtractedText = showExtractedText
        self.onDelete = onDelete
    }
    
    var body: some View {
        ZStack(alignment: .topTrailing) {
            VStack(alignment: .leading, spacing: 4) {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .frame(width: 100, height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                    )
                
                if showExtractedText {
                    if isLoading {
                        HStack(spacing: 4) {
                            ProgressView()
                                .scaleEffect(0.7)
                            Text("Extracting text...")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    } else if let status = extractionStatus {
                        HStack(spacing: 4) {
                            Image(systemName: status ? "doc.text.fill" : "exclamationmark.triangle.fill")
                                .foregroundColor(status ? .green : .orange)
                                .imageScale(.small)
                            Text(status ? "Text extracted" : "Extraction failed")
                                .font(.caption2)
                                .foregroundColor(status ? .green : .orange)
                        }
                    }
                }
            }
            
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 22))
                    .foregroundColor(.white)
                    .background(
                        Circle()
                            .fill(Color.black.opacity(0.5))
                            .frame(width: 24, height: 24)
                    )
            }
            .offset(x: 6, y: -6)
        }
    }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


// ./AISnapStudy/Views/Components/PremiumUpgradeView.swift

import SwiftUI

struct PremiumUpgradeView: View {
    @StateObject private var storeService = StoreService.shared
    @Environment(\.dismiss) private var dismiss
    @State private var showPlans = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // Premium features section
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Premium Features")
                            .font(.title2)
                            .fontWeight(.bold)
                        
                        FeatureRow(
                            icon: "sparkles",
                            title: "More Daily Questions",
                            description: "Create up to 30 question sets per day"
                        )
                        
                        FeatureRow(
                            icon: "square.and.arrow.down",
                            title: "Full Library Access",
                            description: "Download all question sets from our library"
                        )
                    }
                    .padding()
                    
                    // See Plans Button
                    Button {
                        showPlans = true
                    } label: {
                        Text("See Plans")
                            .font(.headline)
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(Color.blue)
                            .cornerRadius(10)
                    }
                    .padding()
                }
            }
            .navigationTitle("Premium Upgrade")
            .navigationBarItems(trailing: Button("Close") {
                dismiss()
            })
            .sheet(isPresented: $showPlans) {
                SubscriptionPlansView()
            }
        }
    }
}

struct SubscriptionPlansView: View {
   @Environment(\.dismiss) private var dismiss
   @StateObject private var storeService = StoreService.shared
   @State private var showTerms = false
   @State private var selectedPlan: PlanType = .annual
   @State private var isLoading = false
   @State private var showAlert = false
   @State private var alertMessage = ""
   
   enum PlanType: String {
       case annual = "com.aisnapstudy.subscription.annual"
       case monthly = "com.aisnapstudy.subscription.monthly"
       
       var productId: String {
           return self.rawValue
       }
   }
   
   var body: some View {
       NavigationView {
           ScrollView {
               VStack(spacing: 24) {
                   Text("Choose your plan")
                       .font(.title2)
                       .fontWeight(.bold)
                   
                   // Annual Plan
                   PlanCard(
                       type: .annual,
                       title: "Annual",
                       price: "$107.92",
                       period: "/ year",
                       description: "Recurring billing.",
                       isSelected: selectedPlan == .annual,
                       discount: "40% off",
                       isBestValue: true,
                       action: { selectedPlan = .annual }
                   )
                   
                   // Monthly Plan
                   PlanCard(
                       type: .monthly,
                       title: "Monthly",
                       price: "$14.99",
                       period: "/ month",
                       description: "Recurring billing. Cancel anytime.",
                       isSelected: selectedPlan == .monthly,
                       action: { selectedPlan = .monthly }
                   )
                   
                   // How subscriptions work
                   SubscriptionInfoSection()
                   
                   // Terms and conditions link
                   Button("Terms and conditions") {
                       showTerms = true
                   }
                   .font(.footnote)
                   .foregroundColor(.blue)
                   
                   // Subscribe button
                   Button(action: {
                       Task {
                           await handlePurchase()
                       }
                   }) {
                       if isLoading {
                           ProgressView()
                               .progressViewStyle(CircularProgressViewStyle(tint: .white))
                       } else {
                           Text("Subscribe")
                               .font(.headline)
                               .foregroundColor(.white)
                       }
                   }
                   .frame(maxWidth: .infinity)
                   .padding()
                   .background(Color.yellow)
                   .cornerRadius(10)
                   .disabled(isLoading)
                   .padding(.horizontal)
               }
               .padding()
           }
           .navigationBarItems(leading: Button("Cancel") { dismiss() })
           .sheet(isPresented: $showTerms) {
               TermsAndConditionsView()
           }
           .alert("êµ¬ë§¤ ì˜¤ë¥˜", isPresented: $showAlert) {
               Button("í™•ì¸", role: .cancel) { }
           } message: {
               Text(alertMessage)
           }
       }
       .task {
           // ìƒí’ˆ ì •ë³´ ë¡œë“œ
           await storeService.loadProducts()
       }
   }
   
   private func handlePurchase() async {
       isLoading = true
       defer { isLoading = false }
       
       do {
           if let product = storeService.products.first(where: { $0.id == selectedPlan.productId }) {
               try await storeService.purchase(product)
               await MainActor.run {
                   dismiss()
               }
           } else {
               throw PurchaseError.productNotFound
           }
       } catch {
           await MainActor.run {
               alertMessage = error.localizedDescription
               showAlert = true
           }
       }
   }
}

enum PurchaseError: LocalizedError {
   case productNotFound
   
   var errorDescription: String? {
       switch self {
       case .productNotFound:
           return "ì„ íƒí•œ êµ¬ë… ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
       }
   }
}

// StoreServiceì˜ PurchaseProduct enum ì—…ë°ì´íŠ¸
enum PurchaseProduct: String, CaseIterable {
   case monthlySubscription = "com.aisnapstudy.subscription.monthly"
   case annualSubscription = "com.aisnapstudy.subscription.annual"
   
   var id: String { rawValue }
   var displayName: String {
       switch self {
       case .monthlySubscription:
           return "Monthly Subscription"
       case .annualSubscription:
           return "Annual Subscription"
       }
   }
}

struct TermsAndConditionsView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    Text("Payment will be charged to the user's iTunes Account upon confirmation of purchase.")
                        .padding(.bottom)
                    
                    Text("Subscription will renew automatically unless auto-renew is turned off at least 24 hours before the end of the current period.")
                        .padding(.bottom)
                    
                    Text("Account will be charged for renewal within 24 hours prior to the end of the current period and will identify the cost of the renewal.")
                        .padding(.bottom)
                    
                    Text("Subscriptions may be managed by the user and auto-renewal may be turned off in the user's account settings after purchase.")
                        .padding(.bottom)
                    
                    Text("Any unused portion of a free trial period, if offered, will be forfeited when the user purchases a subscription, where applicable.")
                        .padding(.bottom)
                }
                .padding()
            }
            .navigationTitle("Terms and conditions")
            .navigationBarItems(trailing: Button("Done") { dismiss() })
        }
    }
}

struct PlanCard: View {
    let type: SubscriptionPlansView.PlanType
    let title: String
    let price: String
    let period: String
    let description: String
    let isSelected: Bool
    var discount: String? = nil
    var isBestValue: Bool = false
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    if isBestValue {
                        Text("Best Value")
                            .font(.caption)
                            .fontWeight(.bold)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(Color.yellow)
                            .cornerRadius(12)
                    }
                    Spacer()
                    if isSelected {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.green)
                    }
                }
                
                Text(title)
                    .font(.title2)
                    .fontWeight(.bold)
                
                HStack(alignment: .firstTextBaseline) {
                    Text(price)
                        .font(.title)
                        .fontWeight(.bold)
                    Text(period)
                        .foregroundColor(.secondary)
                }
                
                if let discount = discount {
                    Text(discount)
                        .font(.subheadline)
                        .foregroundColor(.green)
                }
                
                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            .padding()
            .frame(maxWidth: .infinity)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color(.systemBackground))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isSelected ? Color.blue : Color.gray.opacity(0.2), lineWidth: 2)
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct SubscriptionInfoSection: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            Text("How annual subscriptions work")
                .font(.headline)
            
            HStack(spacing: 16) {
                Image(systemName: "lock.fill")
                    .foregroundColor(.yellow)
                    .frame(width: 30)
                
                VStack(alignment: .leading) {
                    Text("Today: Get instant access")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                    Text("You are billed for one year")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            
            HStack(spacing: 16) {
                Image(systemName: "arrow.clockwise")
                    .frame(width: 30)
                
                VStack(alignment: .leading) {
                    Text("December 16, 2025: Renewal")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                    Text("Your subscription is renewed for another year unless you cancel before this date.")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(12)
    }
}

struct FeatureRow: View {
    let icon: String
    let title: String
    let description: String
    
    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(.blue)
                .frame(width: 30)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.headline)
                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
    }
}


// Viewì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” Premium ìƒíƒœ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
struct SubscriptionStatusView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @State private var showUpgradeView = false
    
    var body: some View {
        HStack {
            Text(viewModel.subscriptionStatusText)
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            if !viewModel.isPremium {
                Button(action: {
                    showUpgradeView = true
                }) {
                    Text("Upgrade")
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.blue)
                        .cornerRadius(8)
                }
            }
        }
        .sheet(isPresented: $showUpgradeView) {
            PremiumUpgradeView()
        }
    }
}



// ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


// ./AISnapStudy/Views/Components/ReviewCard.swift



import SwiftUI

struct ReviewCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    let isSelected: Bool

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(question.question)
                .font(.headline)
                .lineLimit(2)
            
            HStack {
                Text(question.type.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.blue)
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(isSelected ? Color.blue.opacity(0.1) : Color(.systemBackground))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(isSelected ? Color.blue : Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}


// ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


// ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // ê° ë²„íŠ¼ì— ëŒ€í•œ ë³„ë„ì˜ ì•¡ì…˜ ì •ì˜
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // ì¤‘ìš”: ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë¶„ë¦¬
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // ì¤‘ìš”: ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë¶„ë¦¬
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @StateObject private var studyViewModel: StudyViewModel
    @StateObject private var reviewViewModel: ReviewViewModel  // ì¶”ê°€
    @State private var selectedTab = 0
    @StateObject private var statViewModel: StatViewModel
    
    
    init() {
        let homeVM = HomeViewModel.shared
        
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        
        // StudyViewModel ì´ˆê¸°í™” ì‹œì  ë³€ê²½
        let studyVM = StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        )
        self._studyViewModel = StateObject(wrappedValue: studyVM)
        
        let statVM = StatViewModel(
            context: CoreDataService.shared.viewContext,
            homeViewModel: homeVM,
            studyViewModel: studyVM
        )
        // ReviewViewModel ì´ˆê¸°í™” ì¶”ê°€
        let reviewVM = ReviewViewModel(homeViewModel: homeVM)
        self._reviewViewModel = StateObject(wrappedValue: reviewVM)
        
        // StatViewModelë„ studyViewModel ì°¸ì¡° ì¶”ê°€
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
             context: CoreDataService.shared.viewContext,
             homeViewModel: homeVM,  // homeViewModel ì „ë‹¬
             studyViewModel: studyVM // studyViewModel ì „ë‹¬
         ))
        
        
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
        
        // homeViewModelì— studyViewModel ì„¤ì •
        homeVM.setStudyViewModel(studyVM)
        
        // StatViewModelì„ StudyViewModelì— ì—°ê²°
        studyVM.setStatViewModel(statVM)
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            Group {
                if studyViewModel.isGeneratingQuestions {  // ë¬¸ì œ ìƒì„± ì¤‘ì¼ ë•Œ
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                } else if let problemSet = homeViewModel.selectedProblemSet {
                    StudyView(
                        questions: problemSet.questions,
                        studyViewModel: studyViewModel,
                        selectedTab: $selectedTab
                    )
                } else {
                    Text("No Problem Set Selected")
                }
            }
            .tabItem {
                Label("Study", systemImage: "book.fill")
            }
            .tag(1)
            
            ReviewView(
                viewModel: reviewViewModel,
                selectedTab: $selectedTab  // selectedTab ë°”ì¸ë”© ì „ë‹¬
            )
            .tabItem {
                Label("Review", systemImage: "clock.fill")
            }
            .tag(2)
            
            StatView(
                viewModel: statViewModel,
                selectedTab: $selectedTab,
                correctAnswers: studyViewModel.correctAnswers,
                totalQuestions: studyViewModel.totalQuestions
            )
            .tabItem {
                Label("Result", systemImage: "checkmark.circle.fill")
            }
            .tag(3)
            
            // ìƒˆë¡œ ì¶”ê°€ëœ DailyStatsView íƒ­
            DailyStatsView(viewModel: statViewModel)
                .tabItem {
                    Label("Stats", systemImage: "chart.bar.fill")
                }
                .tag(4)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { newProblemSet in
            if let problemSet = newProblemSet,
               // Reviewì—ì„œ ì„ íƒëœ ê²½ìš°ì—ë§Œ íƒ­ ì „í™˜
               selectedTab == 2 {  // 2ëŠ” Review íƒ­
                studyViewModel.loadQuestions(problemSet.questions)
                selectedTab = 1  // Study íƒ­ìœ¼ë¡œ ì „í™˜
            }
        }
         .environmentObject(homeViewModel)
    }
}


// ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData


struct StatView: View {
   @ObservedObject var viewModel: StatViewModel
   @Binding var selectedTab: Int
   let correctAnswers: Int
   let totalQuestions: Int
   
   var incorrectAnswers: Int {
       totalQuestions - correctAnswers
   }
   
   var percentageCorrect: Int {
       guard totalQuestions > 0 else { return 0 }
       return Int((Double(correctAnswers) / Double(totalQuestions)) * 100)
   }
   
   var body: some View {
       ScrollView {
           VStack(spacing: 20) {
               Text("Result")
                   .font(.system(size: 34, weight: .bold))  // í¬ê¸°ë¥¼ í‚¤ìš°ê³  ë³¼ë“œ ì²˜ë¦¬
                   .padding(.top)
               
               // Progress Circle
               ZStack {
                   Circle()
                       .trim(from: 0, to: 1)
                       .stroke(Color.orange, lineWidth: 25)
                       .rotationEffect(.degrees(-90))
                       .frame(width: 200, height: 200)
                   
                   Circle()
                       .trim(from: 0, to: Double(correctAnswers) / Double(totalQuestions))
                       .stroke(Color.green, lineWidth: 25)
                       .rotationEffect(.degrees(-90))
                       .frame(width: 200, height: 200)
                   
                   Text("\(percentageCorrect)%")
                       .font(.system(size: 40, weight: .bold))
               }
               .padding(.vertical)
               
               // Correct/Incorrect Labels
               HStack(spacing: 50) {
                   HStack {
                       Text("Correct")
                           .foregroundColor(.green)
                       Text("\(correctAnswers)")
                           .font(.headline)
                           .padding(8)
                           .background(
                               Circle()
                                   .fill(Color.green.opacity(0.2))
                           )
                   }
                   
                   HStack {
                       Text("Incorrect")
                           .foregroundColor(.orange)
                       Text("\(incorrectAnswers)")
                           .font(.headline)
                           .padding(8)
                           .background(
                               Circle()
                                   .fill(Color.orange.opacity(0.2))
                           )
                   }
               }
               
               Spacer()
               
               VStack(spacing: 12) {
                   Button(action: {
                       viewModel.resetProgress()
                       viewModel.logCurrentQuestionState()
                       withAnimation {
                           selectedTab = 1
                       }
                   }) {
                       Text("Retry Test")
                           .font(.headline)
                           .foregroundColor(.white)
                           .padding()
                           .frame(maxWidth: .infinity)
                           .background(Color.blue)
                           .cornerRadius(10)
                   }
                   
                   Button(action: {
                       withAnimation {
                           selectedTab = 2  // Review íƒ­ìœ¼ë¡œ ì´ë™
                       }
                   }) {
                       Text("Take New Test")
                           .font(.headline)
                           .foregroundColor(.white)
                           .padding()
                           .frame(maxWidth: .infinity)
                           .background(Color.green)
                           .cornerRadius(10)
                   }
               }
               .padding(.horizontal)
               .padding(.bottom, 20)
           }
       }
   }
}


// ./AISnapStudy/Views/Main/HomeView.swift




import SwiftUI
import Combine
import CoreData

// MARK: - Main View
struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var showUpgradeView = false
    @State private var showStudySets = false
    @State private var selectedSubject: DefaultSubject = .generalKnowledge
    @StateObject private var storeService = StoreService.shared
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 32) {
                    // Welcome Section
                    VStack(alignment: .leading, spacing: 24) {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Welcome Back!")
                                .font(.system(size: 32, weight: .bold))
                                .foregroundColor(colorScheme == .dark ? .white : .black)
                            
                            if !storeService.subscriptionStatus.isPremium {
                                HStack(spacing: 8) {
                                    Image(systemName: "sparkles")
                                        .foregroundColor(.yellow)
                                    Text("\(storeService.subscriptionStatus.dailyQuestionsRemaining) questions remaining")
                                        .foregroundColor(.secondary)
                                }
                                .font(.system(size: 16))
                            }
                        }
                        .padding(.horizontal, 24)
                        
                        // Create Questions Button
                        Button(action: {
                            if storeService.subscriptionStatus.dailyQuestionsRemaining > 0 {
                                selectedSubject = .generalKnowledge
                                showQuestionSettings = true
                            } else {
                                // ë‚¨ì€ ì§ˆë¬¸ì´ ì—†ì„ ë•ŒëŠ” ì—…ê·¸ë ˆì´ë“œ ì•ˆë‚´
                                showUpgradeView = true
                            }
                        }) {
                            HStack(spacing: 12) {
                                Image(systemName: "sparkles")
                                    .font(.system(size: 28))
                                Text("Create New Questions")
                                    .font(.system(size: 22, weight: .semibold))
                            }
                            .frame(maxWidth: .infinity)
                            .frame(height: 100)
                            .foregroundColor(.white)
                            .background(
                                LinearGradient(
                                    colors: [
                                        storeService.subscriptionStatus.dailyQuestionsRemaining > 0 ? .blue : .gray,
                                        storeService.subscriptionStatus.dailyQuestionsRemaining > 0 ? .blue.opacity(0.8) : .gray.opacity(0.8)
                                    ],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .cornerRadius(16)
                        }
                        .padding(.horizontal, 24)
                    }
                    
                    // Favorites Section
                    if !viewModel.favoriteProblemSets.isEmpty {
                        VStack(alignment: .leading, spacing: 20) {
                            HStack(spacing: 12) {
                                Image(systemName: "star.fill")
                                    .foregroundColor(.yellow)
                                    .font(.system(size: 24))
                                Text("Favorites")
                                    .font(.system(size: 24, weight: .bold))
                                    .foregroundColor(colorScheme == .dark ? .white : .black)
                            }
                            .padding(.horizontal, 24)
                            
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: 16) {
                                    ForEach(viewModel.favoriteProblemSets) { set in
                                        Button {
                                            Task {
                                                await viewModel.setSelectedProblemSet(set)
                                                if let studyViewModel = viewModel.studyViewModel {
                                                    await studyViewModel.resetState()
                                                    selectedTab = 1
                                                }
                                            }
                                        } label: {
                                            VStack(alignment: .leading, spacing: 8) {
                                                Text(set.name)
                                                    .font(.system(size: 18, weight: .semibold))
                                                    .foregroundColor(.primary)
                                                    .lineLimit(1)
                                                    .truncationMode(.tail)
                                                Text("\(set.questions.count) Questions")
                                                    .font(.system(size: 14))
                                                    .foregroundColor(.secondary)
                                            }
                                            .frame(width: 230)
                                            .padding(16)
                                            .background(colorScheme == .dark ? Color(.systemGray6) : .white)
                                            .cornerRadius(12)
                                            .overlay(
                                                RoundedRectangle(cornerRadius: 12)
                                                    .stroke(Color.gray.opacity(0.1), lineWidth: 3)
                                            )
                                            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
                                        }
                                    }
                                }
                                .padding(.horizontal, 24)
                            }
                        }
                    }
                    
                    // Library Section
                    VStack(alignment: .leading, spacing: 20) {
                        HStack(spacing: 12) {
                            Image(systemName: "square.stack.3d.up.fill")
                                .foregroundColor(.blue)
                                .font(.system(size: 24))
                            Text("Library")
                                .font(.system(size: 24, weight: .bold))
                                .foregroundColor(colorScheme == .dark ? .white : .black)
                        }
                        .padding(.horizontal, 24)
                        
                        Button {
                            showStudySets = true
                        } label: {
                            HStack {
                                Text("View library question sets")
                                    .font(.system(size: 18))
                                    .foregroundColor(.primary)
                                Spacer()
                                Text("\(viewModel.remoteSets.count) Sets")
                                    .foregroundColor(.secondary)
                                Image(systemName: "chevron.right")
                                    .font(.system(size: 14))
                                    .foregroundColor(.secondary)
                            }
                            .padding(20)
                            .background(colorScheme == .dark ? Color(.systemGray6) : .white)
                            .cornerRadius(12)
                            .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
                        }
                        .padding(.horizontal, 24)
                    }
                }
                .padding(.vertical, 32)
            }
            .background(colorScheme == .dark ? Color.black : Color(.systemBackground))
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .principal) {
                    HStack {
                        Text("AI Study")
                            .font(.system(size: 34, weight: .bold))
                            .foregroundColor(colorScheme == .dark ? .white : .black)
                        Spacer()
                        if !storeService.subscriptionStatus.isPremium {
                            Button(action: { showUpgradeView = true }) {
                                Text("Upgrade")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.black)
                                    .padding(.horizontal, 16)
                                    .padding(.vertical, 8)
                                    .background(Color.yellow)
                                    .cornerRadius(20)
                            }
                        }
                    }
                    .padding(.bottom, 8)
                }
            }
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab
            )
        }
        .sheet(isPresented: $showUpgradeView) {
            PremiumUpgradeView()
        }
        .sheet(isPresented: $showStudySets) {
            StudySetsView(viewModel: viewModel)
        }
    }
}


// MARK: - Section Header
struct SectionHeader: View {
    let title: String
    let icon: String
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: icon)
                .foregroundColor(.blue)
            Text(title)
                .font(.title3.bold())
        }
        .padding(.horizontal)
    }
}

// MARK: - Welcome Section
struct WelcomeSection: View {
    let isPremium: Bool
    let remainingQuestions: Int
    @Binding var showUpgradeView: Bool
    
    var body: some View {
        VStack(spacing: 16) {
            // í™˜ì˜ ë©”ì‹œì§€ ì¹´ë“œ
            CardView {
                HStack {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Welcome Back!")
                            .font(.title2.bold())
                        Text("Ready to learn something new?")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                    Spacer()
                    Image(systemName: "brain.head.profile")
                        .font(.system(size: 40))
                        .foregroundColor(.blue)
                }
            }
            
            // í”„ë¦¬ë¯¸ì—„ ë°°ë„ˆ (ë¬´ë£Œ ì‚¬ìš©ìë§Œ í‘œì‹œ)
            if !isPremium {
                Button(action: { showUpgradeView = true }) {
                    CardView {
                        HStack {
                            HStack(spacing: 8) {
                                Image(systemName: "star.fill")
                                    .foregroundColor(.yellow)
                                Text("Upgrade to Premium")
                                    .fontWeight(.semibold)
                            }
                            Spacer()
                            Text("\(remainingQuestions) questions left")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
        .padding(.horizontal)
    }
}

// CardView ì»´í¬ë„ŒíŠ¸
struct CardView<Content: View>: View {
    let content: Content
    
    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }
    
    var body: some View {
        content
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
    }
}




// MARK: - Favorites List
struct FavoritesList: View {
    let problemSets: [ProblemSet]
    let viewModel: HomeViewModel
    @Binding var selectedTab: Int
    
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(problemSets) { set in
                    FavoriteCard(
                        set: set,
                        action: {
                            Task {
                                await viewModel.setSelectedProblemSet(set)
                                if let studyViewModel = viewModel.studyViewModel {
                                    await studyViewModel.resetState()
                                    selectedTab = 1
                                }
                            }
                        }
                    )
                }
            }
            .padding(.horizontal)
        }
    }
}

// MARK: - Favorite Card
// ì„ íƒì ìœ¼ë¡œ ë³„ë„ì˜ FavoriteCard ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤
struct FavoriteCard: View {
    let set: ProblemSet
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 8) {
                Text(set.name)
                    .font(.system(size: 18, weight: .semibold))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                    .truncationMode(.tail)
                Text("\(set.questions.count) Questions")
                    .font(.system(size: 14))
                    .foregroundColor(.gray)
            }
            .frame(width: 280)
            .padding(16)
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
    }
}

// MARK: - Downloadable Sets List
struct DownloadableSetsList: View {
    let remoteSets: [RemoteQuestionSet]
    let viewModel: HomeViewModel
    
    var body: some View {
        VStack(spacing: 4) { // ë¦¬ìŠ¤íŠ¸ì˜ ê°„ê²©ë§Œ ì¤„ì„
            ForEach(remoteSets) { set in
                DownloadableSetCard(
                    set: set,
                    action: {
                        Task {
                            await viewModel.downloadQuestionSet(set)
                        }
                    }
                )
            }
        }
        .padding(.horizontal)
    }
}

struct DownloadableSetCard: View {
    let set: RemoteQuestionSet
    let action: () -> Void
    
    @State private var isDownloading = false
    @State private var isCompleted = false
    
    var body: some View {
        CardView {
            HStack(spacing: 12) {
                // íƒ€ì´í‹€ê³¼ ì •ë³´
                VStack(alignment: .leading, spacing: 4) {
                    Text(set.title)
                        .font(.headline)
                    
                    HStack(spacing: 12) {
                        // ë¬¸ì œ ìˆ˜
                        HStack(spacing: 4) {
                            Image(systemName: "doc.text")
                                .foregroundColor(.blue)
                            Text("\(set.questionCount)")
                                .foregroundColor(.secondary)
                        }
                        .font(.subheadline)
                        
                        // ë‚œì´ë„
                        HStack(spacing: 4) {
                            Image(systemName: "chart.bar.fill")
                                .foregroundColor(.blue)
                            Text(set.difficulty)
                                .foregroundColor(.secondary)
                        }
                        .font(.subheadline)
                    }
                }
                
                Spacer()
                
                // ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
                Button {
                    withAnimation {
                        isDownloading = true
                    }
                    action()
                    
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                        withAnimation {
                            isDownloading = false
                            isCompleted = true
                        }
                    }
                } label: {
                    Group {
                        if isCompleted {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                        } else if isDownloading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle())
                        } else {
                            Image(systemName: "arrow.down.circle.fill")
                                .foregroundColor(.blue)
                        }
                    }
                    .frame(width: 24, height: 24)
                }
                .disabled(isDownloading || isCompleted)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
        }
        .padding(.horizontal)
        .padding(.vertical, 4)
    }
}


// ì›ê²© ë¬¸ì œ ì„¸íŠ¸ ì„¹ì…˜ ì»´í¬ë„ŒíŠ¸
struct RemoteQuestionSetsSection: View {
    let remoteSets: [RemoteQuestionSet]
    let viewModel: HomeViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Available Question Sets")
                .font(.system(size: 20, weight: .semibold))
                .foregroundColor(.primary)
                .padding(.horizontal)
            
            ForEach(remoteSets) { remoteSet in
                RemoteQuestionSetCard(
                    set: remoteSet,
                    onDownload: {
                        Task {
                            await viewModel.downloadQuestionSet(remoteSet)
                        }
                    }
                )
                .padding(.horizontal)
            }
        }
    }
}

// ì›ê²© ë¬¸ì œ ì„¸íŠ¸ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
struct RemoteQuestionSetCard: View {
    let set: RemoteQuestionSet
    let onDownload: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(set.title)
                .font(.headline)
                .foregroundColor(.primary)
            
            Text(set.description)
                .font(.subheadline)
                .foregroundColor(.secondary)
                .lineLimit(2)
            
            HStack {
                HStack(spacing: 8) {
                    Image(systemName: "doc.text")
                        .foregroundColor(.blue)
                    Text("\(set.questionCount) questions")
                }
                .font(.caption)
                .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: onDownload) {
                    HStack {
                        Image(systemName: "arrow.down.circle.fill")
                        Text("Download")
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.1), radius: 5, x: 0, y: 2)
    }
}

// Premium ì—…ê·¸ë ˆì´ë“œ ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸
struct PremiumUpgradeButton: View {
    let remainingQuestions: Int
    @Binding var showUpgradeView: Bool
    
    var body: some View {
        Button(action: {
            showUpgradeView = true
        }) {
            HStack {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
                Text("Upgrade to Premium")
                    .fontWeight(.semibold)
                    .foregroundColor(.primary)
                Spacer()
                Text("\(remainingQuestions) questions left")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding()
            .background(Color(.systemBackground))
            .cornerRadius(10)
            .shadow(radius: 2)
        }
        .padding(.horizontal)
    }
}



// ./AISnapStudy/Views/Main/ReviewView.swift

import SwiftUI

struct ReviewView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @ObservedObject var viewModel: ReviewViewModel
    @StateObject private var subjectManager = SubjectManager.shared
    @State private var showSubjectManagement = false
    @State private var searchText = ""
    @State private var selectedSubject: SubjectType?
    @Binding var selectedTab: Int
   
    public init(viewModel: ReviewViewModel, selectedTab: Binding<Int>) {
        self.viewModel = viewModel
        self._selectedTab = selectedTab
    }
    
    private var visibleSubjects: [SubjectType] {
        let defaultSubjects = DefaultSubject.allCases.filter { !subjectManager.isDeleted($0) }
        let customSubjects = subjectManager.customSubjects.filter { $0.isActive }
        
        let subjects = defaultSubjects as [SubjectType] + customSubjects
        
        print("""
        ğŸ“š ReviewView - Visible Subjects:
        â€¢ Total Subjects: \(subjects.count)
        â€¢ Active Default Subjects: \(defaultSubjects.map { $0.displayName })
        â€¢ Active Custom Subjects: \(customSubjects.map { $0.displayName })
        â€¢ Hidden Subjects: \(subjectManager.hiddenDefaultSubjects)
        """)
        
        return subjects
    }
   
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 5) {
                    Spacer()
                        .frame(height: 5)
                    
                    // Add Saved Questions Card
                    NavigationLink(
                        destination: SavedQuestionsView(selectedTab: $selectedTab)
                    ) {
                        SavedQuestionsCard(savedCount: homeViewModel.savedQuestions.count)
                    }
                    .buttonStyle(PlainButtonStyle())
                    .padding(.horizontal)
                    
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 5) {
                        ForEach(visibleSubjects, id: \.id) { subject in
                            NavigationLink(
                                destination: ProblemSetsListView(
                                    subject: subject,
                                    problemSets: filterProblemSets(subject: subject),
                                    selectedTab: $selectedTab
                                )
                            ) {
                                SubjectCardView(
                                    subject: subject,
                                    problemSetCount: filterProblemSets(subject: subject).count
                                )
                            }
                        }
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .principal) {
                    Text("Review")
                        .font(.system(size: 34, weight: .bold))  // í¬ê¸°ë¥¼ í‚¤ìš°ê³  ë³¼ë“œ ì²˜ë¦¬
                        .padding(.bottom, 5)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showSubjectManagement = true
                    }) {
                        Image(systemName: "slider.horizontal.3")
                            .foregroundColor(.blue)
                            .imageScale(.large)
                    }
                }
            }
            .sheet(isPresented: $showSubjectManagement) {
                NavigationView {
                    SubjectManagementView()
                        .navigationTitle("Manage Subjects")
                        .navigationBarItems(
                            trailing: Button("Done") {
                                showSubjectManagement = false
                            }
                        )
                }
            }
        }
    }
    
    private func filterProblemSets(subject: SubjectType) -> [ProblemSet] {
        return homeViewModel.problemSets.filter { problemSet in
            if let defaultSubject = subject as? DefaultSubject {
                return problemSet.subjectType == "default" &&
                       problemSet.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return problemSet.subjectType == "custom" &&
                       problemSet.subjectId == customSubject.id
            }
            return false
        }
    }
}

// Add new SavedQuestionsCard component
struct SavedQuestionsCard: View {
    let savedCount: Int
    
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: "bookmark.fill")
                .font(.system(size: 24))
                .foregroundColor(.blue)
            
            VStack(alignment: .leading, spacing: 4) {
                Text("Saved Questions")
                    .font(.headline)
                Text("\(savedCount) questions saved")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Image(systemName: "chevron.right")
                .foregroundColor(.gray)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(
                    color: Color.black.opacity(0.1),
                    radius: 8,
                    x: 0,
                    y: 4
                )
        )
    }
}

struct SubjectCardView: View {
    let subject: SubjectType
    let problemSetCount: Int
    
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: subject.icon)
                .font(.system(size: 32))
                .foregroundColor(subject.color)
            
            Text(subject.displayName)
                .font(.headline)
                .foregroundColor(.primary)
                .lineLimit(1)
            
            Text("\(problemSetCount) sets")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 24)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(subject.color.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(subject.color.opacity(0.2), lineWidth: 1)
                )
        )
        .contentShape(Rectangle())
    }
}

struct ProblemSetsListView: View {
    let subject: SubjectType
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @Binding var selectedTab: Int
    @State private var isEditMode = false
    @State private var showHelpAlert = false
    @State private var localProblemSets: [ProblemSet] = []
    
    // ì•Œë¦¼ ê´€ë ¨ ìƒíƒœ
    @State private var isShowingDeleteAlert = false
    @State private var problemSetToDelete: ProblemSet?
    @State private var showingMergeAlert = false
    @State private var mergingProblemSets: (source: ProblemSet, target: ProblemSet)?
    @State private var mergeSetName = ""
    
    var body: some View {
        ProblemSetListContainer(
            localProblemSets: localProblemSets,
            isEditMode: isEditMode,
            selectedTab: $selectedTab,
            problemSetToDelete: $problemSetToDelete,
            isShowingDeleteAlert: $isShowingDeleteAlert
        )
        .navigationTitle(subject.displayName)
        .toolbar {
            ProblemSetToolbar(
                isEditMode: $isEditMode,
                showHelpAlert: $showHelpAlert
            )
        }
        .onAppear { localProblemSets = problemSets }
        .onChange(of: homeViewModel.problemSets) { newProblemSets in
            updateLocalProblemSets(newProblemSets)
        }
        .alert("Delete Problem Set", isPresented: $isShowingDeleteAlert) {
            DeleteAlertButtons(
                problemSetToDelete: problemSetToDelete,
                homeViewModel: homeViewModel
            )
        }
    }
    
    private func updateLocalProblemSets(_ newProblemSets: [ProblemSet]) {
        localProblemSets = newProblemSets.filter { set in
            if let defaultSubject = subject as? DefaultSubject {
                return set.subjectType == "default" && set.subject.rawValue == defaultSubject.rawValue
            } else if let customSubject = subject as? CustomSubject {
                return set.subjectType == "custom" && set.subjectId == customSubject.id
            }
            return false
        }
    }
}

// MARK: - Supporting Views
private struct ProblemSetListContainer: View {
    let localProblemSets: [ProblemSet]
    let isEditMode: Bool
    @Binding var selectedTab: Int
    @Binding var problemSetToDelete: ProblemSet?
    @Binding var isShowingDeleteAlert: Bool
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var refreshID = UUID() // ì¶”ê°€
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                LazyVStack(spacing: 12) {
                    ForEach(localProblemSets) { problemSet in
                        ProblemSetItem(
                            problemSetId: problemSet.id,  // IDë§Œ ì „ë‹¬
                            isEditMode: isEditMode,
                            selectedTab: $selectedTab,
                            problemSetToDelete: $problemSetToDelete,
                            isShowingDeleteAlert: $isShowingDeleteAlert,
                            onFavoriteToggle: {
                                Task {
                                    await homeViewModel.toggleFavorite(problemSet)
                                    // UI ê°•ì œ ìƒˆë¡œê³ ì¹¨
                                    await MainActor.run {
                                        refreshID = UUID()
                                    }
                                }
                            }
                        )
                    }
                }
            }
            .padding(.vertical)
            .id(refreshID) // ì¶”ê°€
        }
    }
}

private struct ProblemSetItem: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    let problemSetId: String  // problemSet ëŒ€ì‹  IDë§Œ ì €ì¥
    let isEditMode: Bool
    @Binding var selectedTab: Int
    @Binding var problemSetToDelete: ProblemSet?
    @Binding var isShowingDeleteAlert: Bool
    let onFavoriteToggle: () -> Void

    // í•„ìš”í•  ë•Œë§ˆë‹¤ ìµœì‹  problemSet ë°ì´í„° ì¡°íšŒ
    private var problemSet: ProblemSet? {
        homeViewModel.problemSets.first { $0.id == problemSetId }
    }
    
    // ìƒì„±ì ìˆ˜ì •
    init(problemSetId: String,
         isEditMode: Bool,
         selectedTab: Binding<Int>,
         problemSetToDelete: Binding<ProblemSet?>,
         isShowingDeleteAlert: Binding<Bool>,
         onFavoriteToggle: @escaping () -> Void) {
        self.problemSetId = problemSetId
        self.isEditMode = isEditMode
        self._selectedTab = selectedTab
        self._problemSetToDelete = problemSetToDelete
        self._isShowingDeleteAlert = isShowingDeleteAlert
        self.onFavoriteToggle = onFavoriteToggle
    }
    
    var body: some View {
        Group {
            if let currentProblemSet = problemSet {
                ReviewProblemSetCard(
                    subject: currentProblemSet.resolvedSubject,
                    problemSet: currentProblemSet,
                    isEditMode: isEditMode,
                    onDelete: {
                        problemSetToDelete = currentProblemSet
                        isShowingDeleteAlert = true
                    },
                    onRename: { newName in
                        Task {
                            await homeViewModel.renameProblemSet(currentProblemSet, newName: newName)
                        }
                    },
                    onFavoriteToggle: onFavoriteToggle
                )
                .onTapGesture {
                    handleTap(problemSet: currentProblemSet)
                }
            }
        }
        .padding(.horizontal)
    }
    
    private func handleTap(problemSet: ProblemSet) {
        Task {
            await homeViewModel.setSelectedProblemSet(problemSet)
            if let studyViewModel = homeViewModel.studyViewModel {
                await studyViewModel.resetState()
                await MainActor.run {
                    withAnimation {
                        selectedTab = 1
                    }
                }
            }
        }
    }
}

private struct ProblemSetToolbar: ToolbarContent {
    @Binding var isEditMode: Bool
    @Binding var showHelpAlert: Bool
    
    var body: some ToolbarContent {
        ToolbarItem(placement: .navigationBarTrailing) {
            HStack(spacing: 16) {
                Button(action: { showHelpAlert = true }) {
                    Image(systemName: "questionmark.circle")
                        .imageScale(.large)
                        .foregroundColor(.blue)
                }
                
                Button(action: {
                    withAnimation {
                        isEditMode.toggle()
                    }
                }) {
                    Image(systemName: isEditMode ? "checkmark.circle.fill" : "pencil.circle")
                        .imageScale(.large)
                        .foregroundColor(isEditMode ? .green : .blue)
                }
            }
        }
    }
}

private struct DeleteAlertButtons: View {
    let problemSetToDelete: ProblemSet?
    let homeViewModel: HomeViewModel
    
    var body: some View {
        Group {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let problemSet = problemSetToDelete {
                    Task {
                        await homeViewModel.deleteProblemSet(problemSet)
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Main/StudySetsView.swift

import SwiftUI


// ì •ë ¬ ì˜µì…˜ì„ ìœ„í•œ enum
enum SortOption: String, CaseIterable {
    case name = "Name"
    case questionCount = "Questions"
    case difficulty = "Difficulty"
}

struct StudySetsView: View {
    let viewModel: HomeViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var selectedSort: SortOption = .name
    @State private var isAscending = true
    
    private var sortedSets: [RemoteQuestionSet] {
        var sets = viewModel.remoteSets
        
        switch selectedSort {
        case .name:
            sets.sort { (set1, set2) in
                isAscending ? set1.title < set2.title : set1.title > set2.title
            }
        case .questionCount:
            sets.sort { (set1, set2) in
                isAscending ? set1.questionCount < set2.questionCount : set1.questionCount > set2.questionCount
            }
        case .difficulty:
            let difficultyOrder = ["Elementary": 0, "Middle": 1, "Hard": 2]
            sets.sort { (set1, set2) in
                let order1 = difficultyOrder[set1.difficulty] ?? 0
                let order2 = difficultyOrder[set2.difficulty] ?? 0
                return isAscending ? order1 < order2 : order1 > order2
            }
        }
        
        return sets
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 2) {
                    ForEach(sortedSets) { set in
                        DownloadableSetCard(
                            set: set,
                            action: {
                                Task {
                                    await viewModel.downloadQuestionSet(set)
                                }
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Text("Study Sets")
                        .font(.system(size: 22, weight: .semibold))
                        .foregroundColor(.primary)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    HStack(spacing: 16) {
                        Menu {
                            Picker("Sort by", selection: $selectedSort) {
                                ForEach(SortOption.allCases, id: \.self) { option in
                                    Text(option.rawValue)
                                }
                            }
                            
                            Divider()
                            
                            Button(action: { isAscending.toggle() }) {
                                HStack {
                                    Text(isAscending ? "Ascending" : "Descending")
                                    Image(systemName: isAscending ? "arrow.up" : "arrow.down")
                                }
                            }
                        } label: {
                            Image(systemName: "arrow.up.arrow.down")
                                .foregroundColor(.blue)
                        }
                        
                        Button("Done") {
                            dismiss()
                        }
                    }
                }
            }
        }
    }
}




// LocalSetCard ì»´í¬ë„ŒíŠ¸
struct LocalSetCard: View {
    let set: ProblemSet
    let viewModel: HomeViewModel
    
    var body: some View {
        CardView {
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text(set.name)
                            .font(.headline)
                        Text("\(set.questions.count) Questions")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                    
                    Spacer()
                    
                    Button {
                        Task {
                            await viewModel.toggleFavorite(set)
                        }
                    } label: {
                        Image(systemName: set.isFavorite ? "star.fill" : "star")
                            .foregroundColor(set.isFavorite ? .yellow : .gray)
                    }
                }
            }
            .padding()
        }
        .padding(.horizontal)
    }
}


// ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
    @EnvironmentObject var homeViewModel: HomeViewModel  // ì¶”ê°€
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
    @State private var isCorrect: Bool? = nil  // ì´ ë¶€ë¶„ì´ ì¤‘ìš”í•©ë‹ˆë‹¤
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // ì¶”ê°€
   @State private var previewIsCorrect: Bool? = nil        // ì¶”ê°€
    @State private var showDeleteAlert = false  // ì¶”ê°€
    @State private var questionToDelete: Question? = nil  // ì¶”ê°€
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
    var body: some View {
        VStack {
            if studyViewModel.isGeneratingQuestions {
                VStack(spacing: 16) {
                    GeneratingQuestionsOverlay(
                        questionCount: studyViewModel.totalExpectedQuestions
                    )
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.white)
                    .transition(.opacity)
                    
                    if !studyViewModel.generatedQuestions.isEmpty {
                        ScrollView {
                            LazyVStack(spacing: 12) {
                                ForEach(studyViewModel.generatedQuestions) { question in
                                    QuestionPreviewCard(
                                        question: question,
                                        selectedAnswer: $previewSelectedAnswer,
                                        isCorrect: $previewIsCorrect,
                                        onAnswerSelected: { correct in
                                            print("Answer selected: \(correct)")
                                        }
                                    )
                                    .transition(.slide)
                                }
                            }
                            .padding()
                        }
                    }
                }
            } else if !studyViewModel.hasQuestions {
                Text("No questions available")
                    .font(.title3)
                    .foregroundColor(.gray)
            } else {
                VStack {
                    Spacer()
                        .frame(height: 20)
                    
                    ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                               total: Double(studyViewModel.totalQuestions))
                        .progressViewStyle(CustomProgressViewStyle())
                        .padding(.horizontal, 20)
                        .padding(.bottom, 10)
                    
                    Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.secondary)
                        .padding(.bottom, 20)
                    
                    if !studyViewModel.hasQuestions {
                        Text("No questions available")
                            .font(.title3)
                            .foregroundColor(.gray)
                    } else {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 20) {
                                if let currentQuestion = studyViewModel.currentQuestion {
                                    switch currentQuestion.type {
                                    case .multipleChoice:
                                        MultipleChoiceView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect
                                        )
                                        
                                    case .trueFalse:
                                        TrueFalseView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect  // ì—¬ê¸° isCorrect ë°”ì¸ë”©ì´ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤
                                        )
                                    }
                                    
                                    if showExplanation && studyViewModel.showExplanation {
                                        ExplanationView(explanation: currentQuestion.explanation)
                                    }
                                }
                            }
                            .padding()
                        }
                        
                        VStack {
                            Divider()
                            
                            HStack(spacing: 12) {
                                if studyViewModel.showExplanation {
                                    UtilityButtons(
                                        showExplanation: $showExplanation,
                                        isSaved: $isSaved,
                                        studyViewModel: studyViewModel,
                                        onDelete: {
                                            questionToDelete = studyViewModel.currentQuestion
                                            showDeleteAlert = true
                                        }
                                    )
                                }
                                
                                ActionButton(
                                    viewModel: studyViewModel,
                                    selectedTab: $selectedTab,
                                    isCorrect: $isCorrect,
                                    showExplanation: $showExplanation
                                )
                            }
                            .padding()
                            .background(Color(UIColor.systemBackground))
                        }
                    }
                }
            }
        }
        .alert("Delete Question", isPresented: $showDeleteAlert) {  // ì¶”ê°€
                    Button("Cancel", role: .cancel) { }
                    Button("Delete", role: .destructive) {
                        if let question = questionToDelete,
                           let problemSet = homeViewModel.selectedProblemSet {
                            Task {
                                await homeViewModel.removeQuestionFromProblemSet(
                                    question.id,
                                    from: problemSet
                                )
                            }
                        }
                    }
                } message: {
                    Text("Are you sure you want to delete this question?")
                }
        .onAppear {
            if let currentQuestion = studyViewModel.currentQuestion {
                isSaved = currentQuestion.isSaved
            }
        }
        .onChange(of: studyViewModel.currentQuestion) { newQuestion in
            if let question = newQuestion {
                isSaved = question.isSaved
            }
        }
    }
}

struct CustomProgressViewStyle: ProgressViewStyle {
    func makeBody(configuration: Configuration) -> some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 12)
                
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.blue)
                    .frame(width: CGFloat(configuration.fractionCompleted ?? 0) * geometry.size.width,
                           height: 12)
            }
        }
        .frame(height: 12)
    }
}

// ìƒˆë¡œ ì¶”ê°€ëœ ë¯¸ë¦¬ë³´ê¸° ì¹´ë“œ ë·°
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // ìƒë‹¨ ì •ë³´
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
          }
          
          // ì§ˆë¬¸
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // ë‹µë³€ ì˜µì…˜
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ë“¤ì€ ìœ ì§€
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   let onDelete: () -> Void
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
           
           Button(action: onDelete) {
               Image(systemName: "trash")
                   .foregroundColor(.red)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.red.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil  // ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°ˆ ë•Œ ë¦¬ì…‹
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               if let currentQuestion = viewModel.currentQuestion,
                  let selectedAnswer = viewModel.selectedAnswer {
                   isCorrect = currentQuestion.correctAnswer.lowercased() == selectedAnswer.lowercased()
               }
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}

struct GeneratingQuestionsOverlay: View {
    let questionCount: Int  // í•„ìš”í•˜ì§€ë§Œ ì‚¬ìš©í•˜ì§€ ì•Šì„ ë§¤ê°œë³€ìˆ˜
    @State private var rotation: Double = 0
    @State private var dotScale: CGFloat = 1.0
    @State private var currentTipIndex = 0
    let timer = Timer.publish(every: 5, on: .main, in: .common).autoconnect()
    
    var body: some View {
        ZStack {
            // ë°°ê²½ìƒ‰ì„ í°ìƒ‰ìœ¼ë¡œ ë³€ê²½
            Color.white
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 30) {
                // Main Animation Circle
                ZStack {
                    // Outer rotating circle
                    Circle()
                        .stroke(lineWidth: 6)
                        .frame(width: 200, height: 200)
                        .foregroundColor(.blue.opacity(0.3))
                        .rotationEffect(.degrees(rotation))
                    
                    // Inner gradient circle
                    Circle()
                        .stroke(
                            LinearGradient(
                                gradient: Gradient(colors: [.blue, .purple]),
                                startPoint: .top,
                                endPoint: .bottom
                            ),
                            lineWidth: 10
                        )
                        .frame(width: 180, height: 180)
                        .rotationEffect(.degrees(-rotation))
                    
                    // Center content - í…ìŠ¤íŠ¸ ìƒ‰ìƒì„ ê²€ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½í•˜ê³  Questions ìˆ˜ í‘œì‹œ ì œê±°
                    VStack(spacing: 8) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 40))
                            .foregroundColor(.blue)
                        Text("Generating")
                            .font(.title)
                            .foregroundColor(.black)  // ê²€ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½
                        Text("Questions")
                            .font(.title2)
                            .foregroundColor(.black)  // ê²€ì€ìƒ‰ìœ¼ë¡œ ë³€ê²½
                    }
                }
                .onAppear {
                    withAnimation(
                        .linear(duration: 4)
                        .repeatForever(autoreverses: false)
                    ) {
                        rotation = 360
                    }
                }
                
                // Animated Dots
                HStack(spacing: 8) {
                    ForEach(0..<3) { index in
                        Circle()
                            .fill(Color.blue)
                            .frame(width: 12, height: 12)
                            .scaleEffect(dotScale)
                            .animation(
                                .easeInOut(duration: 0.6)
                                .repeatForever()
                                .delay(Double(index) * 0.2),
                                value: dotScale
                            )
                    }
                }
                .onAppear {
                    dotScale = 0.5
                }
                
                // Tips Section
                VStack(spacing: 12) {
                    Text(tips[currentTipIndex])
                        .font(.headline)
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                        .frame(height: 60)
                        .transition(.opacity.combined(with: .slide))
                        .id(currentTipIndex)
                        .animation(.easeInOut, value: currentTipIndex)
                    
                    // Progress Dots
                    HStack(spacing: 6) {
                        ForEach(0..<tips.count) { index in
                            Circle()
                                .fill(index == currentTipIndex ? Color.white : Color.gray)
                                .frame(width: 8, height: 8)
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 15)
                        .fill(Color.blue.opacity(0.8))
                )
            }
            .padding(30)
        }
        .onReceive(timer) { _ in
            withAnimation {
                currentTipIndex = (currentTipIndex + 1) % tips.count
            }
        }
    }
    
    private let tips = [
        "Creating personalized questions just for you...",
        "Analyzing content to ensure the best learning experience...",
        "Getting ready to challenge your knowledge...",
        "Preparing explanations to help you understand better...",
        "Almost there! Your questions are being finalized..."
    ]
}

struct GeneratedQuestionPreviewCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: question.type == .multipleChoice ? "list.bullet.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(.blue)
                Text(question.type == .multipleChoice ? "Multiple Choice" : "True/False")
                    .font(.caption)
                    .foregroundColor(.blue)
                Spacer()
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .foregroundColor(.primary)
        }
        .padding()
        .background(Color.white)
        .cornerRadius(10)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
    }
}


// ./AISnapStudy/Views/Stats/CalendarStatsView.swift

import SwiftUI



struct CalendarStatsView: View {
    @State private var selectedMonth = Date()  // ë‚´ë¶€ì—ì„œ ìƒíƒœ ê´€ë¦¬
    let monthlyData: [Date: [DailyStats]]
    private let calendar = Calendar.current
    private let daysInWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    
    private var calendarDays: [CalendarDay] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: selectedMonth),
              let monthFirstWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.start),
              let monthLastWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.end) else {
            return []
        }
        
        let dateInterval = DateInterval(start: monthFirstWeek.start, end: monthLastWeek.end)
        let dates = calendar.generateDates(for: dateInterval, matching: DateComponents(hour: 0))
        
        return dates.enumerated().map { CalendarDay(id: $0, date: $1) }
    }
    
    private func convertToDailyProgress(_ stats: DailyStats) -> DailyProgress {
        return DailyProgress(
            date: stats.date,
            questionsCompleted: stats.totalQuestions,
            correctAnswers: stats.correctAnswers,
            totalTime: 0  // ì‹œê°„ ë°ì´í„°ê°€ ì—†ë‹¤ë©´ 0ìœ¼ë¡œ ì„¤ì •
        )
    }
    
    var body: some View {
        VStack {
            HStack {
                Button(action: previousMonth) {
                    Image(systemName: "chevron.left")
                }
                
                Text(monthString)
                    .font(.headline)
                    .frame(maxWidth: .infinity)
                
                Button(action: nextMonth) {
                    Image(systemName: "chevron.right")
                }
            }
            .padding(.bottom)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 7)) {
                 // ìš”ì¼ í—¤ë”
                 ForEach(daysInWeek, id: \.self) { day in
                     Text(day)
                         .font(.caption)
                         .foregroundColor(.secondary)
                 }
                 
                 // ë‚ ì§œ ê·¸ë¦¬ë“œ
                 ForEach(calendarDays, id: \.id) { calendarDay in
                     if let stats = statsFor(date: calendarDay.date) {
                         DayCellView(
                             date: calendarDay.date,
                             progress: convertToDailyProgress(stats)
                         )
                     } else {
                         Text(String(calendar.component(.day, from: calendarDay.date)))
                             .font(.caption)
                             .foregroundColor(.secondary)
                             .frame(height: 35)
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var monthString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: selectedMonth)
    }
    
    private var days: [Date] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: selectedMonth),
              let monthFirstWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.start),
              let monthLastWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.end) else {
            return []
        }
        
        let dateInterval = DateInterval(start: monthFirstWeek.start, end: monthLastWeek.end)
        return calendar.generateDates(for: dateInterval, matching: DateComponents(hour: 0))
    }
    
    private func statsFor(date: Date) -> DailyStats? {
        let monthRange = calendar.monthDateRange(for: selectedMonth)
        guard let stats = monthlyData[monthRange.start] else { return nil }
        return stats.first { calendar.isDate($0.date, inSameDayAs: date) }
    }
    
    private func previousMonth() {
        selectedMonth = calendar.date(byAdding: .month, value: -1, to: selectedMonth) ?? selectedMonth
    }
    
    private func nextMonth() {
        selectedMonth = calendar.date(byAdding: .month, value: 1, to: selectedMonth) ?? selectedMonth
    }
}




// ./AISnapStudy/Views/Stats/DailyStatsView.swift

import SwiftUI
import Charts

enum TimeRange: String, CaseIterable {
    case week = "Week"
    case month = "Month"
}

struct DailyStatsView: View {
    @State private var currentMonthDate = Date()  // ì¶”ê°€ëœ ìƒíƒœ ë³€ìˆ˜
    @ObservedObject var viewModel: StatViewModel
    @State private var selectedTimeRange: TimeRange = .week
    @State private var selectedDate = Date()
    @State private var showingDatePicker = false
    
    private var todayStats: DailyProgress? {
        let calendar = Calendar.current
        return viewModel.weeklyProgress.first {
            calendar.isDate($0.date, inSameDayAs: Date())
        }
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                timePicker
                
                switch selectedTimeRange {
                case .week:
                    weeklyProgressChart
                case .month:
                    VStack(spacing: 10) {
                        // ì›” ì´ë™ ì»¨íŠ¸ë¡¤
                        HStack {
                            Button(action: previousMonth) {
                                Image(systemName: "chevron.left")
                                    .font(.title3)
                            }
                            
                            Text(monthYearString)
                                .font(.headline)
                                .frame(maxWidth: .infinity)
                            
                            Button(action: nextMonth) {
                                Image(systemName: "chevron.right")
                                    .font(.title3)
                            }
                        }
                        .padding(.horizontal)
                        
                        MonthCalendarView(
                            month: currentMonthDate,
                            monthlyData: viewModel.monthlyProgress
                        )
                    }
                }
                
                StatsCircleContainer(
                    todayStats: todayStats,
                    weeklyStats: viewModel.weeklyProgress,
                    monthlyProgress: viewModel.monthlyProgress,  // ì¶”ê°€
                    selectedTimeRange: selectedTimeRange,        // ì¶”ê°€
                    currentMonthDate: currentMonthDate
                )
            }
            .padding()
        }
        .navigationTitle("Daily Statistics")
    }
    
    private var monthYearString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: currentMonthDate)
    }
    
    private func previousMonth() {
        if let newDate = Calendar.current.date(byAdding: .month, value: -1, to: currentMonthDate) {
            currentMonthDate = newDate
        }
    }
    
    private func nextMonth() {
        if let newDate = Calendar.current.date(byAdding: .month, value: 1, to: currentMonthDate) {
            currentMonthDate = newDate
        }
    }

    
    
    private var weeklyProgressChart: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Weekly Progress")
                .font(.headline)
                .padding(.horizontal)
            
            Chart {
                ForEach(viewModel.weeklyProgress) { progress in
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.questionsCompleted)
                    )
                    .position(by: .value("Type", "Total"))
                    .foregroundStyle(.blue.opacity(0.3))
                    
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.correctAnswers)
                    )
                    .position(by: .value("Type", "Correct"))
                    .foregroundStyle(.green)
                }
            }
            .frame(height: 200)
            .padding(.horizontal, 20)
            .chartLegend(position: .top)
            .chartForegroundStyleScale([
                "Total": .blue.opacity(0.3),
                "Correct": .green
            ])
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var monthlyProgressChart: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Monthly Progress")
                .font(.headline)
                .padding(.horizontal)
            
            Chart {
                ForEach(viewModel.monthlyProgress) { progress in
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.questionsCompleted)
                    )
                    .position(by: .value("Type", "Total"))
                    .foregroundStyle(.blue.opacity(0.3))
                    
                    BarMark(
                        x: .value("Day", progress.week),
                        y: .value("Questions", progress.correctAnswers)
                    )
                    .position(by: .value("Type", "Correct"))
                    .foregroundStyle(.green)
                }
            }
            .frame(height: 200)
            .padding(.horizontal, 20)
            .chartLegend(position: .top)
            .chartForegroundStyleScale([
                "Total": .blue.opacity(0.3),
                "Correct": .green
            ])
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var yearlyProgressChart: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Yearly Progress")
                .font(.headline)
                .padding(.horizontal)
            
            Chart {
                ForEach(viewModel.yearlyProgress) { progress in
                    BarMark(
                        x: .value("Month", progress.week),
                        y: .value("Questions", progress.questionsCompleted)
                    )
                    .position(by: .value("Type", "Total"))
                    .foregroundStyle(.blue.opacity(0.3))
                    
                    BarMark(
                        x: .value("Month", progress.week),
                        y: .value("Questions", progress.correctAnswers)
                    )
                    .position(by: .value("Type", "Correct"))
                    .foregroundStyle(.green)
                }
            }
            .frame(height: 200)
            .padding(.horizontal, 20)
            .chartLegend(position: .top)
            .chartForegroundStyleScale([
                "Total": .blue.opacity(0.3),
                "Correct": .green
            ])
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    private var timePicker: some View {
        Picker("Time Range", selection: $selectedTimeRange) {
            ForEach(TimeRange.allCases, id: \.self) { range in
                Text(range.rawValue).tag(range)
            }
        }
        .pickerStyle(.segmented)
        .padding()
        .onChange(of: selectedTimeRange) { _ in
            let period: StatsPeriod = switch selectedTimeRange {
                case .week: .day
                case .month: .month
            }
            Task {
                await viewModel.loadStatsByPeriod(period)
            }
        }
    }
}

struct CalendarDay: Identifiable, Hashable {
    let id: Int
    let date: Date
    
    // Hashable êµ¬í˜„
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(date)
    }
    
    static func == (lhs: CalendarDay, rhs: CalendarDay) -> Bool {
        return lhs.id == rhs.id && lhs.date == rhs.date
    }
}

struct MonthCalendarView: View {
    @Environment(\.colorScheme) private var colorScheme
    let month: Date
    let monthlyData: [DailyProgress]
    private let calendar = Calendar.current
    private let daysInWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    
    var body: some View {
        VStack(spacing: 15) {
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 8), count: 7), spacing: 8) {
                // ìš”ì¼ í—¤ë”
                ForEach(daysInWeek, id: \.self) { day in
                    Text(day)
                        .font(.caption)
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity)
                }
                
                // ë¹ˆ ì…€ ì±„ìš°ê¸°
                ForEach(0..<firstWeekdayOfMonth, id: \.self) { _ in
                    Color.clear
                        .frame(height: 40)
                }
                
                // ë‚ ì§œ ê·¸ë¦¬ë“œ
                ForEach(calendarDays, id: \.id) { calendarDay in
                    if let progress = progressForDate(calendarDay.date),
                       progress.questionsCompleted > 0 {
                        DayCellView(date: calendarDay.date, progress: progress)
                    } else {
                        Text(String(calendar.component(.day, from: calendarDay.date)))
                            .font(.system(size: 16, weight: .medium))
                            .foregroundColor(colorScheme == .dark ? .white : .primary)
                            .frame(maxWidth: .infinity)
                            .frame(height: 40)
                            .background(
                                RoundedRectangle(cornerRadius: 8)
                                    .fill(colorScheme == .dark ? Color(.systemGray6) : Color(.systemGray6))
                            )
                    }
                }
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 12)
        .background(colorScheme == .dark ? Color(.systemGray5) : Color(.systemBackground))
        .cornerRadius(16)
    }

    // ì›”ì˜ ì²« ë²ˆì§¸ ë‚ ì˜ ìš”ì¼ (0 = ì¼ìš”ì¼, 6 = í† ìš”ì¼)
    private var firstWeekdayOfMonth: Int {
        guard let firstDay = calendar.date(from: calendar.dateComponents([.year, .month], from: month)) else {
            return 0
        }
        return calendar.component(.weekday, from: firstDay) - 1
    }
    
    private var calendarDays: [CalendarDay] {
        guard let range = calendar.range(of: .day, in: .month, for: month) else {
            return []
        }
        
        return (1...range.count).map { day -> CalendarDay in
            let components = calendar.dateComponents([.year, .month], from: month)
            var newComponents = DateComponents()
            newComponents.year = components.year
            newComponents.month = components.month
            newComponents.day = day
            let date = calendar.date(from: newComponents) ?? month
            return CalendarDay(id: day, date: date)
        }
    }
    
    private func progressForDate(_ date: Date) -> DailyProgress? {
        monthlyData.first { calendar.isDate($0.date, inSameDayAs: date) }
    }
    
    private var monthString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: month)
    }
    
    private var daysInMonth: [Date] {
        guard let monthInterval = calendar.dateInterval(of: .month, for: month),
              let monthFirstWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.start),
              let monthLastWeek = calendar.dateInterval(of: .weekOfMonth, for: monthInterval.end) else {
            return []
        }
        
        let dateInterval = DateInterval(start: monthFirstWeek.start, end: monthLastWeek.end)
        return calendar.generateDates(for: dateInterval, matching: DateComponents(hour: 0))
    }
}

struct StatsCircleContainer: View {
    let todayStats: DailyProgress?
    let weeklyStats: [DailyProgress]
    let monthlyProgress: [DailyProgress]  // ì¶”ê°€
    let selectedTimeRange: TimeRange      // ì¶”ê°€
    let currentMonthDate: Date           // ì¶”ê°€
    
    private var monthlyStats: (total: Int, correct: Int, incorrect: Int) {
        let calendar = Calendar.current
        let currentMonth = calendar.component(.month, from: currentMonthDate)
        let currentYear = calendar.component(.year, from: currentMonthDate)
        
        let thisMonthProgress = monthlyProgress.filter { progress in
            let progressMonth = calendar.component(.month, from: progress.date)
            let progressYear = calendar.component(.year, from: progress.date)
            return progressMonth == currentMonth && progressYear == currentYear
        }
        
        let total = thisMonthProgress.reduce(0) { $0 + $1.questionsCompleted }
        let correct = thisMonthProgress.reduce(0) { $0 + $1.correctAnswers }
        return (total, correct, total - correct)
    }
    
    var body: some View {
        HStack {
            CircleProgressView(
                progress: Double(todayStats?.correctAnswers ?? 0) / Double(max(1, todayStats?.questionsCompleted ?? 1)),
                title: "Today's Accuracy",
                total: todayStats?.questionsCompleted ?? 0,
                correct: todayStats?.correctAnswers ?? 0,
                incorrect: (todayStats?.questionsCompleted ?? 0) - (todayStats?.correctAnswers ?? 0)
            )
            
            Spacer(minLength: 30)
            
            if selectedTimeRange == .month {
                // ì›”ë³„ í†µê³„
                CircleProgressView(
                    progress: monthlyStats.total > 0 ? Double(monthlyStats.correct) / Double(monthlyStats.total) : 0,
                    title: "Monthly Accuracy",
                    total: monthlyStats.total,
                    correct: monthlyStats.correct,
                    incorrect: monthlyStats.incorrect
                )
            } else {
                // ì£¼ê°„ í†µê³„
                CircleProgressView(
                    progress: calculateWeeklyProgress(),
                    title: "Weekly Accuracy",
                    total: calculateWeeklyTotal(),
                    correct: calculateWeeklyCorrect(),
                    incorrect: calculateWeeklyIncorrect()
                )
            }
        }
        .padding(.top)
    }
    
    private func calculateWeeklyProgress() -> Double {
        let total = weeklyStats.reduce(0) { $0 + $1.questionsCompleted }
        let correct = weeklyStats.reduce(0) { $0 + $1.correctAnswers }
        return total > 0 ? Double(correct) / Double(total) : 0
    }
    
    private func calculateWeeklyTotal() -> Int {
        weeklyStats.reduce(0) { $0 + $1.questionsCompleted }
    }
    
    private func calculateWeeklyCorrect() -> Int {
        weeklyStats.reduce(0) { $0 + $1.correctAnswers }
    }
    
    private func calculateWeeklyIncorrect() -> Int {
        let total = calculateWeeklyTotal()
        let correct = calculateWeeklyCorrect()
        return total - correct
    }
}

struct CircleProgressView: View {
    let progress: Double
    let title: String
    let total: Int
    let correct: Int
    let incorrect: Int
    
    var body: some View {
        VStack {
            ZStack {
                Circle()
                    .stroke(lineWidth: 20)
                    .opacity(0.3)
                    .foregroundColor(.blue)
                
                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(style: StrokeStyle(lineWidth: 25, lineCap: .round))
                    .foregroundColor(.green)
                    .rotationEffect(.degrees(-90))
                    .animation(.linear, value: progress)
                
                VStack {
                    Text("\(Int(progress * 100))%")
                        .font(.headline)
                        .bold()
                    Text(title)
                        .font(.caption2)
                }
            }
            .frame(width: 150, height: 150)
            
            VStack(alignment: .leading, spacing: 8) {
                VStack {
                    Text("Correct: \(correct)")
                        .font(.subheadline)
                        .foregroundColor(.green)
                }
                
                VStack {
                    Text("Incorrect: \(incorrect)")
                        .font(.subheadline)
                        .foregroundColor(.red)
                }
                
                VStack {
                    Text("Total: \(total)")
                        .font(.subheadline)
                }
            }
            .padding(.top)
        }
        .padding()
    }
}

struct ActivityRow: View {
   let title: String
   let value: String
   let icon: String
   let color: Color
   
    var body: some View {
        HStack {
            Image(systemName: icon)
                .foregroundColor(color)
                .font(.title2)
                .frame(width: 30)
            
            VStack(alignment: .leading) {
                Text(title)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text(value)
                    .font(.headline)
            }
            
            Spacer()
        }
    }
}

struct DailyStatCard: View {
    let title: String
    let value: String
    let trend: String
    let trendUp: Bool
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            Text(value)
                .font(.title2)
                .bold()
            
            if !trend.isEmpty {
                HStack(spacing: 4) {
                    Image(systemName: trendUp ? "arrow.up.right" : "arrow.down.right")
                    Text(trend)
                }
                .font(.caption)
                .foregroundColor(trendUp ? .green : .red)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}
struct DayCellView: View {
    @Environment(\.colorScheme) private var colorScheme
    let date: Date
    let progress: DailyProgress
    
    private var activityColor: Color {
        let questionCount = progress.questionsCompleted
        guard questionCount > 0 else { return colorScheme == .dark ? Color(.systemGray6) : Color(.systemGray6) }
        return Color.green
    }
    
    private var textColor: Color {
        colorScheme == .dark ? .white : .primary
    }
    
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 8)
                .fill(activityColor)
                .frame(maxWidth: .infinity)
                .frame(height: 40)
            
            VStack(spacing: 2) {
                Text("\(Calendar.current.component(.day, from: date))")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.white)
                Text("\(progress.questionsCompleted)")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.white)
            }
        }
    }
}

extension Calendar {
    func generateDates(
        for dateInterval: DateInterval,
        matching components: DateComponents
    ) -> [Date] {
        var dates: [Date] = []
        dates.reserveCapacity(40)

        var date = dateInterval.start
        repeat {
            dates.append(date)
            guard let nextDate = self.nextDate(after: date, matching: components, matchingPolicy: .nextTime) else {
                break
            }
            date = nextDate
        } while date <= dateInterval.end

        return dates
    }
}


// ./AISnapStudy/Views/Stats/StreakBadgeView.swift

import SwiftUI

struct StreakBadgeView: View {
    let streakInfo: StreakInfo
    
    private var streakMessage: String {
        switch streakInfo.currentStreak {
        case 2: return "2 Days! Keep going! ğŸ¯"
        case 3: return "3 Days! You're on fire! ğŸ”¥"
        case 4: return "4 Days! Fantastic! â­ï¸"
        case 5: return "5 Days! Incredible! ğŸŒŸ"
        case 6: return "6 Days! Amazing! ğŸ†"
        case 7...: return "7+ Days! Legendary! ğŸ‘‘"
        default: return "Start your streak today! ğŸ’«"
        }
    }
    
    var body: some View {
        VStack(spacing: 12) {
            Text("\(streakInfo.currentStreak)")
                .font(.system(size: 48, weight: .bold))
                .foregroundColor(.orange)
            
            Text("Day Streak")
                .font(.headline)
                .foregroundColor(.secondary)
            
            Text(streakMessage)
                .font(.subheadline)
                .multilineTextAlignment(.center)
                .foregroundColor(.primary)
            
            if streakInfo.longestStreak > streakInfo.currentStreak {
                Text("Longest streak: \(streakInfo.longestStreak) days")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 15)
                .fill(Color(.systemBackground))
                .shadow(radius: 2)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 15)
                .stroke(Color.orange.opacity(0.3), lineWidth: 2)
        )
    }
}


// ./AISnapStudy/Views/Stats/DetailedStatsView.swift

import SwiftUI
import Charts

struct DetailedStatsView: View {
    @StateObject private var viewModel = DetailedStatsViewModel()
    @State private var selectedMonth = Date()
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Streak Badge Section
                StreakBadgeView(streakInfo: viewModel.streakInfo)
                    .padding()
                
                // Calendar View
                CalendarStatsView(monthlyData: viewModel.monthlyData)
                .padding()
                
                // Stats Summary
                StatsSummaryView(dailyStats: viewModel.dailyStats)
                    .padding()
                
                // Progress Chart
                ProgressChartView(dailyStats: viewModel.dailyStats)
                    .frame(height: 250)
                    .padding()
            }
        }
        .navigationTitle("Detailed Stats")
    }
}

struct StatsSummaryView: View {
    let dailyStats: [DailyStats]
    
    private var totalQuestions: Int {
        dailyStats.reduce(0) { $0 + $1.totalQuestions }
    }
    
    private var totalCorrect: Int {
        dailyStats.reduce(0) { $0 + $1.correctAnswers }
    }
    
    private var averageAccuracy: Double {
        guard totalQuestions > 0 else { return 0 }
        return Double(totalCorrect) / Double(totalQuestions) * 100
    }
    
    var body: some View {
        VStack(spacing: 16) {
            Text("Summary")
                .font(.headline)
            
            HStack(spacing: 20) {
                StatCard(
                    title: "Total",
                    value: "\(totalQuestions)",
                    icon: "list.bullet",
                    color: .blue
                )
                
                StatCard(
                    title: "Correct",
                    value: "\(totalCorrect)",
                    icon: "checkmark",
                    color: .green
                )
                
                StatCard(
                    title: "Accuracy",
                    value: String(format: "%.1f%%", averageAccuracy),
                    icon: "percent",
                    color: .orange
                )
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

struct ProgressChartView: View {
    let dailyStats: [DailyStats]
    
    var body: some View {
        Chart {
            ForEach(dailyStats) { stats in
                BarMark(
                    x: .value("Date", stats.date),
                    y: .value("Questions", stats.totalQuestions)
                )
                .foregroundStyle(by: .value("Type", "Total"))
                
                BarMark(
                    x: .value("Date", stats.date),
                    y: .value("Questions", stats.correctAnswers)
                )
                .foregroundStyle(by: .value("Type", "Correct"))
            }
        }
        .chartForegroundStyleScale([
            "Total": Color.blue.opacity(0.3),
            "Correct": Color.green
        ])
        .chartLegend(position: .top)
    }
}


// ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 512 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.8
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // ì´ë¯¸ì§€ì˜ í¬ê¸°ë¥¼ ìµœëŒ€ ì¹˜ìˆ˜ì— ë§ê²Œ ì¡°ì •
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // ì„¤ì •ëœ í’ˆì§ˆë¡œ ì••ì¶•
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // í¬ê¸°ê°€ ìµœëŒ€ íŒŒì¼ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš°, í’ˆì§ˆì„ ë‚®ì¶°ì„œ ì¶”ê°€ ì••ì¶• ì‹œë„
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera),
                  UIImagePickerController.isCameraDeviceAvailable(.rear) else {
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetailì˜ ì„¤ì • ê°’ì„ ì‚¬ìš©
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // ì˜ˆì¸¡ í† í° ìˆ˜ ê³„ì‚°
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        ğŸ“Š Image Optimization Results:
        â€¢ Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        â€¢ Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        â€¢ Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        â€¢ Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        â€¢ Estimated Tokens: \(estimatedTokens)
        â€¢ Processing Time: \(String(format: "%.3f", processingTime))s
        â€¢ Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}



// ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
    case fileProviderAccessDenied
    case fileCoordinationFailed
}

public class StorageService {
    // MARK: - Properties
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let fileCoordinator = NSFileCoordinator()
    private let fileManager = FileManager.default
    
    // MARK: - Constants
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    private let maxRetryCount = 3
    private let retryDelay: TimeInterval = 0.5
    
    // MARK: - File System
    private var documentDirectory: URL? {
        fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
    }
    
    private func getDirectoryURL(for type: String) -> URL? {
        documentDirectory?.appendingPathComponent(type)
    }
    
    // MARK: - FileProvider Handling
    private func handleFileProviderAccess<T>(_ operation: @escaping (URL) throws -> T) throws -> T {
        guard checkFileProviderAuthorization() else {
            throw StorageError.fileProviderAccessDenied
        }
        
        guard let url = documentDirectory else {
            throw StorageError.invalidData
        }
        
        var coordinationError: NSError?
        var result: T?
        var operationError: Error?
        
        fileCoordinator.coordinate(writingItemAt: url, options: .forMoving, error: &coordinationError) { coordinatedURL in
            do {
                result = try operation(coordinatedURL)
            } catch {
                operationError = error
            }
        }
        
        if let error = coordinationError {
            throw StorageError.fileCoordinationFailed
        }
        
        if let error = operationError {
            throw error
        }
        
        return result!
    }
    
    private func checkFileProviderAuthorization() -> Bool {
        // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì ì ˆí•œ ê¶Œí•œ ì²´í¬ ë¡œì§ êµ¬í˜„
        return true
    }
    
    // MARK: - Error Handling
    private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
        do {
            return try operation()
        } catch let error as NSError {
            Logger.logError(error, category: "FileOperation")
            
            // ì¬ì‹œë„ ë¡œì§
            for attempt in 1...maxRetryCount {
                Logger.log("Retrying operation (attempt \(attempt)/\(maxRetryCount))", category: "FileOperation")
                do {
                    return try operation()
                } catch {
                    if attempt == maxRetryCount {
                        throw error
                    }
                    Thread.sleep(forTimeInterval: retryDelay)
                }
            }
            throw error
        }
    }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var problemSets = try self.getProblemSets()
                problemSets.append(problemSet)
                
                let data = try self.encoder.encode(problemSets)
                self.defaults.set(data, forKey: self.problemSetsKey)
            }
        }
    }
    
    public func getProblemSets() throws -> [ProblemSet] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: problemSetsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([ProblemSet].self, from: data)
            } catch {
                Logger.logError(error, category: "ProblemSets")
                throw StorageError.loadFailed
            }
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                sessions.append(session)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: studySessionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([StudySession].self, from: data)
            } catch {
                Logger.logError(error, category: "StudySessions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.deleteFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                
                guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
                    throw StorageError.notFound
                }
                
                sessions.remove(at: index)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func saveQuestion(_ question: Question) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var savedQuestions = try self.getSavedQuestions()
                savedQuestions.append(question)
                
                let data = try self.encoder.encode(savedQuestions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: savedQuestionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([Question].self, from: data)
            } catch {
                Logger.logError(error, category: "SavedQuestions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func saveQuestions(_ questions: [Question]) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                let data = try self.encoder.encode(questions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("ğŸ“ [\(category)] \(message)")
        #endif
    }
    
    static func logError(_ error: Error, category: String) {
        #if DEBUG
        print("âŒ [\(category)] Error: \(error.localizedDescription)")
        #endif
    }
}


// ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    // private ì €ì¥ í”„ë¡œí¼í‹° ìˆ˜ì •
    private var apiKey: String?
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    private let keyServerURL = "https://aistockadvisor.net/api/get-api-key"
    
    // ì‹±ê¸€í†¤ ìˆ˜ì •
    static let shared = OpenAIService()
    
    // ë‹¨ì¼ ì´ˆê¸°í™” ë©”ì„œë“œ
    private init() {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
        
        // ì´ˆê¸°í™” ì‹œì ì— API Key ê°€ì ¸ì˜¤ê¸°
        Task {
            try? await fetchAPIKey()
        }
    }
    
    private func makeOpenAIRequest(_ request: inout URLRequest) throws {
        guard let apiKey = self.apiKey else {
            print("âŒ API key is nil")
            throw NetworkError.apiError("API key not available")
        }
        
        
        // String ë¦¬í„°ëŸ´ë¡œ í—¤ë” ìƒì„±
        let authHeaderValue = "Bearer " + apiKey
        request.setValue(authHeaderValue, forHTTPHeaderField: "Authorization")
    
    }

    
    // fetchAPIKey í•¨ìˆ˜ ìˆ˜ì •
    func fetchAPIKey() async throws {
        let request = URLRequest(url: URL(string: keyServerURL)!)
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw NetworkError.invalidResponse
        }
        
        let decoder = JSONDecoder()
        let keyResponse = try decoder.decode(APIKeyResponse.self, from: data)
        
        // API í‚¤ ì €ì¥ ì „ í™•ì¸
        print("Debug - Received API Key (first 10 chars):", keyResponse.apiKey.prefix(10))
        
        // API í‚¤ ì €ì¥
        self.apiKey = keyResponse.apiKey
    }
    
    // API Keyê°€ ì—†ì„ ê²½ìš° ê°€ì ¸ì˜¤ëŠ” ë©”ì„œë“œ
    private func ensureValidAPIKey() async throws {
        if apiKey == nil {
            try await fetchAPIKey()
        }
    }
    
    func cleanup() {
           apiKey = nil
       }
    
    func sendTextExtractionResult(_ extractedText: String) async throws -> String {
        // API Key í™•ì¸
        try await ensureValidAPIKey()
        
        print("ğŸ”„ Processing extracted text in OpenAI service...")
        print("ğŸ“ Input text: \(extractedText)")
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        
        try makeOpenAIRequest(&request)  // API Key ì„¤ì •

        let body: [String: Any] = [
            "model": "gpt-4o",
            "messages": [
                ["role": "system", "content": "You are an expert at analyzing extracted text."],
                ["role": "user", "content": extractedText]
            ],
            "temperature": 0.7,
            "max_tokens": 2000
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        print("ğŸŒ Sending request to OpenAI API...")
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("âŒ Invalid response received")
            throw NetworkError.invalidResponse
        }
        
        print("ğŸ“¡ Response status code: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            print("âŒ API request failed with status code: \(httpResponse.statusCode)")
            throw NetworkError.apiError("API request failed with status \(httpResponse.statusCode)")
        }

        let result = String(data: data, encoding: .utf8) ?? "No response"
        print("âœ… OpenAI processing completed: \(result)")
        return result
    }


        func sendImageDataToOpenAI(_ imageData: Data) async throws {
            // API Key í™•ì¸
            try await ensureValidAPIKey()
            
            let url = URL(string: "https://api.openai.com/v1/images")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("Bearer \(apiKey ?? "")", forHTTPHeaderField: "Authorization")

            let body: [String: Any] = [
                "image": imageData.base64EncodedString(),
                "purpose": "image-analysis"
            ]

            request.httpBody = try JSONSerialization.data(withJSONObject: body, options: [])

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw NSError(domain: "OpenAIService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to get valid response from OpenAI API"])
            }

            let result = String(data: data, encoding: .utf8) ?? "No response"
            print("âœ… Image sent to OpenAI. Response: \(result)")
        }
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public ìœ¼ë¡œ ë³€ê²½
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init ì¶”ê°€
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public ìœ¼ë¡œ ë³€ê²½
        let subject: DefaultSubject  // Subject -> DefaultSubjectë¡œ ë³€ê²½
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        let language: Language
        
        public init(    // public init ì¶”ê°€
            subject: DefaultSubject,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int],
            language: Language
        ) {
            self.subject = subject
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
            self.language = language
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("âŒ Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("ğŸ“¸ Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("âŒ Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }

    // extractCompleteQuestion í•¨ìˆ˜ë„ ì¶”ê°€
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSONì´ ì™„ì „í•œ ê°ì²´ì¸ì§€ í™•ì¸
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSONì´ ì•„ì§ ì™„ì„±ë˜ì§€ ì•Šì•˜ê±°ë‚˜ íŒŒì‹±í•  ìˆ˜ ì—†ëŠ” ê²½ìš°
            return nil
        }
    }
    
    // ë‚˜ë¨¸ì§€ private êµ¬ì¡°ì²´ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        // ë„¤íŠ¸ì›Œí¬ ì—°ê²° í™•ì¸
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        // ìºì‹œ í™•ì¸
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("âœ… Retrieved questions from cache")
            return cachedQuestions
        }
        
        // API í‚¤ í™•ì¸ ë° ë¡œê¹…
        guard let apiKey = self.apiKey else {
            print("âŒ API key is nil")
            throw NetworkError.apiError("API key not available")
        }
        print("Debug - API Key type:", type(of: apiKey))
        print("Debug - API Key length:", apiKey.count)
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // ì´ë¯¸ì§€ ë˜ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ëŠ” íƒœìŠ¤í¬ ì¶”ê°€
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            // API í‚¤ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì „ë‹¬
            let questions = try await self.performQuestionGeneration(
                input: processedInput,
                textInput: processedTextInput,
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters,
                apiKey: apiKey  // API í‚¤ ì „ë‹¬
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(
        _ subject: SubjectType,
        isImageInput: Bool,
        isExtractedText: Bool,  // ìƒˆë¡œìš´ ë§¤ê°œë³€ìˆ˜ ì¶”ê°€
        educationLevel: EducationLevel,
        language: Language
    ) -> SubjectPrompt {
        let subjectName = if let customSubject = subject as? CustomSubject {  // ìˆ˜ì •ëœ ë¶€ë¶„
            customSubject.displayName
        } else {
            subject.displayName
        }
        
        let languageInstructionText = language == .auto ?
            "Generate questions in the exact same language as the input text." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.codeName).
            DO NOT use the input text's language. Even if the input is in another language, the output must be in \(language.codeName) only.
            """
        
        let languageInstructionImage = language == .auto ?
            "Generate questions in the same language as any visible text in the image." :
            """
            IMPORTANT: All generated questions, answers, explanations, and hints must be in \(language.codeName).
            DO NOT use the language of visible text in the image. All output must be in \(language.codeName) only.
            """

        // ìˆœìˆ˜ ì´ë¯¸ì§€ ê¸°ë°˜ ì…ë ¥
        if isImageInput && !isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained, image-based questions.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as visible text in the image" : language.codeName)
                    - Ensure consistent language usage throughout all content.
                    - Translate concepts accurately without losing meaning.
                    
                    FORMATTING REQUIREMENTS:
                    - Each question must be self-contained with all necessary context provided.
                    - Avoid ambiguous or overly broad questions.
                    - True/False answers must be "true" or "false" (lowercase).

                    ERROR PREVENTION:
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Create high-quality, context-rich questions based on the given image.
                    \(languageInstructionImage)
                    Each question must include detailed explanations and hints.

                    Examples of good questions:
                    - "If the sum of the angles in a triangle is 180Â°, and one angle is 90Â°, what are the other two angles?"
                    - "The Roman Empire declined for many reasons. Which of the following factors contributed the most to its fall?"
                    
                    Examples of bad questions:
                    - "What does the text explain?"
                    - "Is this image interesting?"
                    """
            )
        }
        // ì´ë¯¸ì§€ì—ì„œ ì¶”ì¶œëœ í…ìŠ¤íŠ¸ ê¸°ë°˜ ì…ë ¥
        else if isImageInput && isExtractedText {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating self-contained questions based on extracted text from images.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as the extracted text" : language.codeName)
                    - Maintain consistent language usage across all questions, answers, and explanations.
                    - Preserve technical terms and proper nouns during translation.

                    FORMATTING REQUIREMENTS:
                    - Create questions with all necessary context included.
                    - True/False answers must be "true" or "false" (lowercase).
                    - Avoid "wh-" questions like "what", "who", or "how".

                    ERROR PREVENTION:
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Generate accurate and context-aware questions from the extracted text in the image.
                    \(languageInstructionImage)
                    Include hints and explanations for each question.

                    Examples of good questions:
                    - "The fall of the Roman Empire is often attributed to external invasions. Which of the following best explains this?"
                    - "In the Pythagorean theorem, if aÂ² + bÂ² = cÂ², what does 'c' represent in a right triangle?"

                    Examples of bad questions:
                    - "What does this text mean?"
                    - "Explain the context."
                    """
            )
        }
        // í…ìŠ¤íŠ¸ ê¸°ë°˜ ì…ë ¥
        else {
            return SubjectPrompt(
                systemPrompt: """
                    You are an expert in creating questions for \(educationLevel.displayName) students.
                    
                    STRICT LANGUAGE REQUIREMENTS:
                    - Output language: \(language == .auto ? "same as input text" : language.codeName)
                    - Maintain consistent language usage across all questions, answers, and explanations.
                    - Preserve technical terms and proper nouns during translation.
                    
                    FORMATTING REQUIREMENTS:
                    - Include all necessary context within the questions.
                    - Avoid overly broad or simplistic questions.
                    - True/False answers must be "true" or "false" (lowercase).

                    ERROR PREVENTION:
                    - Check the consistency of technical terms and proper nouns.
                    """,
                userPromptTemplate: """
                    Create thoughtful and context-rich questions based on the input text.
                    \(languageInstructionText)
                    Create National Assessment of Educational Progress questions for \(educationLevel.displayName) school students
                    Include hints and detailed explanations.

                    Examples of good questions:
                    - "The Renaissance was a cultural movement in Europe. Which of the following innovations was NOT developed during this period?"
                    - "If a car travels 60 miles in one hour, how far will it travel in three hours at the same speed?"

                    Examples of bad questions:
                    - "What is the capital of France?"
                    - "Explain this text."
                    """
            )
        }
    }

    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            isExtractedText: !input.isImage && input.content.count > 0,  // í…ìŠ¤íŠ¸ ì¶”ì¶œ ì—¬ë¶€ í™•ì¸
            educationLevel: parameters.educationLevel,
            language: parameters.language
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": [
                                "type": "array",
                                "items": [
                                    "type": "string"
                                ],
                                "description": "For true_false type, must be exactly ['true', 'false']"
                            ],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint"]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters,
        apiKey: String  // API í‚¤ ë§¤ê°œë³€ìˆ˜ ì¶”ê°€
    ) async throws -> [Question] {
        print("ğŸ¤– OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages ë°°ì—´ì„ ë¯¸ë¦¬ ì„ ì–¸
        var messages: [[String: Any]]

        // êµ¬ì¡°í™”ëœ ë©”ì‹œì§€ ìƒì„±
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI ê³µì‹ ë©€í‹°ëª¨ë‹¬ í¬ë§· ì‚¬ìš©
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        
        // API í‚¤ë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ì—¬ Authorization í—¤ë” ì„¤ì •
        let authHeaderValue = "Bearer " + apiKey
        request.setValue(authHeaderValue, forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        // Debug: í—¤ë” í™•ì¸
        print("Debug - Final Authorization header:", String(authHeaderValue.prefix(20)), "...")
        
        print("""
        ğŸŒ API Request:
        â€¢ URL: \(baseURL)
        â€¢ Method: POST
        â€¢ Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            ğŸŒ API Response:
            â€¢ Status Code: \(httpResponse.statusCode)
            â€¢ Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            // True/False ì§ˆë¬¸ì—ì„œ ì ‘ë‘ì‚¬ ì œê±°
            let processedQuestion = questionData.type == "true_false" ?
                questionData.question
                    .replacingOccurrences(
                        of: "^(True or False:|True/False:|T/F:|\\(True/False\\)|\\[True/False\\]|True or False\\?|Is it true or false:|True False:)\\s*",
                        with: "",
                        options: [.regularExpression, .caseInsensitive]
                    )
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines) :
                questionData.question
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .replacingOccurrences(of: "\n+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines)

            // True/False ë‹µë³€ ì •ê·œí™”
            var correctAnswer = questionData.correctAnswer
            if questionData.type == "true_false" {
                correctAnswer = correctAnswer.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
                if ["yes", "ë„¤", "true", "correct", "that's right", "ë§ìŠµë‹ˆë‹¤", "ë„¤, ê·¸ë ‡ìŠµë‹ˆë‹¤", "ì‚¬ì‹¤ì…ë‹ˆë‹¤"].contains(correctAnswer) {
                    correctAnswer = "true"
                } else if ["no", "ì•„ë‹ˆì˜¤", "false", "incorrect", "that's wrong", "ì•„ë‹™ë‹ˆë‹¤", "ì•„ë‹ˆìš”", "ì‚¬ì‹¤ì´ ì•„ë‹ˆë‹¤", "ì‚¬ì‹¤ì´ ì•„ë‹™ë‹ˆë‹¤"].contains(correctAnswer) {
                    correctAnswer = "false"
                }
            }

            return Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                question: processedQuestion,
                options: questionData.options,
                correctAnswer: correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        âœ… Questions Generated:
        â€¢ Count: \(questions.count)
        â€¢ Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


struct APIKeyResponse: Codable {
    let apiKey: String
    
    // CodingKeys ì¶”ê°€
    enum CodingKeys: String, CodingKey {
        case apiKey = "apiKey"
    }
}



// ./AISnapStudy/Services/VisionService.swift

// Services/VisionService.swift

import Vision
import UIKit

// Vision ê´€ë ¨ ì—ëŸ¬ íƒ€ì… ì •ì˜
enum VisionError: Error {
    case invalidImage
    case processingFailed
    case noTextFound
    case unknown(Error)
}

class VisionService {
    static let shared = VisionService()
    
    private init() {}
    
    func extractText(from image: UIImage) async throws -> String {
        print("ğŸ” Starting universal text extraction...")
        
        guard let cgImage = image.cgImage else {
            print("âŒ Failed to get CGImage from UIImage")
            throw VisionError.invalidImage
        }

        let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        let request = VNRecognizeTextRequest()
        
        // Universal text recognition settings
        request.recognitionLevel = .accurate
        request.usesLanguageCorrection = true
        request.automaticallyDetectsLanguage = true // Enable automatic language detection
        
        print("ğŸ“ Configured for universal text recognition")
        
        do {
            try requestHandler.perform([request])
            
            let observations = request.results ?? []
            print("ğŸ“Š Found \(observations.count) text observations")
            
            var textBlocks: [(text: String, location: CGRect)] = []
            
            for observation in observations {
                if let candidate = observation.topCandidates(1).first {
                    let text = candidate.string
                    let confidence = candidate.confidence
                    
                    if confidence > 0.2 {
                        textBlocks.append((text, observation.boundingBox))
                    }
                }
            }
            
            let finalText = processTextBlocks(textBlocks)
            
            guard !finalText.isEmpty else {
                print("âš ï¸ No valid text extracted")
                throw VisionError.noTextFound
            }
            
            print("âœ… Successfully extracted text")
            return finalText
            
        } catch {
            print("âŒ Text extraction failed: \(error.localizedDescription)")
            throw VisionError.processingFailed
        }
    }
    
    private func processTextBlocks(_ blocks: [(text: String, location: CGRect)]) -> String {
        // Sort blocks by their position on the page
        let sortedBlocks = blocks.sorted { (block1, block2) -> Bool in
            // Different lines (threshold for line height difference)
            if abs(block1.location.minY - block2.location.minY) > 0.05 {
                return block1.location.minY > block2.location.minY
            }
            // Same line - left to right
            return block1.location.minX < block2.location.minX
        }
        
        // Process and join text blocks
        let processedText = sortedBlocks
            .map { block in
                var text = block.text
                    .replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                
                // Fix common punctuation issues
                text = text.replacingOccurrences(of: "\\s*([.,!?])\\s*", with: "$1 ", options: .regularExpression)
                text = text.replacingOccurrences(of: "([.,!?])\\1+", with: "$1", options: .regularExpression)
                
                return text
            }
            .joined(separator: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        
        return processedText
    }
}


// ./AISnapStudy/Services/RemoteQuestionService.swift

import Foundation
import Combine
import SwiftUI

class RemoteQuestionService {
    static let shared = RemoteQuestionService()
    private let baseURL = "https://aistockadvisor.net"
    private let cache = NSCache<NSString, NSArray>()
    
    func fetchFeaturedSets() async throws -> [RemoteQuestionSet] {
        let url = URL(string: "\(baseURL)/featured-sets")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode([RemoteQuestionSet].self, from: data)
    }
    
    func fetchQuestionSet(_ id: String) async throws -> ProblemSet {
        print("ğŸŒ Downloading question set with ID: \(id)")
        let url = URL(string: "\(baseURL)/api/question-sets/\(id)")!
        
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ“¡ Response status: \(httpResponse.statusCode)")
        
        struct RemoteSet: Codable {
            let id: String
            let subject: String
            let subjectType: String
            let subjectId: String
            let subjectName: String
            let questions: [RemoteQuestion]
            let createdAt: String
            let educationLevel: String
            let name: String
            
            struct RemoteQuestion: Codable {
                let id: String
                let type: String
                let question: String
                let options: [String]
                let correctAnswer: String
                let explanation: String
                let hint: String
            }
        }
        
        let decoder = JSONDecoder()
        let remoteSet = try decoder.decode(RemoteSet.self, from: data)
        
        // Question ëª¨ë¸ë¡œ ë³€í™˜
        let questions = remoteSet.questions.map { q -> Question in
            let questionType: QuestionType = {
                switch q.type.lowercased() {
                    case "multiple_choice":
                        return .multipleChoice
                    case "true_false":
                        return .trueFalse
                    default:
                        return .multipleChoice  // ê¸°ë³¸ê°’
                }
            }()
            
            return Question(
                id: q.id,
                type: questionType,
                subject: DefaultSubject.download,  // DefaultSubject íƒ€ì…ìœ¼ë¡œ ë³€ê²½
                question: q.question,
                options: q.options,
                correctAnswer: q.correctAnswer,
                explanation: q.explanation,
                hint: q.hint,
                isSaved: false,
                createdAt: Date()
            )
        }
        
        // ProblemSetìœ¼ë¡œ ë³€í™˜
        return ProblemSet(
            id: UUID().uuidString,
            subject: DefaultSubject.download,
            subjectType: "default",
            subjectId: DefaultSubject.download.rawValue,
            subjectName: "Downloaded Sets",
            questions: questions,
            createdAt: ISO8601DateFormatter().date(from: remoteSet.createdAt) ?? Date(),
            educationLevel: EducationLevel(rawValue: remoteSet.educationLevel) ?? .elementary,
            name: remoteSet.name
        )
    }
    
    func searchQuestionSets(query: String) async throws -> [RemoteQuestionSet] {
        let url = URL(string: "\(baseURL)/search?q=\(query)")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode([RemoteQuestionSet].self, from: data)
    }
    
    func fetchQuestionSets() async throws -> [RemoteQuestionSet] {
        print("ğŸŒ Fetching remote question sets...")
        let url = URL(string: "\(baseURL)/api/question-sets")!
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw URLError(.badServerResponse)
        }
        
        print("ğŸ“¡ Response status: \(httpResponse.statusCode)")
        
        // ë°›ì€ JSON ë°ì´í„° ì¶œë ¥
        if let jsonString = String(data: data, encoding: .utf8) {
            print("ğŸ“¥ Received JSON data: \(jsonString)")
        }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601  // ISO8601 í˜•ì‹ì˜ ë‚ ì§œ ì²˜ë¦¬
        
        do {
            let sets = try decoder.decode([RemoteQuestionSet].self, from: data)
            print("âœ… Fetched \(sets.count) remote sets")
            return sets
        } catch {
            print("ğŸ”´ Decoding error: \(error)")
            throw error
        }
    }

}

// MARK: - ViewModels
class QuestionStoreViewModel: ObservableObject {
    @Published var featuredSets: [RemoteQuestionSet] = []
    @Published var popularSets: [RemoteQuestionSet] = []
    @Published var recentSets: [RemoteQuestionSet] = []
    @Published var isLoading = false
    @Published var error: Error?
    @Published var searchResults: [RemoteQuestionSet] = []
    @Published var searchQuery = ""
    
    private let remoteService = RemoteQuestionService.shared
    private let homeViewModel: HomeViewModel
    
    init(homeViewModel: HomeViewModel) {
        self.homeViewModel = homeViewModel
    }
    
    @MainActor
    func loadFeaturedSets() async {
        isLoading = true
        do {
            featuredSets = try await remoteService.fetchFeaturedSets()
        } catch {
            self.error = error
        }
        isLoading = false
    }
    
    @MainActor
    func downloadQuestionSet(_ set: RemoteQuestionSet) async {
        isLoading = true
        do {
            let problemSet = try await remoteService.fetchQuestionSet(set.id)
            // Convert to Download subject
            let downloadedSet = ProblemSet(
                subject: DefaultSubject.download,  // New Download subject
                subjectType: "default",
                subjectId: DefaultSubject.download.rawValue,
                subjectName: "Download",
                questions: problemSet.questions,
                createdAt: Date(),
                educationLevel: .high,  // Or determine from set.difficulty
                name: set.title
            )
            await homeViewModel.saveProblemSet(downloadedSet)
        } catch {
            self.error = error
        }
        isLoading = false
    }
}

// MARK: - Views
struct QuestionStoreView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var selectedCategory: String?
    @State private var showingSearch = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                if homeViewModel.isLoadingRemote {
                    ProgressView("Loading question sets...")
                } else {
                    ForEach(homeViewModel.remoteSets) { remoteSet in
                        QuestionSetCard(
                            set: remoteSet,
                            onDownload: {
                                Task {
                                    await homeViewModel.downloadQuestionSet(remoteSet)
                                }
                            }
                        )
                    }
                }
            }
            .padding()
        }
        .navigationTitle("Question Store")
    }
}

struct QuestionSetCard: View {
   let set: RemoteQuestionSet
   let onDownload: () -> Void
   @Environment(\.colorScheme) private var colorScheme
   
   var body: some View {
       VStack(alignment: .leading, spacing: 16) {
           // ìƒë‹¨ ì˜ì—­
           HStack(alignment: .top) {
               // ì•„ì´ì½˜
               Image(systemName: "book.fill")
                   .font(.system(size: 24))
                   .foregroundColor(.blue)
                   .frame(width: 40, height: 40)
                   .background(Color.blue.opacity(0.1))
                   .clipShape(Circle())
               
               VStack(alignment: .leading, spacing: 4) {
                   Text(set.title)
                       .font(.system(size: 18, weight: .semibold))
                       .foregroundColor(.primary)
                   
                   Text(set.description)
                       .font(.subheadline)
                       .foregroundColor(.secondary)
                       .lineLimit(2)
               }
           }
           
           Divider()
           
           // í•˜ë‹¨ ì •ë³´ ì˜ì—­
           HStack(spacing: 16) {
               // ë¬¸ì œ ìˆ˜
               HStack(spacing: 6) {
                   Image(systemName: "doc.text.fill")
                       .foregroundColor(.blue)
                   Text("\(set.questionCount) Questions")
                       .font(.system(size: 14, weight: .medium))
               }
               .foregroundColor(.secondary)
               
               // ë‚œì´ë„
               HStack(spacing: 6) {
                   Image(systemName: "chart.bar.fill")
                       .foregroundColor(.green)
                   Text(set.difficulty)
                       .font(.system(size: 14, weight: .medium))
               }
               .foregroundColor(.secondary)
               
               Spacer()
               
               // ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
               Button(action: onDownload) {
                   HStack(spacing: 6) {
                       Image(systemName: "arrow.down.circle.fill")
                       Text("Download")
                   }
                   .font(.system(size: 14, weight: .medium))
                   .foregroundColor(.white)
                   .padding(.horizontal, 16)
                   .padding(.vertical, 8)
                   .background(Color.blue)
                   .cornerRadius(20)
               }
           }
       }
       .padding(16)
       .background(colorScheme == .dark ? Color(.systemGray6) : Color.white)
       .cornerRadius(16)
       .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 4)
       .overlay(
           RoundedRectangle(cornerRadius: 16)
               .stroke(Color.gray.opacity(0.1), lineWidth: 1)
       )
       .padding(.horizontal)
   }
}

// Featured Section with carousel
struct FeaturedSection: View {
    let sets: [RemoteQuestionSet]
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Featured")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.horizontal)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 15) {
                    ForEach(sets) { set in
                        FeaturedCard(set: set, onDownload: onDownload)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
}

// Featured Card
struct FeaturedCard: View {
    let set: RemoteQuestionSet
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        VStack(alignment: .leading) {
            
            // Content
            VStack(alignment: .leading, spacing: 8) {
                Text(set.title)
                    .font(.headline)
                
                Text(set.description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .lineLimit(2)
                
                HStack {
                    Label("\(set.questionCount) questions", systemImage: "doc.text")
                    Spacer()
                    Button(action: { onDownload(set) }) {
                        Image(systemName: "arrow.down.circle.fill")
                            .imageScale(.large)
                    }
                }
                .font(.caption)
            }
            .padding()
        }
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 5)
        .frame(width: 280)
    }
}

// Category Section
struct CategorySection: View {
    let categories = ["Math", "Science", "Language", "History", "Geography", "General"]
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Categories")
                .font(.title2)
                .fontWeight(.bold)
                .padding(.horizontal)
            
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 15) {
                ForEach(categories, id: \.self) { category in
                    CategoryCard(category: category)
                }
            }
        }
    }
}

// Category Card
struct CategoryCard: View {
    let category: String
    
    var body: some View {
        VStack {
            Image(systemName: iconName(for: category))
                .font(.title)
                .foregroundColor(.blue)
            Text(category)
                .font(.caption)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(10)
    }
    
    private func iconName(for category: String) -> String {
        switch category.lowercased() {
        case "math": return "function"
        case "science": return "flask.fill"
        case "language": return "textformat"
        case "history": return "clock.fill"
        case "geography": return "globe"
        default: return "book.fill"
        }
    }
}

// Question Set Section
struct QuestionSetSection: View {
    let title: String
    let sets: [RemoteQuestionSet]
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        VStack(alignment: .leading) {
            Text(title)
                .font(.title2)
                .fontWeight(.bold)
                .padding(.horizontal)
            
            ForEach(sets) { set in
                QuestionSetRow(set: set, onDownload: onDownload)
            }
        }
    }
}

// Question Set Row
struct QuestionSetRow: View {
    let set: RemoteQuestionSet
    let onDownload: (RemoteQuestionSet) -> Void
    
    var body: some View {
        HStack {
            
            VStack(alignment: .leading) {
                Text(set.title)
                    .font(.headline)
                Text("\(set.questionCount) questions")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
            
            Button(action: { onDownload(set) }) {
                Image(systemName: set.isDownloaded ? "checkmark.circle.fill" : "arrow.down.circle")
                    .imageScale(.large)
                    .foregroundColor(set.isDownloaded ? .green : .blue)
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

extension RemoteQuestionService {
    private func handleNetworkError(_ error: Error) {
        if let urlError = error as? URLError {
            switch urlError.code {
            case .notConnectedToInternet:
                print("âŒ No internet connection")
            case .timedOut:
                print("âŒ Request timed out")
            case .cannotFindHost:
                print("âŒ Cannot find host: \(urlError.failingURL?.host ?? "unknown")")
            default:
                print("âŒ Network error: \(urlError.localizedDescription)")
            }
        } else {
            print("âŒ Unknown error: \(error.localizedDescription)")
        }
    }
}


// ./AISnapStudy/Services/StoreService.swift

import StoreKit

@MainActor
class StoreService: ObservableObject {
    static let shared = StoreService()
    
    @Published private(set) var products: [Product] = []
    @Published private(set) var purchasedProducts: [Product] = []
    @Published private(set) var subscriptionStatus: UserSubscriptionStatus
    
    private let productIds: Set<String> = Set(PurchaseProduct.allCases.map { $0.id })
    private let defaults = UserDefaults.standard
    private let subscriptionStatusKey = "userSubscriptionStatus"
    private let lastResetDateKey = "lastResetDate"
    private var resetTimer: Timer?
    
    private init() {
        // ì €ì¥ëœ êµ¬ë… ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
        if let savedData = defaults.data(forKey: subscriptionStatusKey),
           let savedStatus = try? JSONDecoder().decode(UserSubscriptionStatus.self, from: savedData) {
            self.subscriptionStatus = savedStatus
        } else {
            self.subscriptionStatus = UserSubscriptionStatus.defaultStatus
        }
        
        // ì´ˆê¸°í™” ì‹œ ìƒíƒœ í™•ì¸ ë° ë¦¬ì…‹
        checkAndResetDailyQuestions()
        
        Task {
            await loadProducts()
            await updatePurchasedProducts()
            await checkSubscriptionStatus()
        }
        
        setupDailyReset()
    }
    
    deinit {
        resetTimer?.invalidate()
    }
    
    private func setupDailyReset() {
        let calendar = Calendar.current
        let now = Date()
        guard let tomorrow = calendar.date(byAdding: .day, value: 1, to: now),
              let nextMidnight = calendar.date(bySettingHour: 0, minute: 0, second: 0, of: tomorrow) else {
            return
        }
        
        resetTimer?.invalidate()
        resetTimer = Timer(fire: nextMidnight, interval: 86400, repeats: true) { [weak self] _ in
            Task { @MainActor [weak self] in
                self?.checkAndResetDailyQuestions()
            }
        }
        
        if let timer = resetTimer {
            RunLoop.main.add(timer, forMode: .common)
        }
    }
    
    private func checkAndResetDailyQuestions() {
        let calendar = Calendar.current
        let now = Date()
        
        let shouldReset = if let lastResetDate = defaults.object(forKey: lastResetDateKey) as? Date {
            !calendar.isDate(lastResetDate, inSameDayAs: now)
        } else {
            true
        }
        
        if shouldReset {
            resetDailyQuestions()
        }
    }
    
    func loadProducts() async {
        do {
            products = try await Product.products(for: productIds)
            print("âœ… Loaded \(products.count) products")
        } catch {
            print("âŒ Failed to load products: \(error)")
        }
    }
    
    func purchase(_ product: Product) async throws {
        let result = try await product.purchase()
        
        switch result {
        case .success(let verification):
            await updatePurchasedProducts()
            await checkSubscriptionStatus()
            print("âœ… Purchase successful")
            
        case .userCancelled:
            print("â„¹ï¸ Purchase cancelled by user")
            
        case .pending:
            print("â³ Purchase pending")
            
        @unknown default:
            print("â“ Unknown purchase result")
        }
    }
    
    func updatePurchasedProducts() async {
        purchasedProducts.removeAll()
        
        for await result in Transaction.currentEntitlements {
            guard case .verified(let transaction) = result else { continue }
            
            if let product = products.first(where: { $0.id == transaction.productID }) {
                purchasedProducts.append(product)
            }
        }
        
        await updateSubscriptionStatus()
    }
    
    private func updateSubscriptionStatus() async {
        let isPremium = !purchasedProducts.isEmpty
        subscriptionStatus.isPremium = isPremium
        
        // Premium ìƒíƒœê°€ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ ì§ˆë¬¸ ìˆ˜ ë¦¬ì…‹
        if isPremium != subscriptionStatus.isPremium {
            resetDailyQuestions()
        }
        
        saveSubscriptionStatus()
    }
    
    private func resetDailyQuestions() {
        let maxQuestions = subscriptionStatus.isPremium ? 30 : 1
        subscriptionStatus.dailyQuestionsRemaining = maxQuestions
        subscriptionStatus.lastResetDate = Date()
        
        // ìƒíƒœ ì €ì¥
        saveSubscriptionStatus()
        // ë§ˆì§€ë§‰ ë¦¬ì…‹ ë‚ ì§œ ì €ì¥
        defaults.set(Date(), forKey: lastResetDateKey)
    }
    
    func checkSubscriptionStatus() async {
        if let savedStatus = loadSubscriptionStatus() {
            if savedStatus.isPremium != subscriptionStatus.isPremium {
                // Premium ìƒíƒœê°€ ë³€ê²½ëœ ê²½ìš°ë§Œ ì—…ë°ì´íŠ¸
                subscriptionStatus = savedStatus
                resetDailyQuestions()
            } else {
                // ê·¸ ì™¸ì˜ ê²½ìš° ë‚¨ì€ ì§ˆë¬¸ ìˆ˜ë§Œ ìœ ì§€
                subscriptionStatus.dailyQuestionsRemaining = savedStatus.dailyQuestionsRemaining
            }
        }
        
        checkAndResetDailyQuestions()
    }
    
    func decrementRemainingQuestions() {
        guard subscriptionStatus.dailyQuestionsRemaining > 0 else { return }
        subscriptionStatus.dailyQuestionsRemaining -= 1
        saveSubscriptionStatus()
    }
    
    private func saveSubscriptionStatus() {
        if let encoded = try? JSONEncoder().encode(subscriptionStatus) {
            defaults.set(encoded, forKey: subscriptionStatusKey)
        }
    }
    
    private func loadSubscriptionStatus() -> UserSubscriptionStatus? {
        guard let data = defaults.data(forKey: subscriptionStatusKey),
              let status = try? JSONDecoder().decode(UserSubscriptionStatus.self, from: data) else {
            return nil
        }
        return status
    }
}


// ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    // MARK: - Singleton
    static let shared = NetworkMonitor()
    
    // MARK: - Properties
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    private var timestampQueue: TimestampQueue
    
    // MARK: - Published Properties
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    // MARK: - Constants
    private let maxTimestamps = 1000
    private let cleanupInterval: TimeInterval = 300 // 5 minutes
    
    // MARK: - Debug Control
    private var shouldLog: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    // MARK: - Initialization
    private init() {
        self.timestampQueue = TimestampQueue(maxSize: maxTimestamps)
        setupPeriodicCleanup()
        startMonitoring()
    }
    
    // MARK: - Monitoring
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            self.timestampQueue.enqueue(Date().timeIntervalSince1970)
            
            DispatchQueue.main.async {
                self.updateNetworkStatus(path)
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    private func updateNetworkStatus(_ path: NWPath) {
        self.status = path.status
        self.isReachable = path.status == .satisfied
        self.connectionType = path.availableInterfaces.first?.type
        self.isExpensive = path.isExpensive
        self.isConstrained = path.isConstrained
        
        if shouldLog {
            switch path.status {
            case .satisfied:
                // ì¤‘ìš”í•œ ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€ê²½ë§Œ ë…¸í‹°í”¼ì¼€ì´ì…˜ ë°œì†¡
                if !isReachable {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            case .unsatisfied:
                Logger.log("Network disconnected", category: "Network")
            default:
                break
            }
        }
    }
    
    // MARK: - Network Status Check
    func checkNetworkAvailability() -> Bool {
        return status == .satisfied
    }
    
    func handleNetworkError(_ error: Error) async throws -> Bool {
        if !checkNetworkAvailability() {
            throw NetworkError.noConnection
        }
        return true
    }
    
    // MARK: - Timestamp Management
    private func setupPeriodicCleanup() {
        Timer.scheduledTimer(withTimeInterval: cleanupInterval, repeats: true) { [weak self] _ in
            self?.performTimestampCleanup()
        }
    }
    
    private func performTimestampCleanup() {
        let currentTime = Date().timeIntervalSince1970
        timestampQueue.removeTimestampsBefore(currentTime - cleanupInterval)
        if shouldLog {
            Logger.log("Timestamp cleanup completed", category: "Network")
        }
    }
    
    // MARK: - Utility Methods
    func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    // MARK: - Connection Management
    func getConnectionDetails() -> String {
        """
        Network Status:
        â€¢ Connection: \(isReachable ? "Connected" : "Disconnected")
        â€¢ Type: \(getInterfaceTypeString(connectionType))
        â€¢ Expensive: \(isExpensive ? "Yes" : "No")
        â€¢ Constrained: \(isConstrained ? "Yes" : "No")
        """
    }
    
    // MARK: - Cleanup
    func stopMonitoring() {
        monitor.cancel()
        if shouldLog {
            Logger.log("Network monitoring stopped", category: "Network")
        }
    }
    
    deinit {
        stopMonitoring()
    }
}

// MARK: - TimestampQueue
private class TimestampQueue {
    private var timestamps: [TimeInterval]
    private let maxSize: Int
    
    init(maxSize: Int) {
        self.maxSize = maxSize
        self.timestamps = []
        timestamps.reserveCapacity(maxSize)
    }
    
    func enqueue(_ timestamp: TimeInterval) {
        if timestamps.count >= maxSize {
            timestamps.removeFirst()
        }
        timestamps.append(timestamp)
    }
    
    func removeTimestampsBefore(_ time: TimeInterval) {
        timestamps.removeAll { $0 < time }
    }
    
    var count: Int {
        timestamps.count
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("ğŸ“± [\(category)] \(message)")
        #endif
    }
}


