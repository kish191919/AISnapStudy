// ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

@MainActor
class QuestionSettingsViewModel: ObservableObject {
    // Quick Text Mode ÏÉÅÌÉúÍ∞Ä @PublishedÎ°ú ÏÑ†Ïñ∏ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    @Published var useTextExtraction: Bool = true {
        didSet {
            UserDefaults.standard.set(useTextExtraction, forKey: "useTextExtraction")
        }
    }
    
    @Published var selectedLanguage: Language = .auto {
        didSet {
            UserDefaults.standard.set(selectedLanguage.rawValue, forKey: "selectedLanguage")
        }
    }
    
    // TextExtraction Í¥ÄÎ†® ÏÉÅÌÉúÎì§
    @Published var extractedTexts: [String: String] = [:]
    @Published var isLoadingTexts: [String: Bool] = [:]
    @Published var extractionStatus: [String: Bool] = [:]
    
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private var openAIService: OpenAIService?
    private let totalMaximumQuestions = 10
    private var studyViewModel: StudyViewModel?
    
    // MARK: - UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastDifficulty = "lastDifficulty"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    // MARK: - Published Properties

    private var imageIds: [UIImage: String] = [:]
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView: Bool = false
    @Published var isGeneratingQuestions: Bool = false
    @Published var problemSetName: String = ""
    @Published var isLoading: Bool = false
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool = true
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool = false
    @Published var alertTitle: String = ""
    @Published var alertMessage: String = ""
    
    @Published var selectedSubject: Subject {
         didSet {
             UserDefaults.standard.set(selectedSubject.rawValue, forKey: UserDefaultsKeys.lastSubject)
         }
     }
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
         }
     }
     
     @Published var difficulty: Difficulty {
         didSet {
             UserDefaults.standard.set(difficulty.rawValue, forKey: UserDefaultsKeys.lastDifficulty)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         }
     }
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
         }
     }
     
     let subject: Subject
     
     // MARK: - Initialization
     init(subject: Subject, homeViewModel: HomeViewModel) {
         
         self.subject = subject
         self.homeViewModel = homeViewModel
         self.studyViewModel = homeViewModel.studyViewModel
         
         // UserDefaultsÏóêÏÑú ÎßàÏßÄÎßâ ÏÑ§Ï†ïÍ∞íÏùÑ Î∂àÎü¨Ïò§Í±∞ÎÇò, ÏÑ†ÌÉùÎêú subject ÏÇ¨Ïö©
         let lastSubjectRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastSubject)
         let lastDifficultyRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastDifficulty)
         let lastEducationLevelRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel)

         
         // Í∏∞Î≥∏Í∞íÏùÑ ÌïòÎìúÏΩîÎî©ÌïòÏßÄ ÏïäÍ≥† ÌååÎùºÎØ∏ÌÑ∞ÎÇò null Ï≤òÎ¶¨
         self.selectedSubject = Subject(rawValue: lastSubjectRaw ?? "") ?? subject
         self.difficulty = Difficulty(rawValue: lastDifficultyRaw ?? "") ?? .medium  // Í∏∞Î≥∏Í∞íÏùÑ .mediumÏúºÎ°ú Î≥ÄÍ≤Ω
         
         self.educationLevel = EducationLevel(rawValue: lastEducationLevelRaw ?? "") ?? .elementary
         self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Initialize network monitoring
         self.isNetworkAvailable = networkMonitor.isReachable
         
         // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
         UserDefaults.standard.register(defaults: ["useTextExtraction": true])
         // Ï†ÄÏû•Îêú Í∞í Î°úÎìú
         self.useTextExtraction = UserDefaults.standard.bool(forKey: "useTextExtraction")
         print("üì± Initial useTextExtraction value loaded: \(useTextExtraction)")
         
         // Ï†ÄÏû•Îêú Ïñ∏Ïñ¥ ÏÑ§Ï†ï Î∂àÎü¨Ïò§Í∏∞
         if let savedLanguage = UserDefaults.standard.string(forKey: "selectedLanguage"),
            let language = Language(rawValue: savedLanguage) {
             self.selectedLanguage = language
         }
         
         
         // Initialize OpenAI service
         do {
             self.openAIService = try OpenAIService()
         } catch {
             self.error = error
             print("Failed to initialize OpenAI service:", error)
         }
     }
     
     // MARK: - Image Management
     private func generateImageId() -> String {
         return UUID().uuidString
     }
     
    func getImageId(for image: UIImage) -> String {
        if let existingId = imageIds[image] {
            return existingId
        }
        let newId = generateImageId()
        imageIds[image] = newId
        return newId
    }

    // ÏÉàÎ°úÏö¥ Ìï®Ïàò Ï∂îÍ∞Ä
    private func sendExtractedTextToOpenAI(_ text: String) async throws {
        print("üì§ Preparing to send extracted text to OpenAI")
        guard let openAIService = openAIService else {
            print("‚ùå OpenAI service not initialized")
            return
        }
        
        do {
            let response = try await openAIService.sendTextExtractionResult(text)
            print("‚úÖ OpenAI processing completed for extracted text")
            print("üì• OpenAI Response: \(response)")
        } catch {
            print("‚ùå Failed to process extracted text with OpenAI: \(error)")
            throw error
        }
    }

    private func sendImageToOpenAI(_ imageData: Data) async throws {
        print("üì§ Preparing to send image to OpenAI")
        guard let openAIService = openAIService else {
            print("‚ùå OpenAI service not initialized")
            return
        }
        
        do {
            try await openAIService.sendImageDataToOpenAI(imageData)
            print("‚úÖ Image successfully sent to OpenAI")
        } catch {
            print("‚ùå Failed to send image to OpenAI: \(error)")
            throw error
        }
    }

    
    func removeImage(at index: Int) {
        guard index < selectedImages.count else { return }
        
        let imageToRemove = selectedImages[index]
        if let imageId = imageIds[imageToRemove] {
            // Remove extracted text for this image
            extractedTexts.removeValue(forKey: imageId)
            imageIds.removeValue(forKey: imageToRemove)
            print("üóëÔ∏è Removed text for image: \(imageId)")
        }
        
        selectedImages.remove(at: index)
        
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false
            hasSelectedGallery = false
        }
    }
    
    
    func saveProblemSetName() {
        if problemSetName.isEmpty {
            problemSetName = generateDefaultName()
        }
        
        // Ïù¥Î¶ÑÏù¥ Ï†ÄÏû•ÎêòÏóàÏùåÏùÑ ÏïåÎ¶¨Îäî ÌîºÎìúÎ∞± Ï†úÍ≥µ
        HapticManager.shared.impact(style: .medium)
        print("Problem Set name saved: \(problemSetName)")
        
        // ÏßàÎ¨∏ ÏÉùÏÑ±Ïù¥ ÏôÑÎ£åÎêòÏóàÍ≥† Ïù¥Î¶ÑÏù¥ Ï†ÄÏû•ÎêòÏóàÏùÑ ÎïåÎßå StudyViewÎ°ú Ïù¥Îèô
        if !isGeneratingQuestions {
            shouldShowStudyView = true
        }
    }
    
    // Í∏∞Î≥∏ Ïù¥Î¶Ñ ÏÉùÏÑ± Î©îÏÑúÎìú
    func generateDefaultName() -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMdd_HHmm"
        let dateString = dateFormatter.string(from: Date())
        let totalQuestions = multipleChoiceCount + trueFalseCount
        
        return "\(selectedSubject.displayName)_\(totalQuestions)Q_\(dateString)"
        // Ïòà: "Math_10Q_0515_1430"
    }
     
     // Í∏∞Ï°¥ resetCounts Î©îÏÑúÎìú ÏàòÏ†ï
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults ÏôÑÏ†Ñ Ï¥àÍ∏∞ÌôîÍ∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞Î•º ÏúÑÌïú ÏÉàÎ°úÏö¥ Î©îÏÑúÎìú
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastDifficulty)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         difficulty = .medium
         resetCounts()
     }
    
    // questionTextÍ∞Ä ÎπÑÏñ¥ÏûàÏßÄ ÏïäÏúºÎ©¥ Ïù¥ÎØ∏ÏßÄ ÏòµÏÖòÏùÑ Ïà®Í∏∞Í∏∞ ÏúÑÌïú Í≥ÑÏÇ∞ ÏÜçÏÑ±
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // ÌÖçÏä§Ìä∏ ÏûÖÎ†•ÏùÑ Î¶¨ÏÖãÌïòÎäî Î©îÏÑúÎìú
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // Ïã§Ï†ú ÏÑ†ÌÉùÎêú Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏùÑ ÎïåÎßå Ï≤¥ÌÅ¨
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // Îã§Ïùå ÏÉÅÌÉú Î≥ÄÍ≤ΩÏùÑ ÏúÑÌï¥ Î¶¨ÏÖã
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // ÏÉÅÌÉú Î¶¨ÏÖã
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }

    @MainActor
    func addImage(_ image: UIImage) async {
       print("üì∏ Starting addImage processing...")
       do {
           let compressedData = try await Task {
               try ImageService.shared.compressForAPI(image)
           }.value

           if let compressedImage = UIImage(data: compressedData) {
               selectedImages.append(compressedImage)
               let imageId = getImageId(for: compressedImage)

               if useTextExtraction {
                   print("üîç Text extraction enabled for image: \(imageId)")
                   isLoadingTexts[imageId] = true
                   
                   // FileProvider ÏóêÎü¨ÏôÄ ÏÉÅÍ¥ÄÏóÜÏù¥ Vision API ÏÇ¨Ïö©
                   do {
                       // VisionServiceÎ•º ÌÜµÌïú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
                       print("üìù Starting Vision API text extraction...")
                       let extractedText = try await VisionService.shared.extractText(from: compressedImage)
                       
                       if !extractedText.isEmpty {
                           print("‚úÖ Text extracted successfully: \(extractedText)")
                           await MainActor.run {
                               extractedTexts[imageId] = extractedText
                               extractionStatus[imageId] = true
                               isLoadingTexts[imageId] = false
                           }
                       } else {
                           print("‚ö†Ô∏è No text extracted from image")
                           await MainActor.run {
                               extractionStatus[imageId] = false
                               isLoadingTexts[imageId] = false
                           }
                       }
                   } catch {
                       print("‚ùå Text extraction failed: \(error.localizedDescription)")
                       await MainActor.run {
                           extractionStatus[imageId] = false
                           isLoadingTexts[imageId] = false
                       }
                   }
               } else {
                   print("‚ÑπÔ∏è Text extraction disabled - using image directly")
               }
           }
       } catch {
           print("‚ùå Error in image processing: \(error.localizedDescription)")
           self.error = error
           showError(error)
       }
    }
    
    
    @MainActor
    func sendAllImages() async {
       print("üöÄ Starting sendAllImages process...")
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("‚ùå No content to generate questions from")
           return
       }
       
       isLoading = true
       studyViewModel?.isGeneratingQuestions = true
       
       do {
           var allExtractedText = ""
           var imagesForDirectProcessing: [UIImage] = []
           
           // Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨
           for image in selectedImages {
               let imageId = getImageId(for: image)
               print("üì∏ Processing image: \(imageId)")
               
               if useTextExtraction {
                   print("üîç Text extraction enabled - attempting to extract text...")
                   do {
                       let extractedText = try await VisionService.shared.extractText(from: image)
                       if !extractedText.isEmpty {
                           print("‚úÖ Successfully extracted text: \(extractedText)")
                           allExtractedText += extractedText + "\n"
                       } else {
                           print("‚ö†Ô∏è No text extracted, adding to direct processing queue")
                           imagesForDirectProcessing.append(image)
                       }
                   } catch {
                       print("‚ùå Error extracting text from image: \(error)")
                       imagesForDirectProcessing.append(image)
                   }
               } else {
                   print("‚ÑπÔ∏è Text extraction disabled - adding to direct processing queue")
                   imagesForDirectProcessing.append(image)
               }
           }

           // ÌÖçÏä§Ìä∏ ÏûÖÎ†• Ï≤òÎ¶¨
           if !questionText.isEmpty {
               let textInput = OpenAIService.QuestionInput(
                   content: questionText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("üìù Processing text input")
               await generateQuestions(from: textInput, parameters: createParameters())
           }
           
           // Ï∂îÏ∂úÎêú ÌÖçÏä§Ìä∏ Ï≤òÎ¶¨
           if !allExtractedText.isEmpty {
               let input = OpenAIService.QuestionInput(
                   content: allExtractedText.data(using: .utf8) ?? Data(),
                   isImage: false
               )
               print("üì§ Sending extracted text to OpenAI")
               await generateQuestions(from: input, parameters: createParameters())
           }
           
           // ÏßÅÏ†ë Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨Í∞Ä ÌïÑÏöîÌïú Í≤ΩÏö∞ Ï≤òÎ¶¨
           if !imagesForDirectProcessing.isEmpty {
               print("üì∏ Processing \(imagesForDirectProcessing.count) images directly")
               for image in imagesForDirectProcessing {
                   print("üñºÔ∏è Direct processing image")
                   try await processImageDirectly(image)
               }
           }
           
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           showSuccess()
           shouldShowStudyView = true
           
       } catch {
           print("‚ùå Error in sendAllImages: \(error.localizedDescription)")
           isLoading = false
           studyViewModel?.isGeneratingQuestions = false
           self.error = error
           showError(error)
       }
    }
    // generateQuestions(from:parameters:) Î≥¥Ï°∞ Ìï®Ïàò
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
       print("üîÑ Starting question generation from input")
       guard let openAIService = self.openAIService else {
           print("‚ùå OpenAI service not initialized")
           return
       }
       
       do {
           let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
           print("‚úÖ Successfully generated \(questions.count) questions")
           
           let name = problemSetName.isEmpty ? generateDefaultName() : problemSetName
           await processGeneratedQuestions(questions, name: name)
       } catch {
           print("‚ùå Error generating questions: \(error)")
           await MainActor.run {
               self.error = error
               showError(error)
           }
       }
    }

    // ÏßÅÏ†ë Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨Î•º ÏúÑÌïú Ìï®ÏàòÎèÑ ÏàòÏ†ï
    private func processImageDirectly(_ image: UIImage) async throws {
        print("üñºÔ∏è Processing image directly...")
        guard let openAIService = self.openAIService else {
            throw NetworkError.apiError("OpenAI service not initialized")
        }
        
        let compressedData = try await imageService.compressForAPI(image)
        let input = OpenAIService.QuestionInput(
            content: compressedData,
            isImage: true
        )
        print("üì§ Sending image to OpenAI")
        let questions = try await openAIService.generateQuestions(from: input, parameters: createParameters())
        await processGeneratedQuestions(questions, name: problemSetName)
    }

    private func createParameters() -> OpenAIService.QuestionParameters {
        return OpenAIService.QuestionParameters(
            subject: selectedSubject,
            difficulty: difficulty,
            educationLevel: educationLevel,
            questionTypes: [
                .multipleChoice: multipleChoiceCount,
                .trueFalse: trueFalseCount
            ],
            language: selectedLanguage  // language ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä
        )
    }
    // MARK: - Image Capture Methods
    @MainActor
    func takePhoto() async {
        print("üì∏ Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }
    
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("üì∏ Processing camera image...")
        guard let image = image else {
            print("‚ùå No image captured")
            return
        }

        Task {
            do {
                // Ïù¥ÎØ∏ÏßÄ Î∞©Ìñ• Î≥¥Ï†ï ÌõÑ Ï≤òÎ¶¨
                let orientedImage = image.fixedOrientation()
                await addImage(orientedImage)
                hasCameraImage = true
                hasSelectedCamera = true
                print("‚úÖ Camera image added successfully")
            } catch {
                print("‚ùå Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }
     
     @MainActor
     func selectFromGallery() async {
         do {
             let hasPermission = try await imageService.requestPermission(for: .gallery)
             if hasPermission {
                 showImagePicker = true
                 hasGalleryImages = true
             } else {
                 self.error = ImageServiceError.permissionDenied
                 showError(ImageServiceError.permissionDenied)
             }
         } catch {
             if let imageError = error as? ImageServiceError {
                 showError(imageError)
             } else {
                 showError(error)
             }
         }
     }
    
    @MainActor
    func processGeneratedQuestions(_ questions: [Question], name: String) async {
        print("\nüîÑ Processing Generated Questions:")
        print("Number of questions by type:")
        let questionsByType = Dictionary(grouping: questions, by: { $0.type })
        questionsByType.forEach { type, questions in
            print("- \(type.rawValue): \(questions.count) questions")
        }
        
        let subject = questions.first?.subject ?? self.subject
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            subject: subject,
            difficulty: difficulty,
            questions: questions,
            createdAt: Date(),
            educationLevel: self.educationLevel,
            name: name  // Ï†ÑÎã¨Î∞õÏùÄ Ïù¥Î¶Ñ ÏÇ¨Ïö©
        )

        
        print("\nüì¶ Setting ProblemSet in HomeViewModel")
        // ProblemSet Ï†ÄÏû•
        await homeViewModel.saveProblemSet(problemSet)
        // Ï†ÄÏû•Îêú ProblemSetÏùÑ Î∞îÎ°ú ÏÑ†ÌÉùÌïòÏó¨ ÏÇ¨Ïö©
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // Study ÌÉ≠ÏúºÎ°ú ÏûêÎèô Ï†ÑÌôò
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
    }

    @MainActor
    private func showSuccess() {
       alertTitle = "Success"
       alertMessage = "Questions have been successfully generated."
       showAlert = true
    }
    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


// ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    
    @Published var streak: Int = 0
    @Published var correctAnswers: Int = 0
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var isLoading = false
    
    private weak var studyViewModel: StudyViewModel?
    private weak var homeViewModel: HomeViewModel?
    

    
    @Published var totalPoints: Int = 0      // ÌòÑÏû¨ ÏÑ∏ÏÖòÏùò Ï†êÏàò
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    

    
    init(context: NSManagedObjectContext,
         homeViewModel: HomeViewModel? = nil,
         studyViewModel: StudyViewModel? = nil) {
        self.context = context
        self.homeViewModel = homeViewModel
        self.studyViewModel = studyViewModel
        
        // Move the loadStats() call to the end of the init method
        loadStats()
    }
    
    
    func updateScore() {
        if let studyVM = studyViewModel {
            // correctAnswersÎäî StudyViewModelÏóêÏÑú Í¥ÄÎ¶¨ÎêòÎäî ÌòÑÏû¨ ÏÑ∏ÏÖòÏùò Ï†ïÎãµ Ïàò
            correctAnswers = studyVM.correctAnswers
            // Í∞Å Î¨∏Ï†úÎãπ 10Ï†êÏî© Í≥ÑÏÇ∞
            totalPoints = correctAnswers * 10
        }
    }
    
    func updateStats(correctAnswers: Int, totalQuestions: Int) {
        self.correctAnswers = correctAnswers
        self.completedQuestions = totalQuestions
        self.accuracyRate = totalQuestions > 0 ?
            (Double(correctAnswers) / Double(totalQuestions)) * 100 : 0
            
        print("""
        üìä Stats Updated:
        ‚Ä¢ Correct Answers: \(correctAnswers)
        ‚Ä¢ Total Score: \(correctAnswers * 10)
        ‚Ä¢ Accuracy Rate: \(accuracyRate)%
        """)
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("üîÑ Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("üîÑ Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    func loadStats() {
        isLoading = true
        let request: NSFetchRequest<CDStudySession> = CDStudySession.fetchRequest()
        
        do {
            let sessions = try context.fetch(request)
            calculateStats(from: sessions)
        } catch {
            print("Failed to fetch study sessions:", error)
        }
        
        isLoading = false
    }

    private func calculateStats(from sessions: [CDStudySession]) {
        totalQuestions = sessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrect = sessions.reduce(0) { total, session in
            total + (session.questions?.filter { ($0 as? CDQuestion)?.isCorrect == true }.count ?? 0)
        }
        
        averageScore = totalQuestions > 0 ? (Double(totalCorrect) / Double(totalQuestions)) * 100 : 0
        correctAnswers = totalCorrect
        completedQuestions = totalQuestions
        totalPoints = completedQuestions * 10
        accuracyRate = completedQuestions > 0 ? (Double(correctAnswers) / Double(completedQuestions)) * 100 : 0
        streak = calculateStreak(from: sessions)
    }

    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
            print("üîÑ Starting resetProgress...")
            correctAnswers = 0
            completedQuestions = 0
            accuracyRate = 0
            totalPoints = 0  // Ï†êÏàò Ï¥àÍ∏∞Ìôî
            
            // HomeViewModelÏùÑ ÌÜµÌï¥ StudyViewModelÏóê Ï†ëÍ∑º
            guard let homeVM = homeViewModel else {
                print("‚ùå homeViewModel is nil in resetProgress")
                return
            }
            
            guard let studyVM = homeVM.studyViewModel else {
                print("‚ùå studyViewModel is nil in resetProgress")
                return
            }
            
            guard let currentProblemSet = homeVM.selectedProblemSet else {
                print("‚ùå No selected problem set found")
                return
            }
            guard let homeVM = homeViewModel,
                  let studyVM = homeVM.studyViewModel,
                  let currentProblemSet = homeVM.selectedProblemSet else {
                print("‚ùå Required view models not found")
                return
                }

                Task {
                    print("üîÑ Resetting study state...")
                    await studyVM.resetState()
                    
                    await MainActor.run {
                        print("üîÑ Loading questions...")
                        studyVM.loadQuestions(currentProblemSet.questions)
                        
                        print("""
                        ‚úÖ Reset complete:

                        ‚Ä¢ Total Questions: \(currentProblemSet.questions.count)
                        """)
                    }
                }
            }
        }


// ./AISnapStudy/ViewModels/HomeViewModel.swift

// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    @Published var studyViewModel: StudyViewModel?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var correctAnswers: Int = 0
    @Published var totalQuestions: Int = 0
    @Published private(set) var selectedProblemSet: ProblemSet?
    
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()

    
    init() {
        Task {
            await loadInitialData()
        }
    }
    
        
    func setStudyViewModel(_ viewModel: StudyViewModel) {
        print("üì± Setting StudyViewModel in HomeViewModel")
        self.studyViewModel = viewModel
    }
    
    @MainActor
    func resetAndSetProblemSet(_ problemSet: ProblemSet) async {
        print("üîÑ Starting complete ProblemSet reset")
        
        // ÏÉàÎ°úÏö¥ ProblemSet ÏÑ§Ï†ï
        self.selectedProblemSet = problemSet
        
        // StudyViewModelÏù¥ nilÏù¥ ÏïÑÎãåÏßÄ ÌôïÏù∏
        guard let studyVM = studyViewModel else {
            print("‚ùå StudyViewModel is nil")
            return
        }
        
        // ÏÉÅÌÉú Î¶¨ÏÖã Î∞è Î¨∏Ï†ú Îã§Ïãú Î°úÎìú
        await studyVM.resetState()
        studyVM.loadQuestions(problemSet.questions)
        
        print("""
        ‚úÖ ProblemSet reset complete:
        ‚Ä¢ ID: \(problemSet.id)
        ‚Ä¢ Questions: \(problemSet.questions.count)
        ‚Ä¢ Index reset to 0
        ‚Ä¢ Current Question: \(studyVM.currentQuestion?.question ?? "none")
        """)
    }
    
    // MARK: - Data Loading
    @MainActor
    private func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("üîµ HomeViewModel - Initial data loading")
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            hasLoadedData = true
            print("‚úÖ Initial data loaded successfully")
        } catch {
            print("‚ùå Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("üîµ HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // ÏµúÍ∑º ProblemSetÏùÑ selectedProblemSetÏúºÎ°ú ÏÑ§Ï†ï
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            print("‚úÖ Loaded problem sets: \(problemSets.count)")
            print("‚úÖ Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("‚ùå Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            print("üíæ Saving ProblemSet with \(problemSet.questions.count) questions")
            try await coreDataService.saveProblemSet(problemSet)
            
            // Îç∞Ïù¥ÌÑ∞ Î¶¨Î°úÎìú ÎåÄÏã† Î¨∏Ï†ú ÏÑ∏Ìä∏ ÏßÅÏ†ë Ï∂îÍ∞Ä
            problemSets.insert(problemSet, at: 0)
            setSelectedProblemSet(problemSet)
            
            print("‚úÖ Saved ProblemSet: \(problemSet.questions.count) questions")
        } catch {
            self.error = error
            print("‚ùå Failed to save ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("üîµ HomeViewModel - Setting selected problem set")
        
        // ÏÉÅÌÉú Î≥ÄÍ≤ΩÏùÑ Î©îÏù∏ Ïä§Î†àÎìúÏóêÏÑú ÌïúÎ≤àÏóê Ï≤òÎ¶¨
        DispatchQueue.main.async {
            self.selectedProblemSet = problemSet
            
            if let problemSet = problemSet {
                print("""
                ‚úÖ ProblemSet set successfully:
                ‚Ä¢ ID: \(problemSet.id)
                ‚Ä¢ Questions: \(problemSet.questions.count)
                """)
            }
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("‚ùå Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("‚ùå Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                üìù Stored ProblemSets:
                ‚Ä¢ Count: \(storedSets.count)
                ‚Ä¢ Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("‚ùå Failed to verify storage: \(error)")
            }
        }
    }
}


// ./AISnapStudy/ViewModels/ReviewViewModel.swift


import Foundation

import Foundation

@MainActor
class ReviewViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            üìö Review Data Loaded:
            ‚Ä¢ Study Sessions: \(studySessions.count)
            ‚Ä¢ Problem Sets: \(problemSets.count)
            ‚Ä¢ Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("‚ùå Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("‚úÖ Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("‚ùå Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("üì± HomeViewModel reference set in ReviewViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


// ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
    // OpenAIService ÌÉÄÏûÖ Ï∞∏Ï°∞ Ï∂îÍ∞Ä
    typealias QuestionInput = OpenAIService.QuestionInput
    typealias QuestionParameters = OpenAIService.QuestionParameters
    private weak var statViewModel: StatViewModel?

    @Published private(set) var loadedQuestions: [Question] = []
    @Published private(set) var loadingProgress = 0

    private let openAIService: OpenAIService

    @Published private(set) var currentQuestion: Question?
    @Published var selectedAnswer: String?
    @Published var showExplanation = false
    private var questions: [Question] = []
    private var cancellables = Set<AnyCancellable>()
    @Published private(set) var currentIndex = 0
    @Published var correctAnswers: Int = 0

    // ÏßàÎ¨∏ ÏÉùÏÑ± Í¥ÄÎ†® ÌîÑÎ°úÌçºÌã∞ Ï∂îÍ∞Ä
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    
    func setStatViewModel(_ viewModel: StatViewModel) {
        self.statViewModel = viewModel
    }

    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }

    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }

    var totalQuestions: Int {
        questions.count
    }

    private let context: NSManagedObjectContext
    private var currentSession: CDStudySession?
    private let homeViewModel: HomeViewModel

    private var hasInitialized = false

    init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
        self.context = context
        self.homeViewModel = homeViewModel

        // OpenAIService Ï¥àÍ∏∞Ìôî
        do {
            self.openAIService = try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAI service: \(error)")
        }

        Task { @MainActor in
            homeViewModel.$selectedProblemSet
                .compactMap { $0 }
                .removeDuplicates(by: { $0.id == $1.id })
                .receive(on: RunLoop.main)
                .sink { [weak self] problemSet in
                    guard let self = self else { return }
                    // async Î©îÏÑúÎìúÎ•º Task ÎÇ¥ÏóêÏÑú Ìò∏Ï∂úÌïòÎèÑÎ°ù ÏàòÏ†ï
                    Task {
                        await self.resetState()
                        await MainActor.run {
                            self.loadQuestions(problemSet.questions)
                        }
                    }
                }
                .store(in: &self.cancellables)
        }

        setupCurrentSession()
    }

    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []

        // ÏòàÏÉÅÎêòÎäî Ï¥ù ÏßàÎ¨∏ Ïàò Í≥ÑÏÇ∞
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)

        do {
            let questions = try await openAIService.generateQuestions(from: input, parameters: parameters)
            await MainActor.run {
                questions.forEach { question in
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }

        await MainActor.run {
            isGeneratingQuestions = false
            loadedQuestions = generatedQuestions
            loadingProgress = 100
            isLoadingQuestions = false
        }
    }
   
    @MainActor
    func resetState() async {
        print("üîÑ Performing complete state reset")
        currentIndex = 0
        selectedAnswer = nil
        showExplanation = false
        correctAnswers = 0
        
        await MainActor.run {
            questions.removeAll()
            
            if let problemSet = homeViewModel.selectedProblemSet {
                questions = problemSet.questions
                currentQuestion = questions.first
            }
        }
        
        print("""
        ‚úÖ State reset complete:
        ‚Ä¢ Questions count: \(questions.count)
        ‚Ä¢ Current index: \(currentIndex)
        ‚Ä¢ Current question: \(currentQuestion?.question ?? "No question loaded")
        """)
    }
   
   func loadQuestions(_ newQuestions: [Question]) {
       print("üìù Loading fresh set of \(newQuestions.count) questions")
       questions = newQuestions
       currentIndex = 0
       currentQuestion = questions.isEmpty ? nil : questions[0]
       
       print("‚úÖ First question loaded explicitly: \(currentQuestion?.question ?? "No question loaded") with currentIndex: \(currentIndex)")
   }
   
   private func setupCurrentSession() {
       let session = CDStudySession(context: context)
       session.startTime = Date()
       currentSession = session
       saveContext()
   }
   
    func submitAnswer() {
        guard let currentQuestion = currentQuestion else { return }
        
        print("Debug True/False Detailed:")
        print("Selected Answer (raw): \(selectedAnswer ?? "nil")")
        print("Selected Answer (lowercased): \(selectedAnswer?.lowercased() ?? "nil")")
        print("Correct Answer (raw): \(currentQuestion.correctAnswer)")
        print("Correct Answer (lowercased): \(currentQuestion.correctAnswer.lowercased())")
        print("Are they equal? \(currentQuestion.correctAnswer.lowercased() == selectedAnswer?.lowercased())")
        print("Length of selected answer: \(selectedAnswer?.count ?? 0)")
        print("Length of correct answer: \(currentQuestion.correctAnswer.count)")
        
        // Í≥µÎ∞± Ï†úÍ±∞ÌïòÍ≥† ÎπÑÍµê
        let trimmedSelected = selectedAnswer?.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        let trimmedCorrect = currentQuestion.correctAnswer.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        
        let isCorrect = trimmedSelected == trimmedCorrect
        

        print("Trimmed Selected: '\(trimmedSelected ?? "nil")'")
        print("Trimmed Correct: '\(trimmedCorrect)'")
        print("Final comparison result: \(isCorrect)")
        
        
        if let session = currentSession {
            let question = CDQuestion(context: context)
            question.isCorrect = isCorrect
            question.question = currentQuestion.question
            question.session = session
            saveContext()
        }
        
        showExplanation = true
    }
   
   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
   private func saveContext() {
       do {
           try context.save()
       } catch {
           print("Failed to save context: \(error)")
       }
   }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("‚úÖ Question save state toggled successfully")
       } catch {
           print("‚ùå Failed to toggle question save state: \(error)")
       }
   }
}


// ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
        setupMetal()
    }

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
        }
    }
    
    private func setupMetal() {
        // Metal ÎîîÎ∞îÏù¥Ïä§ Ï≤¥ÌÅ¨
        guard MTLCreateSystemDefaultDevice() != nil else {
            print("Metal is not supported on this device")
            return
        }
        
        // MetalTools ÌîÑÎ†àÏûÑÏõåÌÅ¨ Ï¥àÍ∏∞Ìôî ÏßÄÏó∞
        DispatchQueue.main.async {
            // MetalTools Í¥ÄÎ†® ÏûëÏóÖ
        }
    }
    
    private func setupAppearance() {
        // ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î∞î Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        
        // ÌÉ≠ Î∞î Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        return true
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        üìä CoreData Configuration:
        ‚Ä¢ Store Descriptions: \(container.persistentStoreDescriptions.count)
        ‚Ä¢ View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("‚ùå No store URL found")
            return
        }
        
        print("‚Ä¢ Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("‚úÖ Created CoreData directory")
        } catch {
            print("‚ùå Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData ÏòµÏÖò ÏÑ§Ï†ï
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // ÏÑ±Îä• ÏµúÏ†ÅÌôî ÏÑ§Ï†ï
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


// ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


// ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


// ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


// ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



// ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


// ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


// ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    let day: String          // "Mon", "Tue", etc.
    let questionsCompleted: Int
    let correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.day = date.formatted(.dateTime.weekday(.abbreviated))
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


// ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // Ï∂îÍ∞Ä: Structured OutputsÏùò refusal Ï≤òÎ¶¨Î•º ÏúÑÌï¥
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


// ./AISnapStudy/Models/Language.swift




// ./AISnapStudy/Models/ProblemSet.swift


import Foundation

public struct ProblemSet: Identifiable, Codable {
    public let id: String
    public let subject: Subject
    public let difficulty: Difficulty
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    
    
    // ÏÉàÎ°ú Ï∂îÍ∞ÄÌï† ÏÜçÏÑ±Îì§
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?
    public var isFavorite: Bool
    
    public var questionCount: Int {
        questions.count
    }
    
    public init(
          id: String,
          subject: Subject,
          difficulty: Difficulty,
          questions: [Question],
          createdAt: Date,
          lastAttempted: Date? = nil,
          educationLevel: EducationLevel,
          name: String,
          tags: [String] = [],
          problemSetDescription: String? = nil,
          isFavorite: Bool = false
      ) {
          self.id = id
          self.subject = subject
          self.difficulty = difficulty
          self.questions = questions
          self.createdAt = createdAt
          self.lastAttempted = lastAttempted
          self.educationLevel = educationLevel
          self.name = name
          self.tags = tags
          self.problemSetDescription = problemSetDescription
          self.isFavorite = isFavorite
      }
}

// MARK: - Hashable
extension ProblemSet: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/ReviewFilter.swift


import Foundation

enum ReviewFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



// ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
    case multipleChoice = "multiple_choice"
    case trueFalse = "true_false"  
}

public struct Question: Identifiable, Codable {
    public let id: String
    public let type: QuestionType
    public let subject: Subject
    public let difficulty: Difficulty
    public let question: String
    public let options: [String]
    public let correctAnswer: String
    public let explanation: String
    public let hint: String?
    public var isSaved: Bool
    public let createdAt: Date
    
    public init(
        id: String,
        type: QuestionType,
        subject: Subject,
        difficulty: Difficulty,
        question: String,
        options: [String] = [],
        correctAnswer: String,
        explanation: String,
        hint: String? = nil,
        isSaved: Bool = false,
        createdAt: Date = Date()
    ) {
        self.id = id
        self.type = type
        self.subject = subject
        self.difficulty = difficulty
        self.question = question
        self.options = options
        self.correctAnswer = correctAnswer
        self.explanation = explanation
        self.hint = hint
        self.isSaved = isSaved
        self.createdAt = createdAt
    }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
    public static var supportsSecureCoding: Bool {
        return true
    }
    
    let question: Question
    
    init(question: Question) {
        self.question = question
        super.init()
    }
    
    public func encode(with coder: NSCoder) {
        coder.encode(question.id, forKey: "id")
        coder.encode(question.type.rawValue, forKey: "type")
        coder.encode(question.subject.rawValue, forKey: "subject")
        coder.encode(question.difficulty.rawValue, forKey: "difficulty")
        coder.encode(question.question, forKey: "question")
        coder.encode(question.options, forKey: "options")
        coder.encode(question.correctAnswer, forKey: "correctAnswer")
        coder.encode(question.explanation, forKey: "explanation")
        coder.encode(question.hint, forKey: "hint")
        coder.encode(question.isSaved, forKey: "isSaved")
        coder.encode(question.createdAt, forKey: "createdAt")
    }
    
    public required init?(coder: NSCoder) {
        guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
              let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
              let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
              let difficultyRaw = coder.decodeObject(of: NSString.self, forKey: "difficulty") as String?,
              let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
              let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
              let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
              let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
            return nil
        }
        
        let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
        let isSaved = coder.decodeBool(forKey: "isSaved")
        let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
        
        let question = Question(
            id: id,
            type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
            subject: Subject(rawValue: subjectRaw) ?? .math,
            difficulty: Difficulty(rawValue: difficultyRaw) ?? .medium,
            question: questionText,
            options: options,
            correctAnswer: correctAnswer,
            explanation: explanation,
            hint: hint,
            isSaved: isSaved,
            createdAt: createdAt
        )
        
        self.question = question
        super.init()
    }
}

// MARK: - Hashable
extension Question: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/Subject.swift


import SwiftUI

public enum Subject: String, Codable, CaseIterable {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        }
    }
    
    public var displayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        }
    }
}

public enum EducationLevel: String, Codable, CaseIterable {
    case elementary = "elementary"
    case middle = "middle"
    case high = "high"
    case college = "college"
    
    public var displayName: String {
        switch self {
        case .elementary:
            return "Elementary"
        case .middle:
            return "Middle"
        case .high:
            return "High"
        case .college:
            return "College"
        }
    }
    
    public var color: Color {
        switch self {
        case .elementary:
            return .green
        case .middle:
            return .green
        case .high:
            return .green
        case .college:
            return .green
        }
    }
}

public enum Difficulty: String, Codable, CaseIterable {
    case easy = "easy"
    case medium = "medium"
    case hard = "hard"
    
    public var iconName: String {
            switch self {
            case .easy:
                return "1.circle.fill"
            case .medium:
                return "2.circle.fill"
            case .hard:
                return "3.circle.fill"
            }
        }
    
    public var color: Color {
        switch self {
        case .easy:
            return .green
        case .medium:
            return .green
        case .hard:
            return .green
        }
    }
    
    public var displayName: String {
        rawValue.capitalized
    }
    
    public var icon: String {
        switch self {
        case .easy:
            return "1.circle.fill"
        case .medium:
            return "2.circle.fill"
        case .hard:
            return "3.circle.fill"
        }
    }
    
    // ÎÇúÏù¥ÎèÑÎ•º Ïà´ÏûêÎ°ú ÌëúÌòÑ
    public var level: Int {
        switch self {
        case .easy: return 1
        case .medium: return 2
        case .hard: return 3
        }
    }
}


// ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Ï†ÄÏû• ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÎäî Î°úÏßÅ Ï∂îÍ∞Ä
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


// ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


// ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


// ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


// ./AISnapStudy/Views/Question/QuestionSettingsView.swift



import SwiftUI
import PhotosUI
import UIKit
import AVFoundation

struct QuestionSettingsView: View {
    @StateObject private var viewModel: QuestionSettingsViewModel
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedTab: Int
    @State private var expandedSections: Set<SectionType> = []
    @State private var isTextInputSelected = false
    @State private var showNamePopup = false
    @State private var isGeneratingQuestions = false
    
    let subject: Subject
    
    public enum SectionType: Hashable {
        case questionAbout
        case learningSubject
        case questionTypes
        case educationLevel
        case difficultyLevel
    }
    
    init(subject: Subject, homeViewModel: HomeViewModel, selectedTab: Binding<Int>) {
        self.subject = subject
        self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
            subject: subject,
            homeViewModel: homeViewModel
        ))
        self._selectedTab = selectedTab
    }
    
    var body: some View {
        VStack(spacing: 0) {
            Form {
                // Speed Up and Language Selection Section
                Section {
                    SpeedUpSection(useTextExtraction: $viewModel.useTextExtraction)
                }
                .listRowSpacing(0)

                Section {
                    LanguageSection(selectedLanguage: $viewModel.selectedLanguage)
                }
                .listRowSpacing(0)


                // Image Selection Options
                HStack(spacing: 12) {
                    ImageOptionCard(
                        icon: "camera.fill",
                        isUsed: viewModel.hasSelectedCamera,
                        isDisabled: !viewModel.canUseImageInput,
                        action: {
                            if viewModel.canUseImageInput {
                                isTextInputSelected = false
                                Task { await viewModel.takePhoto() }
                            }
                        }
                    )

                    ImageOptionCard(
                        icon: "photo.fill",
                        isUsed: viewModel.hasSelectedGallery,
                        isDisabled: !viewModel.canUseImageInput,
                        action: {
                            if viewModel.canUseImageInput {
                                isTextInputSelected = false
                                Task { await viewModel.selectFromGallery() }
                            }
                        }
                    )

                    ImageOptionCard(
                        icon: "text.bubble.fill",
                        isUsed: viewModel.isTextInputActive,
                        isDisabled: !viewModel.canUseTextInput,
                        action: {
                            isTextInputSelected.toggle()
                            viewModel.toggleTextInput()
                        }
                    )
                }
                .padding(.horizontal)

                // Text Input Field
                if viewModel.isTextInputActive {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .padding(.horizontal)
                }

                // Selected Images Display
                if !viewModel.selectedImages.isEmpty {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                SelectedImageCell(
                                    image: viewModel.selectedImages[index],
                                    onDelete: {
                                        viewModel.removeImage(at: index)
                                    }
                                )
                            }
                        }
                        .padding(.vertical, 8)
                    }
                }
                
                // Subject Section
                Section {
                    DisclosureGroup(
                        isExpanded: isExpandedBinding(for: .learningSubject)
                    ) {
                        LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                    } label: {
                        HStack {
                            Text("Subject")
                                .font(.headline)
                            Spacer()
                            Text(viewModel.selectedSubject.displayName)
                                .foregroundColor(.gray)
                        }
                    }
                }.listRowSpacing(0)
                
                // Question Types Section
                Section {
                    DisclosureGroup(
                        isExpanded: isExpandedBinding(for: .questionTypes)
                    ) {
                        QuestionTypesSelectionSection(viewModel: viewModel)
                    } label: {
                        HStack {
                            Text("Type")
                                .font(.headline)
                            Spacer()
                            Text("\(viewModel.totalQuestionCount) questions")
                                .foregroundColor(.gray)
                        }
                    }
                }.listRowSpacing(0)
                
                if isTextInputSelected {
                    // Education Level Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .educationLevel)
                        ) {
                            EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                        } label: {
                            HStack {
                                Text("Education Level")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.educationLevel.displayName)
                                    .foregroundColor(.gray)
                            }
                        }
                    }.listRowSpacing(0)
                    
                    // Difficulty Level Section
                    Section {
                        DisclosureGroup(
                            isExpanded: isExpandedBinding(for: .difficultyLevel)
                        ) {
                            DifficultyLevelSection(difficulty: $viewModel.difficulty)
                        } label: {
                            HStack {
                                Text("Difficulty Level")
                                    .font(.headline)
                                Spacer()
                                Text(viewModel.difficulty.displayName)
                                    .foregroundColor(.gray)
                            }
                        }
                    }.listRowSpacing(0)
                }
            }
            .listSectionSpacing(4)
            
            // Generate Questions Button
            VStack {
                Button(action: {
                    showNamePopup = true
                    isGeneratingQuestions = true
                    Task {
                        await viewModel.sendAllImages()
                    }
                }) {
                    Text("Generate Questions")
                        .font(.headline)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                        .cornerRadius(10)
                }
                .disabled(!isGenerateButtonEnabled)
                .padding()
            }
            .background(Color(UIColor.systemGroupedBackground))
        }
        .overlay(popupOverlay)
        .navigationBarItems(leading: cancelButton)
        .navigationBarTitleDisplayMode(.inline)
        .sheet(isPresented: $viewModel.showImagePicker) {
            PhotoPicker(selectedImages: $viewModel.selectedImages)
        }
        .sheet(isPresented: $viewModel.showCamera) {
            ImagePicker(
                image: $viewModel.selectedImage,
                sourceType: .camera,
                onImageSelected: { image in
                    Task {
                        await viewModel.handleCameraImage(image)
                    }
                }
            )
        }
        .alert(isPresented: $viewModel.showAlert) {
            Alert(
                title: Text(viewModel.alertTitle),
                message: Text(viewModel.alertMessage),
                dismissButton: .default(Text("OK")) {
                    if viewModel.alertTitle == "Success" {
                        dismiss()
                    }
                }
            )
        }
        .onChange(of: viewModel.shouldShowStudyView) { show in
            if show {
                dismiss()
                selectedTab = 1
            }
        }
    }
    
    private var cancelButton: some View {
        Button("Cancel") {
            viewModel.resetCounts()
            dismiss()
        }
    }
    
    private var popupOverlay: some View {
        Group {
            if showNamePopup {
                ProblemSetNamePopup(
                    isPresented: $showNamePopup,
                    problemSetName: $viewModel.problemSetName,
                    isGeneratingQuestions: $viewModel.isGeneratingQuestions,
                    defaultName: viewModel.generateDefaultName()
                ) {
                    viewModel.saveProblemSetName()
                    showNamePopup = false
                    viewModel.shouldShowStudyView = true
                }
                .transition(.opacity)
                .animation(.easeInOut, value: showNamePopup)
            }
        }
    }
    
    private var isGenerateButtonEnabled: Bool {
        let hasInput = !viewModel.selectedImages.isEmpty ||
            (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
        let hasQuestionType = viewModel.totalQuestionCount > 0
        return hasInput && hasQuestionType
    }
    
    private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
        Binding(
            get: { expandedSections.contains(section) },
            set: { isExpanded in
                withAnimation {
                    if isExpanded {
                        expandedSections.insert(section)
                    } else {
                        expandedSections.remove(section)
                    }
                }
            }
        )
    }
}



struct GeneratingQuestionsOverlay: View {
    let questionCount: Int
    @State private var animatingDots = false
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 16) {
                ProgressView()
                    .scaleEffect(1.5)
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                
                Text("Generating \(questionCount) questions\(dots)")
                    .font(.headline)
                    .foregroundColor(.white)
                
                Text("Please wait...")
                    .font(.subheadline)
                    .foregroundColor(.white.opacity(0.8))
            }
            .padding()
            .background(Color.black.opacity(0.6))
            .cornerRadius(10)
        }
        .onAppear {
            withAnimation(Animation.easeInOut(duration: 0.8).repeatForever()) {
                animatingDots.toggle()
            }
        }
    }
    
    private var dots: String {
        animatingDots ? "..." : ""
    }
}

struct ProblemSetNamePopup: View {
    @Binding var isPresented: Bool
    @Binding var problemSetName: String
    @Binding var isGeneratingQuestions: Bool  // Ï∂îÍ∞Ä
    let defaultName: String
    let onSubmit: () -> Void
    
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 24) {
                Text("Name Your Question Set")
                    .font(.title2)
                    .fontWeight(.bold)
                
                VStack(alignment: .leading, spacing: 8) {
                    Text("Enter a name for your question set:")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    TextField("Enter name", text: $problemSetName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .font(.body)
                        .frame(height: 44)
                        .placeholder(when: problemSetName.isEmpty) {
                            Text("Default: \(defaultName)")
                                .foregroundColor(.gray)
                        }
                }
                
                // ÏßàÎ¨∏ ÏÉùÏÑ± ÏÉÅÌÉúÏóê Îî∞Î•∏ Î©îÏãúÏßÄ ÌëúÏãú
                Text(isGeneratingQuestions ?
                     "Questions are being generated... Please wait." :
                     "Questions are ready. Please save the name to continue.")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Button(action: {
                    if problemSetName.isEmpty {
                        problemSetName = defaultName
                    }
                    if !isGeneratingQuestions {
                        onSubmit()
                    }
                }) {
                    Text(isGeneratingQuestions ? "Generating Questions..." : "Save Name")
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .frame(height: 44)
                        .background(isGeneratingQuestions ? Color.gray : Color.blue)
                        .cornerRadius(10)
                }
                .disabled(isGeneratingQuestions)
            }
            .padding(32)
            .background(Color(UIColor.systemBackground))
            .cornerRadius(16)
            .shadow(radius: 10)
            .padding(.horizontal, 32)
        }
    }
}

// Generate Questions Footer
struct GenerateQuestionsFooter: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @Binding var isGeneratingQuestions: Bool
    @Binding var showNamePopup: Bool
    let isGenerateButtonEnabled: Bool
    
    var body: some View {
        VStack {
            Button(action: {
                showNamePopup = true
                isGeneratingQuestions = true
                Task {
                    await viewModel.sendAllImages()
                }
            }) {
                Text("Generate Questions")
                    .font(.headline)
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                    .cornerRadius(10)
            }
            .disabled(!isGenerateButtonEnabled)
            .padding()
        }
        .background(Color(UIColor.systemGroupedBackground))
    }
}

struct SubjectSelectionButton: View {
   let subject: Subject
   let isSelected: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 8) {
               Image(systemName: subject.icon)
                   .font(.system(size: 24))
               Text(subject.displayName)
                   .font(.caption)
                   .lineLimit(1)
                   .minimumScaleFactor(0.8)
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 12)
           .padding(.horizontal, 8)
           .background(
               RoundedRectangle(cornerRadius: 10)
                   .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
           )
           .foregroundColor(isSelected ? subject.color : .gray)
           .overlay(
               RoundedRectangle(cornerRadius: 10)
                   .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
           )
       }
       .buttonStyle(PlainButtonStyle())
   }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}

struct DifficultyLevelSection: View {
   @Binding var difficulty: Difficulty
   
   var body: some View {
       HStack(spacing: 12) {
           ForEach(Difficulty.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: difficulty == level,
                   color: level.color
               ) {
                   withAnimation(.spring()) {
                       difficulty = level
                   }
               }
           }
       }
       .padding(.vertical, 8)
   }
}


struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // Ï∂îÍ∞Ä
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSectionÎèÑ ÏàòÏ†ï
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // Ï¥ù Î¨∏Ï†ú Ïàò ÌëúÏãú
                HStack {
                    Text("Type")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/10")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(Subject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject == subject
                        ) {
                            viewModel.selectedSubject = subject
                            print("Selected subject: \(subject.rawValue)")  // Î°úÍπÖ Ï∂îÍ∞Ä
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// ImagePicker, PhotoPicker, LoadingView ÎèÑ Ï∂îÍ∞Ä
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = 10
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

class CustomImagePickerController: UIImagePickerController {
    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .all // Î™®Îì† Î∞©Ìñ• ÏßÄÏõê
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)?
    
    class CustomImagePickerController: UIImagePickerController {
        override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
            return .portrait // Ïπ¥Î©îÎùº UIÎäî Ìï≠ÏÉÅ ÏÑ∏Î°ú Î™®ÎìúÎ°ú Ïú†ÏßÄ
        }
    }
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = CustomImagePickerController()
        picker.delegate = context.coordinator
        picker.sourceType = sourceType
        
        if sourceType == .camera {
            picker.cameraDevice = .rear
            picker.cameraCaptureMode = .photo
            picker.allowsEditing = false
            
            // Ï†ÑÏ≤¥ ÌôîÎ©¥ Î™®ÎìúÎ°ú ÏÑ§Ï†ï
            picker.modalPresentationStyle = .fullScreen
            
            // Ïπ¥Î©îÎùº UIÎ•º ÏÑ∏Î°ú Î™®ÎìúÎ°ú Í≥†Ï†ï
            picker.navigationController?.navigationBar.isHidden = false
            picker.navigationController?.interactivePopGestureRecognizer?.isEnabled = false
        }
        
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController,
                                 didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                // Ïù¥ÎØ∏ÏßÄÎäî ÏõêÎûò Î∞©Ìñ• Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
                parent.image = image
                parent.onImageSelected?(image)
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

// UIImage extension for orientation fixing
extension UIImage {
    func fixedOrientation() -> UIImage {
        if imageOrientation == .up { return self }
        
        var transform = CGAffineTransform.identity
        
        switch imageOrientation {
        case .down, .downMirrored:
            transform = transform.translatedBy(x: size.width, y: size.height)
            transform = transform.rotated(by: .pi)
        case .left, .leftMirrored:
            transform = transform.translatedBy(x: size.width, y: 0)
            transform = transform.rotated(by: .pi/2)
        case .right, .rightMirrored:
            transform = transform.translatedBy(x: 0, y: size.height)
            transform = transform.rotated(by: -.pi/2)
        case .up, .upMirrored:
            break
        @unknown default:
            break
        }
        
        guard let cgImage = self.cgImage else { return self }
        
        let context = CGContext(data: nil,
                              width: Int(size.width),
                              height: Int(size.height),
                              bitsPerComponent: cgImage.bitsPerComponent,
                              bytesPerRow: 0,
                              space: cgImage.colorSpace!,
                              bitmapInfo: cgImage.bitmapInfo.rawValue)!
        
        context.concatenate(transform)
        
        switch imageOrientation {
        case .left, .leftMirrored, .right, .rightMirrored:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.height, height: size.width))
        default:
            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: size.width, height: size.height))
        }
        
        guard let newCGImage = context.makeImage() else { return self }
        return UIImage(cgImage: newCGImage)
    }
}





// ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            VStack(alignment: .leading, spacing: 12) {
                TrueFalseButton(
                    title: "True",
                    isSelected: selectedAnswer?.lowercased() == "true",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "true"
                }
                
                TrueFalseButton(
                    title: "False",
                    isSelected: selectedAnswer?.lowercased() == "false",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "false"
                }
            }
            
            // Answer Result
            if showExplanation {
                HStack {
                    if let isCorrect = isCorrect {
                        HStack {
                            Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect ? .green : .red)
                            
                            Text(isCorrect ? "Correct!" : "Incorrect")
                                .foregroundColor(isCorrect ? .green : .red)
                                .fontWeight(.semibold)
                        }
                        .padding(.vertical, 4)
                        
                        Spacer()
                        
                    }
                }
                
                // Show correct answer if wrong
                if let isCorrect = isCorrect, !isCorrect {
                    Text("Answer: \(question.correctAnswer)")
                        .font(.subheadline)
                        .foregroundColor(.blue)
                        .padding(.vertical, 4)
                }
            }
            
            // Explanation Section
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}

// TrueFalseButton Íµ¨Ï°∞Ï≤¥Îäî Î≥ÄÍ≤Ω ÏóÜÏùå
struct TrueFalseButton: View {
    let title: String
    let isSelected: Bool
    let disabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .disabled(disabled)
    }
}


// ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            // ÏßàÎ¨∏ ÌÖçÏä§Ìä∏
            Text(question.question)
                .font(.title3)
                .fontWeight(.bold)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 16)
            
            // ÏÑ†ÌÉùÏßÄ
            VStack(spacing: 16) {
                ForEach(question.options, id: \.self) { option in
                    Button(action: { selectedAnswer = option }) {
                        HStack {
                            Text(option)
                                .font(.body)
                                .fontWeight(.medium)
                                .multilineTextAlignment(.leading)
                                .foregroundColor(getTextColor(for: option))
                            Spacer()
                            if selectedAnswer == option && showExplanation {
                                Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                    .foregroundColor(isCorrect == true ? .green : .red)
                                    .imageScale(.large)
                                    .transition(.scale.combined(with: .opacity))
                            }
                        }
                        .padding(.vertical, 16)
                        .padding(.horizontal, 20)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(getBackgroundColor(for: option))
                                .shadow(color: Color.black.opacity(0.05),
                                       radius: 4, x: 0, y: 2)
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    .disabled(showExplanation)
                }
            }
        }
        .padding()
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.15)
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.15)
            }
        }
        // Í∏∞Î≥∏ Î∞∞Í≤ΩÏÉâÏùÑ Ï°∞Í∏à Îçî Î™ÖÌôïÌïòÍ≤å Íµ¨Î∂Ñ
        return Color(UIColor.systemGray6)
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue
            } else {
                return isCorrect == true ? .green : .red
            }
        }
        return .primary
    }
}


// ./AISnapStudy/Views/Question/Sections/EducationLevelSection.swift


import SwiftUI

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education Level") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionTypesSection.swift


import SwiftUI

// Question Type Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Type") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "True/False",
                    count: $viewModel.trueFalseCount
                )
                
            }
        }
    }
}


// ./AISnapStudy/Views/Question/Sections/QuestionAboutSection.swift

import SwiftUI

import SwiftUI

struct QuestionAboutSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @Binding var isTextInputSelected: Bool

    var body: some View {
        VStack(spacing: 16) { // DisclosureGroup Ï†úÍ±∞
            // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ ÏòµÏÖò Ïπ¥Îìú
            HStack(spacing: 12) {
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.takePhoto() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            isTextInputSelected = false
                            Task { await viewModel.selectFromGallery() }
                        }
                    }
                )

                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        isTextInputSelected.toggle()
                        viewModel.toggleTextInput()
                    }
                )
            }
            .padding(.horizontal)

            // üü¢ useTextExtraction ÌÜ†Í∏Ä Ï∂îÍ∞Ä
            Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                .padding(.horizontal)
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("üì± useTextExtraction changed to: \(newValue)")
                }

            // ÌÖçÏä§Ìä∏ ÏûÖÎ†• ÌïÑÎìú
            if viewModel.isTextInputActive {
                TextField("Enter your question here...", text: $viewModel.questionText)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
            }

            // ÏÑ†ÌÉùÌïú Ïù¥ÎØ∏ÏßÄ ÌëúÏãú
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                            SelectedImageCell(
                                image: viewModel.selectedImages[index],
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .listRowSpacing(0)
    }
}


// ./AISnapStudy/Views/Question/Sections/DifficultySection.swift

import SwiftUI

// Difficulty Section
struct DifficultySection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Difficulty Level") {
            Picker("Difficulty", selection: $viewModel.difficulty) {
                ForEach(Difficulty.allCases, id: \.self) { difficulty in
                    Text(difficulty.rawValue.capitalized)
                        .tag(difficulty)
                }
            }
            .pickerStyle(.segmented)
        }
    }
}



// ./AISnapStudy/Views/Question/Sections/LearningSubjectSection.swift

import SwiftUI

struct LearningSubjectSection: View {
   @Binding var selectedSubject: Subject
   
   let columns = [
       GridItem(.flexible()),
       GridItem(.flexible()),
       GridItem(.flexible())
   ]
   
   var body: some View {
       LazyVGrid(columns: columns, spacing: 12) {
           ForEach(Subject.allCases, id: \.self) { subject in
               SubjectSelectionButton(
                   subject: subject,
                   isSelected: selectedSubject == subject
               ) {
                   withAnimation(.spring()) {
                       selectedSubject = subject
                   }
               }
           }
       }
       .padding(.vertical, 8)
   }
}



// ./AISnapStudy/Views/Components/DifficultySelector.swift


import SwiftUI

struct DifficultySelector: View {
    @Binding var selectedDifficulty: Difficulty
    
    var body: some View {
        HStack(spacing: 12) {
            ForEach(Difficulty.allCases, id: \.self) { difficulty in
                DifficultyButton(
                    difficulty: difficulty,
                    isSelected: selectedDifficulty == difficulty,
                    action: { selectedDifficulty = difficulty }
                )
            }
        }
        .padding(.horizontal)
    }
}

// Î≥ÑÎèÑÏùò Î≤ÑÌäº Ïª¥Ìè¨ÎÑåÌä∏Î°ú Î∂ÑÎ¶¨
private struct DifficultyButton: View {
    let difficulty: Difficulty
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack {
                Image(systemName: difficulty.iconName)
                    .font(.system(size: 24))
                Text(difficulty.displayName)
                    .font(.caption)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .background(backgroundColor)
            .foregroundColor(foregroundColor)
        }
    }
    
    private var backgroundColor: some View {
        RoundedRectangle(cornerRadius: 10)
            .fill(isSelected ? Color.accentColor : Color.secondaryBackground)
    }
    
    private var foregroundColor: Color {
        isSelected ? .white : .primary
    }
}



// ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // ÏÉÅÎã® Ìó§Îçî
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // ÌÉúÍ∑∏ Î™©Î°ù (ÏûëÍ≥† Í∞ÑÍ≤∞ÌïòÍ≤å)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // ÏµúÎåÄ 3Í∞úÏùò ÌÉúÍ∑∏Îßå ÌëúÏãú
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // Ï†ïÎ≥¥ Í∑∏Î¶¨Îìú
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
                InfoRow(title: "Difficulty", value: problemSet.difficulty.rawValue)
            }
            .font(.footnote)
            
            // ÏÑ§Î™Ö (Îçî ÏßßÍ≤å)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



// ./AISnapStudy/Views/Components/SpeedUpSection.swift


import SwiftUI

struct SpeedUpSection: View {
    @Binding var useTextExtraction: Bool
    @State private var isExpanded: Bool = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                Text("Automatically extracts text from images to generate questions faster. Recommended when images contain mostly text.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding(.vertical, 8)
            },
            label: {
                HStack {
                    Image(systemName: "bolt.fill")
                        .foregroundColor(.yellow)
                    Text("Speed Up Processing")
                        .font(.headline)
                    Spacer()
                    Toggle("", isOn: $useTextExtraction)
                        .labelsHidden()
                }
            }
        )
    }
}


// ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/LanguageButton.swift

import SwiftUI

// Add new supporting view for Language Button
struct LanguageButton: View {
    let language: Language
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 6) {
                Text(emoji(for: language))
                    .font(.title2)
                Text(displayName(for: language))
                    .font(.caption)
                    .foregroundColor(isSelected ? .white : .primary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.blue : Color.gray.opacity(0.1))
            )
        }
    }
    
    private func emoji(for language: Language) -> String {
        switch language {
        case .auto: return "üåê"
        case .english: return "üá∫üá∏"
        case .korean: return "üá∞üá∑"
        case .japanese: return "üáØüáµ"
        case .chinese: return "üá®üá≥"
        case .spanish: return "üá™üá∏"
        case .french: return "üá´üá∑"
        case .german: return "üá©üá™"
        case .russian: return "üá∑üá∫"
        case .italian: return "üáÆüáπ"
        }
    }
    
    private func displayName(for language: Language) -> String {
        switch language {
        case .auto: return "Auto"
        default: return language.rawValue
        }
    }
}



struct LanguageSection: View {
    @Binding var selectedLanguage: Language
    @State private var isExpanded: Bool = false
    @State private var showLanguageMenu = false
    
    var body: some View {
        DisclosureGroup(
            isExpanded: $isExpanded,
            content: {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Choose the language in which you want the questions to be generated. The generated questions will appear in your selected language regardless of the input language.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.vertical, 8)
                        
                    Text("Current: \(selectedLanguage.displayName) \(selectedLanguage.emoji)")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            },
            label: {
                HStack {
                    HStack {
                        Image(systemName: "globe")
                            .foregroundColor(.blue)
                        Text("Question Language")
                            .font(.headline)
                    }
                    
                    Spacer()
                    
                    // Î≥ÑÎèÑÏùò Î≤ÑÌäºÏúºÎ°ú Î∂ÑÎ¶¨
                    Button(action: {
                        showLanguageMenu = true
                    }) {
                        HStack(spacing: 4) {
                            Text(selectedLanguage.emoji)
                            Image(systemName: "chevron.down")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
            }
        )
        .sheet(isPresented: $showLanguageMenu) {
            LanguageSelectionView(selectedLanguage: $selectedLanguage)
        }
    }
}

// LanguageSelectionViewÎäî Îçî ÍπîÎÅîÌïú UIÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
struct LanguageSelectionView: View {
    @Binding var selectedLanguage: Language
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            List {
                ForEach(Language.allCases) { language in
                    LanguageRow(
                        language: language,
                        isSelected: language == selectedLanguage,
                        onSelect: {
                            selectedLanguage = language
                            UserDefaults.standard.set(language.rawValue, forKey: "selectedLanguage")
                            dismiss()
                        }
                    )
                }
            }
            .navigationTitle("Select Language")
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
        }
        .presentationDetents([.medium, .large])
    }
}

// Î≥ÑÎèÑÏùò LanguageRow Ïª¥Ìè¨ÎÑåÌä∏
struct LanguageRow: View {
    let language: Language
    let isSelected: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack(spacing: 12) {
                Text(language.emoji)
                    .font(.title3)
                
                VStack(alignment: .leading) {
                    Text(language.displayName)
                        .foregroundColor(.primary)
                    Text(language.description)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if isSelected {
                    Image(systemName: "checkmark")
                        .foregroundColor(.blue)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}


// Language.swift (ÏÉàÎ°úÏö¥ ÌååÏùº)
enum Language: String, CaseIterable, Identifiable {
    case auto = "AUTO"
    case english = "ENGLISH"
    case korean = "ÌïúÍµ≠Ïñ¥"
    case japanese = "Êó•Êú¨Ë™û"
    case chinese = "‰∏≠Êñá"
    case spanish = "ESPA√ëOL"
    case french = "FRAN√áAIS"
    case german = "DEUTSCH"
    case russian = "–†–£–°–°–ö–ò–ô"
    case italian = "ITALIANO"
    
    var id: String { self.rawValue }
    
    // OpenAI APIÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïñ∏Ïñ¥ ÏΩîÎìú
    var languageCode: String {
        switch self {
        case .auto: return "auto"
        case .english: return "en"
        case .korean: return "ko"
        case .japanese: return "ja"
        case .chinese: return "zh"
        case .spanish: return "es"
        case .french: return "fr"
        case .german: return "de"
        case .russian: return "ru"
        case .italian: return "it"
        }
    }
}

// Update Language enum to include display names and emojis
extension Language {
    var displayName: String {
        switch self {
        case .auto: return "Automatic"
        case .english: return "English"
        case .korean: return "ÌïúÍµ≠Ïñ¥"
        case .japanese: return "Êó•Êú¨Ë™û"
        case .chinese: return "‰∏≠Êñá"
        case .spanish: return "Espa√±ol"
        case .french: return "Fran√ßais"
        case .german: return "Deutsch"
        case .russian: return "–†—É—Å—Å–∫–∏–π"
        case .italian: return "Italiano"
        }
    }
    
    var emoji: String {
        switch self {
        case .auto: return "üåê"
        case .english: return "üá∫üá∏"
        case .korean: return "üá∞üá∑"
        case .japanese: return "üáØüáµ"
        case .chinese: return "üá®üá≥"
        case .spanish: return "üá™üá∏"
        case .french: return "üá´üá∑"
        case .german: return "üá©üá™"
        case .russian: return "üá∑üá∫"
        case .italian: return "üáÆüáπ"
        }
    }
}

extension Language {
    var description: String {
        switch self {
        case .auto:
            return "Detect language automatically"
        case .english:
            return "English"
        case .korean:
            return "ÌïúÍµ≠Ïñ¥ (Korean)"
        case .japanese:
            return "Êó•Êú¨Ë™û (Japanese)"
        case .chinese:
            return "‰∏≠Êñá (Chinese)"
        case .spanish:
            return "Espa√±ol (Spanish)"
        case .french:
            return "Fran√ßais (French)"
        case .german:
            return "Deutsch (German)"
        case .russian:
            return "–†—É—Å—Å–∫–∏–π (Russian)"
        case .italian:
            return "Italiano (Italian)"
        }
    }
}


// ./AISnapStudy/Views/Components/ReviewProblemSetCard.swift

import SwiftUI

struct ReviewProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                    .font(.headline)
                    .foregroundColor(.primary)
                Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
            if problemSet.isFavorite {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
            }
        }
        .padding(10)
        .background(RoundedRectangle(cornerRadius: 8)
                        .fill(Color(UIColor.systemBackground))
                        .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1))
        .padding(.vertical, 4)
    }
}


// ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search Review...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
                
                Text(question.difficulty.rawValue.capitalized)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


// ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


// ./AISnapStudy/Views/Components/ImageSelectionSection.swift



import SwiftUI
import PhotosUI
import UIKit

struct ImageSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    @FocusState private var isTextFieldFocused: Bool
    @State private var keyboardHeight: CGFloat = 0
  
    var body: some View {
        VStack(spacing: 16) {
            // Quick Text Mode Toggle
            Group {
                VStack(alignment: .leading, spacing: 8) {
                    Toggle("SpeedUp", isOn: $viewModel.useTextExtraction)
                        .padding()
                        .onAppear {
                            print("üîÑ Toggle initialized with: \(viewModel.useTextExtraction)")
                        }

                    VStack(alignment: .leading, spacing: 4) {
                        HStack {
                            Text("Quick Text Mode")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            if viewModel.useTextExtraction {
                                Image(systemName: "bolt.fill")
                                    .foregroundColor(.yellow)
                                    .imageScale(.small)
                            }
                        }
                        Text("Extracts text for faster processing")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .toggleStyle(SwitchToggleStyle(tint: .blue))
                .onChange(of: viewModel.useTextExtraction) { newValue in
                    print("üì± Quick Text Mode changed to: \(newValue)")
                }
            }
            .padding(.horizontal)

            Divider()

            // Input Type Selection Buttons
            HStack(spacing: 12) {
                // Camera Button
                ImageOptionCard(
                    icon: "camera.fill",
                    isUsed: viewModel.hasSelectedCamera,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.takePhoto()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Gallery Button
                ImageOptionCard(
                    icon: "photo.fill",
                    isUsed: viewModel.hasSelectedGallery,
                    isDisabled: !viewModel.canUseImageInput,
                    action: {
                        if viewModel.canUseImageInput {
                            viewModel.isTextInputActive = false
                            isTextFieldFocused = false
                            viewModel.onImageOptionSelected()
                            Task {
                                await viewModel.selectFromGallery()
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)

                // Text Input Button
                ImageOptionCard(
                    icon: "text.bubble.fill",
                    isUsed: viewModel.isTextInputActive,
                    isDisabled: !viewModel.canUseTextInput,
                    action: {
                        if viewModel.canUseTextInput {
                            viewModel.onImageOptionSelected()
                            viewModel.toggleTextInput()
                            if viewModel.isTextInputActive {
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    isTextFieldFocused = true
                                }
                            } else {
                                isTextFieldFocused = false
                            }
                        }
                    }
                )
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal)

            // Text Input Field
            if viewModel.isTextInputActive {
                VStack(spacing: 12) {
                    TextField("Enter your question here...", text: $viewModel.questionText)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .focused($isTextFieldFocused)
                }
                .padding(.horizontal)
            }

            // Selected Images Display
            if !viewModel.selectedImages.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(Array(zip(viewModel.selectedImages.indices, viewModel.selectedImages)), id: \.0) { index, image in
                            let imageId = viewModel.getImageId(for: image)
                            SelectedImageCell(
                                image: image,
                                isLoading: viewModel.isLoadingTexts[imageId] ?? false,
                                extractionStatus: viewModel.extractionStatus[imageId],
                                extractedText: viewModel.extractedTexts[imageId],
                                showExtractedText: viewModel.useTextExtraction,
                                onDelete: {
                                    viewModel.removeImage(at: index)
                                }
                            )
                        }
                    }
                    .padding(.horizontal)
                }
            }

            // Generate Button for Selected Content
            if !viewModel.selectedImages.isEmpty || !viewModel.questionText.isEmpty {
                Button {
                    Task {
                        await viewModel.sendAllImages()
                    }
                } label: {
                    HStack {
                        Spacer()
                        Image(systemName: "sparkles")
                        Text("Generate Questions")
                            .fontWeight(.semibold)
                        Spacer()
                    }
                    .font(.headline)
                    .foregroundColor(.white)
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(viewModel.isLoading ? Color.gray : Color.green)
                    )
                    .animation(.easeInOut, value: viewModel.isLoading)
                }
                .buttonStyle(BorderlessButtonStyle())
                .disabled(viewModel.isLoading)
                .padding(.horizontal)
            }
        }
    }
}



// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
   let icon: String
   let isUsed: Bool
   let isDisabled: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 12) {
               Image(systemName: icon)
                   .font(.system(size: 30))
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 20)
           .foregroundColor(foregroundColor)
           .background(
               RoundedRectangle(cornerRadius: 12)
                   .fill(backgroundColor)
           )
           .overlay(
               RoundedRectangle(cornerRadius: 12)
                   .stroke(strokeColor, lineWidth: 1)
           )
       }
       .disabled(isDisabled)
       .buttonStyle(PlainButtonStyle())
   }
   
   private var foregroundColor: Color {
       if isDisabled {
           return .gray.opacity(0.5)
       }
       return isUsed ? .green : .gray
   }
   
   private var backgroundColor: Color {
       if isDisabled {
           return Color.gray.opacity(0.1)
       }
       return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
   }
   
   private var strokeColor: Color {
       if isDisabled {
           return .clear
       }
       return isUsed ? Color.green.opacity(0.2) : .clear
   }
}

struct SelectedImageCell: View {
    let image: UIImage
    let isLoading: Bool
    let extractionStatus: Bool?
    let extractedText: String?
    let showExtractedText: Bool
    let onDelete: () -> Void
    
    init(
        image: UIImage,
        isLoading: Bool = false,
        extractionStatus: Bool? = nil,
        extractedText: String? = nil,
        showExtractedText: Bool = false,
        onDelete: @escaping () -> Void
    ) {
        self.image = image
        self.isLoading = isLoading
        self.extractionStatus = extractionStatus
        self.extractedText = extractedText
        self.showExtractedText = showExtractedText
        self.onDelete = onDelete
    }
    
    var body: some View {
        ZStack(alignment: .topTrailing) {
            VStack(alignment: .leading, spacing: 4) {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .frame(width: 100, height: 100)
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                    )
                
                if showExtractedText {
                    if isLoading {
                        HStack(spacing: 4) {
                            ProgressView()
                                .scaleEffect(0.7)
                            Text("Extracting text...")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                    } else if let status = extractionStatus {
                        HStack(spacing: 4) {
                            Image(systemName: status ? "doc.text.fill" : "exclamationmark.triangle.fill")
                                .foregroundColor(status ? .green : .orange)
                                .imageScale(.small)
                            Text(status ? "Text extracted" : "Extraction failed")
                                .font(.caption2)
                                .foregroundColor(status ? .green : .orange)
                        }
                    }
                }
            }
            
            Button(action: onDelete) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 22))
                    .foregroundColor(.white)
                    .background(
                        Circle()
                            .fill(Color.black.opacity(0.5))
                            .frame(width: 24, height: 24)
                    )
            }
            .offset(x: 6, y: -6)
        }
    }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


// ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


// ./AISnapStudy/Views/Components/ReviewCard.swift



import SwiftUI

struct ReviewCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


// ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Subject and Difficulty Tags
            HStack {
                Text(question.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .foregroundColor(question.subject.color)
                    .cornerRadius(8)
                
                Spacer()
                
                Text(question.difficulty.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.difficulty.color.opacity(0.2))
                    .foregroundColor(question.difficulty.color)
                    .cornerRadius(8)
            }
            
            // Question Type
            Text(question.type.rawValue.replacingOccurrences(of: "_", with: " ").capitalized)
                .font(.caption)
                .foregroundColor(.secondary)
            
            // Question Text
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .padding(.vertical, 4)
            
            // Footer
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Image(systemName: "arrow.right.circle.fill")
                    .foregroundColor(.blue)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2)
        )
    }
}

#Preview {
    SavedQuestionCard(question: Question(
        id: UUID().uuidString,
        type: .multipleChoice,
        subject: .math,
        difficulty: .medium,
        question: "Sample Question",
        options: ["A", "B", "C", "D"],
        correctAnswer: "A",
        explanation: "Sample explanation",
        hint: "Sample hint",
        isSaved: true,
        createdAt: Date()
    ))
    .padding()
}


// ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


// ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // Í∞Å Î≤ÑÌäºÏóê ÎåÄÌïú Î≥ÑÎèÑÏùò Ïï°ÏÖò Ï†ïÏùò
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // Ï§ëÏöî: Î≤ÑÌäº Ïä§ÌÉÄÏùº Î∂ÑÎ¶¨
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // Ï§ëÏöî: Î≤ÑÌäº Ïä§ÌÉÄÏùº Î∂ÑÎ¶¨
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


// ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @StateObject private var studyViewModel: StudyViewModel
    @State private var selectedTab = 0
    @StateObject private var statViewModel: StatViewModel
    
    
    init() {
        let homeVM = HomeViewModel.shared
        
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        
        // StudyViewModel Ï¥àÍ∏∞Ìôî ÏãúÏ†ê Î≥ÄÍ≤Ω
        let studyVM = StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        )
        self._studyViewModel = StateObject(wrappedValue: studyVM)
        
        let statVM = StatViewModel(
            context: CoreDataService.shared.viewContext,
            homeViewModel: homeVM,
            studyViewModel: studyVM
        )
        
        // StatViewModelÎèÑ studyViewModel Ï∞∏Ï°∞ Ï∂îÍ∞Ä
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
             context: CoreDataService.shared.viewContext,
             homeViewModel: homeVM,  // homeViewModel Ï†ÑÎã¨
             studyViewModel: studyVM // studyViewModel Ï†ÑÎã¨
         ))
        
        
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
        
        // homeViewModelÏóê studyViewModel ÏÑ§Ï†ï
        homeVM.setStudyViewModel(studyVM)
        
        // StatViewModelÏùÑ StudyViewModelÏóê Ïó∞Í≤∞
        studyVM.setStatViewModel(statVM)
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            if let problemSet = homeViewModel.selectedProblemSet {
                StudyView(
                    questions: problemSet.questions,
                    studyViewModel: studyViewModel,
                    selectedTab: $selectedTab
                )
                .tabItem {
                    Label("Study", systemImage: "book.fill")
                }
                .tag(1)
            } else {
                Text("No Problem Set Selected")
                    .tabItem {
                        Label("Study", systemImage: "book.fill")
                    }
                    .tag(1)
            }
            
            ReviewView()
                .tabItem {
                    Label("Review", systemImage: "clock.fill")
                }
                .tag(2)
            
            StatView(
                correctAnswers: homeViewModel.correctAnswers,
                totalQuestions: homeViewModel.totalQuestions,
                viewModel: statViewModel,
                selectedTab: $selectedTab
            )
            .tabItem {
                Label("Stats", systemImage: "chart.bar.fill")
            }
            .tag(3)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { _ in
            if selectedTab == 1 {
                if let problemSet = homeViewModel.selectedProblemSet {
                    studyViewModel.loadQuestions(problemSet.questions)
                }
            }
        }
        .environmentObject(homeViewModel)
    }
}


// ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData

struct StatView: View {
    @ObservedObject var viewModel: StatViewModel
    @Binding var selectedTab: Int
    
    let correctAnswers: Int
    let totalQuestions: Int
    
    
    @EnvironmentObject private var homeViewModel: HomeViewModel
    
    
    init(correctAnswers: Int,
         totalQuestions: Int,
         viewModel: StatViewModel, // Pass viewModel directly
         selectedTab: Binding<Int>) {
        self.correctAnswers = correctAnswers
        self.totalQuestions = totalQuestions
        self.viewModel = viewModel // Direct assignment without StateObject
        self._selectedTab = selectedTab
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                Text("ÌïôÏäµ ÌÜµÍ≥Ñ")
                    .font(.title)
                    .padding(.top)
                
                // ÌòÑÏû¨ Ïä§Ìä∏Î¶≠
                HStack {
                    VStack(alignment: .leading) {
                        Text("ÌòÑÏû¨ Ïä§Ìä∏Î¶≠")
                            .font(.headline)
                        Text("\(viewModel.streak)Ïùº")
                            .font(.title)
                            .foregroundColor(.blue)
                    }
                    Spacer()
                    Image(systemName: "flame.fill")
                        .font(.system(size: 40))
                        .foregroundColor(.orange)
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
                
                // ÌÜµÍ≥Ñ Í∑∏Î¶¨Îìú
                LazyVGrid(columns: [
                    GridItem(.flexible()),
                    GridItem(.flexible())
                ], spacing: 20) {
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 20) {
                        StatCard(
                            title: "Ï¥ù Ï†êÏàò",
                            value: "\(viewModel.correctAnswers * 10)Ï†ê",  // ÎßûÏùÄ Í∞úÏàò * 10Ï†ê
                            icon: "star.fill",
                            color: .yellow
                        )
                        
                        StatCard(
                            title: "Ï†ïÎãµÎ•†",
                            value: String(format: "%.1f%%", viewModel.accuracyRate),
                            icon: "percent",
                            color: .blue
                        )
                        
                        StatCard(title: "ÏôÑÎ£åÌïú Î¨∏Ï†ú",
                                 value: "\(viewModel.completedQuestions)Í∞ú",
                                 icon: "checkmark.circle.fill",
                                 color: .green)
                        StatCard(title: "Ï†ïÎãµ Ïàò",
                                 value: "\(viewModel.correctAnswers)Í∞ú",
                                 icon: "target",
                                 color: .red)
                    }
                    .padding()
                    
                    // Îã§Ïãú ÌíÄÍ∏∞ Î≤ÑÌäº
                    Button(action: {
                        // Î®ºÏ†Ä ÏÉÅÌÉú Î¶¨ÏÖã
                        viewModel.resetProgress()
                        
                        // Study ViewÎ°ú Ï†ÑÌôòÌïòÍ∏∞ ÏßÅÏ†Ñ ÏÉÅÌÉú ÌôïÏù∏ÏùÑ ÏúÑÌï¥ viewModelÏóêÏÑú Î°úÍ∑∏ Ï∂úÎ†•
                        viewModel.logCurrentQuestionState()
                        
                        // Î∞îÎ°ú Study ÌÉ≠ÏúºÎ°ú Ïù¥Îèô
                        withAnimation {
                            selectedTab = 1
                        }
                    }) {
                        Text("Îã§Ïãú ÌíÄÍ∏∞")
                            .font(.headline)
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(10)
                    }
                    .padding()
                }
            }
        }
    }
}


// ./AISnapStudy/Views/Main/ProfileView.swift

//
//import SwiftUI
//
//struct ProfileView: View {
//    @State private var showingEditProfile = false
//    @StateObject private var viewModel = ProfileViewModel()
//    
//    var body: some View {
//        NavigationView {
//            List {
//                // Profile Section
//                Section {
//                    HStack {
//                        Image(systemName: "person.circle.fill")
//                            .resizable()
//                            .frame(width: 60, height: 60)
//                            .foregroundColor(.accentColor)
//                        
//                        VStack(alignment: .leading) {
//                            Text(viewModel.user.name)
//                                .font(.headline)
//                            Text(viewModel.user.email)
//                                .font(.subheadline)
//                                .foregroundColor(.secondary)
//                        }
//                    }
//                    .padding(.vertical, 8)
//                }
//                
//                // Settings Section
//                Section("Settings") {
//                    Toggle("Dark Mode", isOn: $viewModel.isDarkMode)
//                    Toggle("Notifications", isOn: $viewModel.notificationsEnabled)
//                    
//                    NavigationLink("Study Preferences") {
//                        StudyPreferencesView()
//                    }
//                }
//                
//                // App Info Section
//                Section("App Info") {
//                    HStack {
//                        Text("Version")
//                        Spacer()
//                        Text(Bundle.main.appVersion)
//                            .foregroundColor(.secondary)
//                    }
//                    
//                    Button("Terms of Service") {
//                        viewModel.showTerms()
//                    }
//                    
//                    Button("Privacy Policy") {
//                        viewModel.showPrivacyPolicy()
//                    }
//                }
//                
//                // Account Actions
//                Section {
//                    Button("Sign Out", role: .destructive) {
//                        viewModel.signOut()
//                    }
//                }
//            }
//            .navigationTitle("Profile")
//            .toolbar {
//                ToolbarItem(placement: .navigationBarTrailing) {
//                    Button("Edit") {
//                        showingEditProfile = true
//                    }
//                }
//            }
//            .sheet(isPresented: $showingEditProfile) {
//                EditProfileView()
//            }
//        }
//    }
//}


// ./AISnapStudy/Views/Main/HomeView.swift

// File: ./AISnapStudy/Views/Main/HomeView.swift

import SwiftUI
import Combine
import CoreData

struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Environment(\.managedObjectContext) private var context
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var selectedSubject: Subject = .math
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Create New Questions Button
                    MainActionButton(
                        title: "Create New Questions",
                        icon: "plus.circle.fill"
                    ) {
                        selectedSubject = .math // Default subject
                        showQuestionSettings = true
                    }
                    
                    // Review Questions Button
                    MainActionButton(
                        title: "Review Questions",
                        icon: "book.fill"
                    ) {
                        if let problemSet = viewModel.selectedProblemSet {
                            viewModel.setSelectedProblemSet(problemSet)
                            selectedTab = 1
                        }
                    }
                    .disabled(viewModel.selectedProblemSet == nil)
                    .opacity(viewModel.selectedProblemSet == nil ? 0.5 : 1)
                }
                .padding(.horizontal)
                .padding(.vertical, 32)
            }
            .navigationTitle("Home")
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab  // selectedTab Î∞îÏù∏Îî© Ï†ÑÎã¨
            )
        }
    }
}


// ./AISnapStudy/Views/Main/ReviewView.swift

import SwiftUI

struct ReviewView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var viewModel: ReviewViewModel
    @State private var searchText = ""
    
    init() {
        let vm = ReviewViewModel(homeViewModel: HomeViewModel.shared)
        self._viewModel = StateObject(wrappedValue: vm)
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                SearchBar(text: $searchText)
                    .padding(.horizontal)
                
                List {
                    // Saved Questions Section
                    Section(header: Text("Saved Questions")) {
                        NavigationLink(
                            destination: SavedQuestionsView(
                                questions: viewModel.savedQuestions,
                                homeViewModel: homeViewModel
                            )
                        ) {
                            HStack {
                                Image(systemName: "bookmark.fill")
                                    .foregroundColor(.blue)
                                Text("Saved Questions")
                                    .font(.headline)
                                Spacer()
                                Text("\(viewModel.savedQuestions.count)")
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    
                    // Subject folders
                    ForEach(Subject.allCases, id: \.self) { subject in
                        NavigationLink(
                            destination: ProblemSetsListView(
                                subject: subject,
                                problemSets: filteredAndSortedProblemSets(for: subject)
                            )
                        ) {
                            HStack {
                                Image(systemName: "folder.fill")
                                    .foregroundColor(.blue)
                                Text(subject.displayName)
                                    .font(.headline)
                                    .padding(.leading, 8)
                            }
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())
                .navigationTitle("Review")
                .navigationBarTitleDisplayMode(.inline)  // Ïù¥ Ï§ÑÏùÑ Ï∂îÍ∞Ä
                .refreshable {
                    viewModel.refreshData()
                }
            }
        }
        .onAppear {
                    viewModel.setHomeViewModel(homeViewModel)
                }
    }
    
    var problemSets: [ProblemSet] {
        homeViewModel.problemSets
    }
    
    // SubjectÎ≥ÑÎ°ú Problem Sets ÌïÑÌÑ∞ÎßÅ Î∞è Ï†ïÎ†¨ÌïòÎäî Î©îÏÑúÎìú
    private func filteredAndSortedProblemSets(for subject: Subject) -> [ProblemSet] {
        return viewModel.problemSets
            .filter { $0.subject == subject }
            .sorted(by: { $0.createdAt > $1.createdAt })
    }
}

struct SavedQuestionsView: View {
    let questions: [Question]
    let homeViewModel: HomeViewModel
    @State private var showStudyView = false
    
    var body: some View {
        List(questions) { question in
            SavedQuestionCard(question: question)
                .onTapGesture {
                    // Create a temporary ProblemSet for the saved question
                    let problemSet = ProblemSet(
                        id: UUID().uuidString,
                        subject: question.subject,
                        difficulty: question.difficulty,
                        questions: [question],
                        createdAt: Date(),
                        educationLevel: .elementary,
                        name: "Saved Question"
                    )
                    homeViewModel.setSelectedProblemSet(problemSet)
                    showStudyView = true
                }
        }
        .navigationTitle("Saved Questions")
        .background(
            NavigationLink(
                isActive: $showStudyView,
                destination: {
                    if let studyViewModel = homeViewModel.studyViewModel {
                        StudyView(
                            questions: [questions[0]],
                            studyViewModel: studyViewModel,
                            selectedTab: .constant(1)
                        )
                    }
                },
                label: { EmptyView() }
            )
        )
    }
}

struct ProblemSetsListView: View {
    let subject: Subject
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var isShowingStudyView = false
    
    var body: some View {
        List(problemSets) { problemSet in
            Button(action: {
                homeViewModel.setSelectedProblemSet(problemSet)
                isShowingStudyView = true
            }) {
                ReviewProblemSetCard(problemSet: problemSet)
            }
            .background(
                NavigationLink(
                    isActive: $isShowingStudyView,
                    destination: {
                        guard let studyViewModel = homeViewModel.studyViewModel else {
                            return AnyView(Text("Study ViewModel not available"))
                        }
                        return AnyView(
                            StudyView(
                                questions: problemSet.questions,
                                studyViewModel: studyViewModel,
                                selectedTab: .constant(1)
                            )
                        )
                    }
                ) { EmptyView() }
                .hidden()
            )
        }
        .navigationTitle("\(subject.displayName) Sets")
        .listStyle(InsetGroupedListStyle())
    }
}


// ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
    @State private var isCorrect: Bool? = nil  // Ïù¥ Î∂ÄÎ∂ÑÏù¥ Ï§ëÏöîÌï©ÎãàÎã§
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // Ï∂îÍ∞Ä
   @State private var previewIsCorrect: Bool? = nil        // Ï∂îÍ∞Ä
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
    var body: some View {
        VStack {
            if studyViewModel.isGeneratingQuestions {
                VStack(spacing: 16) {
                    QuestionGeneratingView()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(Color.white)
                        .transition(.opacity)
                    
                    if !studyViewModel.generatedQuestions.isEmpty {
                        ScrollView {
                            LazyVStack(spacing: 12) {
                                ForEach(studyViewModel.generatedQuestions) { question in
                                    QuestionPreviewCard(
                                        question: question,
                                        selectedAnswer: $previewSelectedAnswer,
                                        isCorrect: $previewIsCorrect,
                                        onAnswerSelected: { correct in
                                            print("Answer selected: \(correct)")
                                        }
                                    )
                                    .transition(.slide)
                                }
                            }
                            .padding()
                        }
                    }
                }
            } else {
                VStack {
                    Spacer()
                        .frame(height: 20)
                    
                    ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                               total: Double(studyViewModel.totalQuestions))
                        .progressViewStyle(CustomProgressViewStyle())
                        .padding(.horizontal, 20)
                        .padding(.bottom, 10)
                    
                    Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundColor(.secondary)
                        .padding(.bottom, 20)
                    
                    if !studyViewModel.hasQuestions {
                        Text("No questions available")
                            .font(.title3)
                            .foregroundColor(.gray)
                    } else {
                        ScrollView {
                            VStack(alignment: .leading, spacing: 20) {
                                if let currentQuestion = studyViewModel.currentQuestion {
                                    switch currentQuestion.type {
                                    case .multipleChoice:
                                        MultipleChoiceView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect
                                        )
                                        
                                    case .trueFalse:
                                        TrueFalseView(
                                            question: currentQuestion,
                                            selectedAnswer: $studyViewModel.selectedAnswer,
                                            showExplanation: studyViewModel.showExplanation,
                                            isCorrect: isCorrect  // Ïó¨Í∏∞ isCorrect Î∞îÏù∏Îî©Ïù¥ Î¨∏Ï†úÏùº Ïàò ÏûàÏäµÎãàÎã§
                                        )
                                    }
                                    
                                    if showExplanation && studyViewModel.showExplanation {
                                        ExplanationView(explanation: currentQuestion.explanation)
                                    }
                                }
                            }
                            .padding()
                        }
                        
                        VStack {
                            Divider()
                            
                            HStack(spacing: 12) {
                                if studyViewModel.showExplanation {
                                    UtilityButtons(
                                        showExplanation: $showExplanation,
                                        isSaved: $isSaved,
                                        studyViewModel: studyViewModel
                                    )
                                }
                                
                                ActionButton(
                                    viewModel: studyViewModel,
                                    selectedTab: $selectedTab,
                                    isCorrect: $isCorrect,
                                    showExplanation: $showExplanation
                                )
                            }
                            .padding()
                            .background(Color(UIColor.systemBackground))
                        }
                    }
                }
            }
        }
        .onAppear {
            if let currentQuestion = studyViewModel.currentQuestion {
                isSaved = currentQuestion.isSaved
            }
        }
        .onChange(of: studyViewModel.currentQuestion) { newQuestion in
            if let question = newQuestion {
                isSaved = question.isSaved
            }
        }
    }
}

struct CustomProgressViewStyle: ProgressViewStyle {
    func makeBody(configuration: Configuration) -> some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 12)
                
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.blue)
                    .frame(width: CGFloat(configuration.fractionCompleted ?? 0) * geometry.size.width,
                           height: 12)
            }
        }
        .frame(height: 12)
    }
}

// ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ÎØ∏Î¶¨Î≥¥Í∏∞ Ïπ¥Îìú Î∑∞
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // ÏÉÅÎã® Ï†ïÎ≥¥
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
              
              Text(question.difficulty.rawValue.capitalized)
                  .font(.caption)
                  .foregroundColor(.secondary)
          }
          
          // ÏßàÎ¨∏
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // ÎãµÎ≥Ä ÏòµÏÖò
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// Í∏∞Ï°¥ Ïª¥Ìè¨ÎÑåÌä∏Îì§ÏùÄ Ïú†ÏßÄ
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil  // Îã§Ïùå Î¨∏Ï†úÎ°ú ÎÑòÏñ¥Í∞à Îïå Î¶¨ÏÖã
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               if let currentQuestion = viewModel.currentQuestion,
                  let selectedAnswer = viewModel.selectedAnswer {
                   isCorrect = currentQuestion.correctAnswer.lowercased() == selectedAnswer.lowercased()
               }
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}



struct QuestionGeneratingView: View {
    @State private var rotation: Double = 0
    @State private var dotScale: CGFloat = 1.0
    @State private var currentTipIndex = 0
    let timer = Timer.publish(every: 3, on: .main, in: .common).autoconnect()
    
    var body: some View {
        VStack(spacing: 30) {
            // Main Animation Circle
            ZStack {
                // Outer rotating circle
                Circle()
                    .stroke(lineWidth: 4)
                    .frame(width: 160, height: 160)
                    .foregroundColor(.blue.opacity(0.3))
                    .rotationEffect(.degrees(rotation))
                
                // Inner gradient circle
                Circle()
                    .stroke(
                        LinearGradient(
                            gradient: Gradient(colors: [.blue, .purple]),
                            startPoint: .top,
                            endPoint: .bottom
                        ),
                        lineWidth: 8
                    )
                    .frame(width: 140, height: 140)
                    .rotationEffect(.degrees(-rotation))
                
                // Center content
                VStack(spacing: 8) {
                    Image(systemName: "sparkles")
                        .font(.system(size: 30))
                        .foregroundColor(.blue)
                    Text("Generating")
                        .font(.headline)
                        .foregroundColor(.primary)
                    Text("Questions")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
            }
            .onAppear {
                withAnimation(
                    .linear(duration: 4)
                    .repeatForever(autoreverses: false)
                ) {
                    rotation = 360
                }
            }
            
            // Animated Dots
            HStack(spacing: 6) {
                ForEach(0..<3) { index in
                    Circle()
                        .fill(Color.blue)
                        .frame(width: 10, height: 10)
                        .scaleEffect(dotScale)
                        .animation(
                            .easeInOut(duration: 0.6)
                            .repeatForever()
                            .delay(Double(index) * 0.2),
                            value: dotScale
                        )
                }
            }
            .onAppear {
                dotScale = 0.5
            }
            
            // Rotating Tips
            VStack(spacing: 12) {
                Text(tips[currentTipIndex])
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                    .frame(height: 50)
                    .transition(.opacity.combined(with: .slide))
                    .id(currentTipIndex)
                    .animation(.easeInOut, value: currentTipIndex)
                
                // Progress Dots
                HStack(spacing: 6) {
                    ForEach(0..<tips.count) { index in
                        Circle()
                            .fill(index == currentTipIndex ? Color.blue : Color.gray)
                            .frame(width: 6, height: 6)
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 15)
                    .fill(Color.blue.opacity(0.1))
            )
        }
        .padding(30)
        .onReceive(timer) { _ in
            withAnimation {
                currentTipIndex = (currentTipIndex + 1) % tips.count
            }
        }
    }
    
    private let tips = [
        "Creating personalized questions just for you...",
        "Analyzing content to ensure the best learning experience...",
        "Getting ready to challenge your knowledge...",
        "Preparing explanations to help you understand better...",
        "Almost there! Your questions are being finalized..."
    ]
}

struct GeneratedQuestionPreviewCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: question.type == .multipleChoice ? "list.bullet.circle.fill" : "checkmark.circle.fill")
                    .foregroundColor(.blue)
                Text(question.type == .multipleChoice ? "Multiple Choice" : "True/False")
                    .font(.caption)
                    .foregroundColor(.blue)
                Spacer()
                Text(question.difficulty.displayName)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .foregroundColor(.primary)
        }
        .padding()
        .background(Color.white)
        .cornerRadius(10)
        .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
    }
}


// ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 512 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.8
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // Ïù¥ÎØ∏ÏßÄÏùò ÌÅ¨Í∏∞Î•º ÏµúÎåÄ ÏπòÏàòÏóê ÎßûÍ≤å Ï°∞Ï†ï
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // ÏÑ§Ï†ïÎêú ÌíàÏßàÎ°ú ÏïïÏ∂ï
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // ÌÅ¨Í∏∞Í∞Ä ÏµúÎåÄ ÌååÏùº ÌÅ¨Í∏∞Î•º Ï¥àÍ≥ºÌïòÎäî Í≤ΩÏö∞, ÌíàÏßàÏùÑ ÎÇÆÏ∂∞ÏÑú Ï∂îÍ∞Ä ÏïïÏ∂ï ÏãúÎèÑ
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera),
                  UIImagePickerController.isCameraDeviceAvailable(.rear) else {
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetailÏùò ÏÑ§Ï†ï Í∞íÏùÑ ÏÇ¨Ïö©
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // ÏòàÏ∏° ÌÜ†ÌÅ∞ Ïàò Í≥ÑÏÇ∞
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        üìä Image Optimization Results:
        ‚Ä¢ Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        ‚Ä¢ Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        ‚Ä¢ Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        ‚Ä¢ Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        ‚Ä¢ Estimated Tokens: \(estimatedTokens)
        ‚Ä¢ Processing Time: \(String(format: "%.3f", processingTime))s
        ‚Ä¢ Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}



// ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
    case fileProviderAccessDenied
    case fileCoordinationFailed
}

public class StorageService {
    // MARK: - Properties
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    private let fileCoordinator = NSFileCoordinator()
    private let fileManager = FileManager.default
    
    // MARK: - Constants
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    private let maxRetryCount = 3
    private let retryDelay: TimeInterval = 0.5
    
    // MARK: - File System
    private var documentDirectory: URL? {
        fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
    }
    
    private func getDirectoryURL(for type: String) -> URL? {
        documentDirectory?.appendingPathComponent(type)
    }
    
    // MARK: - FileProvider Handling
    private func handleFileProviderAccess<T>(_ operation: @escaping (URL) throws -> T) throws -> T {
        guard checkFileProviderAuthorization() else {
            throw StorageError.fileProviderAccessDenied
        }
        
        guard let url = documentDirectory else {
            throw StorageError.invalidData
        }
        
        var coordinationError: NSError?
        var result: T?
        var operationError: Error?
        
        fileCoordinator.coordinate(writingItemAt: url, options: .forMoving, error: &coordinationError) { coordinatedURL in
            do {
                result = try operation(coordinatedURL)
            } catch {
                operationError = error
            }
        }
        
        if let error = coordinationError {
            throw StorageError.fileCoordinationFailed
        }
        
        if let error = operationError {
            throw error
        }
        
        return result!
    }
    
    private func checkFileProviderAuthorization() -> Bool {
        // Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî Ï†ÅÏ†àÌïú Í∂åÌïú Ï≤¥ÌÅ¨ Î°úÏßÅ Íµ¨ÌòÑ
        return true
    }
    
    // MARK: - Error Handling
    private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
        do {
            return try operation()
        } catch let error as NSError {
            Logger.logError(error, category: "FileOperation")
            
            // Ïû¨ÏãúÎèÑ Î°úÏßÅ
            for attempt in 1...maxRetryCount {
                Logger.log("Retrying operation (attempt \(attempt)/\(maxRetryCount))", category: "FileOperation")
                do {
                    return try operation()
                } catch {
                    if attempt == maxRetryCount {
                        throw error
                    }
                    Thread.sleep(forTimeInterval: retryDelay)
                }
            }
            throw error
        }
    }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var problemSets = try self.getProblemSets()
                problemSets.append(problemSet)
                
                let data = try self.encoder.encode(problemSets)
                self.defaults.set(data, forKey: self.problemSetsKey)
            }
        }
    }
    
    public func getProblemSets() throws -> [ProblemSet] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: problemSetsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([ProblemSet].self, from: data)
            } catch {
                Logger.logError(error, category: "ProblemSets")
                throw StorageError.loadFailed
            }
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                sessions.append(session)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: studySessionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([StudySession].self, from: data)
            } catch {
                Logger.logError(error, category: "StudySessions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.deleteFailed }
            
            try self.handleFileOperation {
                var sessions = try self.getStudySessions()
                
                guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
                    throw StorageError.notFound
                }
                
                sessions.remove(at: index)
                
                let data = try self.encoder.encode(sessions)
                self.defaults.set(data, forKey: self.studySessionsKey)
            }
        }
    }
    
    public func saveQuestion(_ question: Question) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                var savedQuestions = try self.getSavedQuestions()
                savedQuestions.append(question)
                
                let data = try self.encoder.encode(savedQuestions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        return try handleFileOperation {
            guard let data = defaults.data(forKey: savedQuestionsKey) else {
                return []
            }
            
            do {
                return try decoder.decode([Question].self, from: data)
            } catch {
                Logger.logError(error, category: "SavedQuestions")
                throw StorageError.loadFailed
            }
        }
    }
    
    public func saveQuestions(_ questions: [Question]) throws {
        try handleFileProviderAccess { [weak self] url in
            guard let self = self else { throw StorageError.saveFailed }
            
            try self.handleFileOperation {
                let data = try self.encoder.encode(questions)
                self.defaults.set(data, forKey: self.savedQuestionsKey)
            }
        }
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("üìù [\(category)] \(message)")
        #endif
    }
    
    static func logError(_ error: Error, category: String) {
        #if DEBUG
        print("‚ùå [\(category)] Error: \(error.localizedDescription)")
        #endif
    }
}


// ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    private let apiKey: String
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    
    static let shared: OpenAIService = {
        do {
            return try OpenAIService()
        } catch {
            fatalError("Failed to initialize OpenAIService: \(error)")
        }
    }()
    
    
    func sendTextExtractionResult(_ extractedText: String) async throws -> String {
        print("üîÑ Processing extracted text in OpenAI service...")
        print("üìù Input text: \(extractedText)")
        
        let url = URL(string: baseURL)!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")

        let body: [String: Any] = [
            "model": "gpt-4o",
            "messages": [
                ["role": "system", "content": "You are an expert at analyzing extracted text."],
                ["role": "user", "content": extractedText]
            ],
            "temperature": 0.7,
            "max_tokens": 2000
        ]

        request.httpBody = try JSONSerialization.data(withJSONObject: body)

        print("üåê Sending request to OpenAI API...")
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            print("‚ùå Invalid response received")
            throw NetworkError.invalidResponse
        }
        
        print("üì° Response status code: \(httpResponse.statusCode)")
        
        guard httpResponse.statusCode == 200 else {
            print("‚ùå API request failed with status code: \(httpResponse.statusCode)")
            throw NetworkError.apiError("API request failed with status \(httpResponse.statusCode)")
        }

        let result = String(data: data, encoding: .utf8) ?? "No response"
        print("‚úÖ OpenAI processing completed: \(result)")
        return result
    }


        func sendImageDataToOpenAI(_ imageData: Data) async throws {
            let url = URL(string: "https://api.openai.com/v1/images")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.addValue("Bearer YOUR_API_KEY", forHTTPHeaderField: "Authorization")

            let body: [String: Any] = [
                "image": imageData.base64EncodedString(),
                "purpose": "image-analysis"
            ]

            request.httpBody = try JSONSerialization.data(withJSONObject: body, options: [])

            let (data, response) = try await URLSession.shared.data(for: request)
            guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                throw NSError(domain: "OpenAIService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to get valid response from OpenAI API"])
            }

            let result = String(data: data, encoding: .utf8) ?? "No response"
            print("‚úÖ Image sent to OpenAI. Response: \(result)")
        }
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public ÏúºÎ°ú Î≥ÄÍ≤Ω
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init Ï∂îÍ∞Ä
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public ÏúºÎ°ú Î≥ÄÍ≤Ω
        let subject: Subject
        let difficulty: Difficulty
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        let language: Language
        
        public init(    // public init Ï∂îÍ∞Ä
            subject: Subject,
            difficulty: Difficulty,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int],
            language: Language
        ) {
            self.subject = subject
            self.difficulty = difficulty
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
            self.language = language
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("‚ùå Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("üì∏ Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("‚ùå Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }
    
    // StreamResponse Íµ¨Ï°∞Ï≤¥ÎèÑ ÌïÑÏöîÌï©ÎãàÎã§
    private struct StreamResponse: Codable {
        struct Choice: Codable {
            struct Delta: Codable {
                let content: String?
            }
            let delta: Delta
        }
        let choices: [Choice]
    }

    // extractCompleteQuestion Ìï®ÏàòÎèÑ Ï∂îÍ∞Ä
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSONÏù¥ ÏôÑÏ†ÑÌïú Í∞ùÏ≤¥Ïù∏ÏßÄ ÌôïÏù∏
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSONÏù¥ ÏïÑÏßÅ ÏôÑÏÑ±ÎêòÏßÄ ÏïäÏïòÍ±∞ÎÇò ÌååÏã±Ìï† Ïàò ÏóÜÎäî Í≤ΩÏö∞
            return nil
        }
    }
    
    // ÎÇòÎ®∏ÏßÄ private Íµ¨Ï°∞Ï≤¥Îì§ÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Initialization
    init() throws {
        self.apiKey = try ConfigurationManager.shared.getValue(for: "OpenAIAPIKey")
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)_\(parameters.difficulty.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("‚úÖ Retrieved questions from cache")
            return cachedQuestions
        }
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // Ïù¥ÎØ∏ÏßÄ ÎòêÎäî ÌÖçÏä§Ìä∏Î•º Ï≤òÎ¶¨ÌïòÎäî ÌÉúÏä§ÌÅ¨ Ï∂îÍ∞Ä
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            let questions = try await self.performQuestionGeneration(
                input: processedInput,                     // Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
                textInput: processedTextInput,             // ÌÖçÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(_ subject: Subject, isImageInput: Bool, educationLevel: EducationLevel, difficulty: Difficulty,     language: Language) -> SubjectPrompt {
        let languageInstruction_text = language == .auto ?
            "Generate questions in the exact same language as the input text" :
            """
            IMPORTANT: You must generate all questions, answers, explanations, and hints in \(language.displayName) (\(language.rawValue)) language.
            DO NOT use the input text's language.
            Even if the input is in a different language, your output must be in \(language.displayName) only.
            """
        
        let languageInstruction_image = language == .auto ?
            "Generate questions in the exact same language as any visible text in the image" :
            """
            IMPORTANT: You must generate all questions, answers, explanations, and hints in \(language.displayName) (\(language.rawValue)) language.
            DO NOT use the input text's language.
            Even if the input text is in a different language, your output must be in \(language.displayName) only.
            """
        
        if isImageInput {
            return SubjectPrompt(
                systemPrompt: """
                   You are an \(subject.displayName) expert creating image-based questions.
                   Must to create self-contained questions that provide all necessary context within each question.
                   
                   STRICT LANGUAGE REQUIREMENT:
                   - Output language: \(language == .auto ? "Same as visible text in input" : language.displayName)
                   - Maintain consistent language throughout all content
                   - Translate concepts from input while maintaining accuracy
                   """,
                
                userPromptTemplate: """
                   Important: \(languageInstruction_image)
                   Create self-contained questions that provide all necessary context within each question.
                   Include detailed explanations and hints.
                   Preserve the original meaning while using \(language == .auto ? "input language" : language.displayName)
                   
                   Example format:
                   BAD: "What does the text explain?"
                   BAD: "what is the title of this image?"
                   GOOD: "In the passage where Jesus described the birds of the air, what characteristics of the birds did he emphasize?"
                   GOOD: "What lesson does the person mentioned in the text want to convey to us through ‚Äòtrying to endure many hardships while worrying about how to repay the mortgaged house price‚Äô"
                   GOOD: Sarah has 12 apples. She gives 5 apples to her friend Emma. Then, she buys 8 more apples from the store.
                   How many apples does Sarah have now?
                   GOOD: Solve for x: 2x^2 - 3x - 5 = 0
                   """
            )
        } else {
            return SubjectPrompt(
                systemPrompt: """
                   You are an \(subject.displayName) expert specializing in creating questions for \(educationLevel.displayName) school students.
                   Must to create self-contained questions that provide all necessary context within each question.
                   Include detailed explanations and hints.
                   
                   STRICT LANGUAGE REQUIREMENT:
                   - Output language: \(language == .auto ? "Same as input" : language.displayName)
                   - Maintain consistent language throughout all content
                   - Translate concepts from input while maintaining accuracy
                   """,
                userPromptTemplate: """
                   Important: \(languageInstruction_text)
                   Create self-contained questions that provide all necessary context within each question.
                   Include detailed explanations and hints
                   
                    Question creation guidelines:
                   - Generate questions directly from the user's input content
                   - Create questions for \(educationLevel.displayName) school student
                   - Avoid broad, oversimplified questions

                   Example format:
                   BAD: "What does the text explain?"
                   BAD: "what is the title of this image?"
                   GOOD: "In the passage where Jesus described the birds of the air, what characteristics of the birds did he emphasize?"
                   GOOD: "What lesson does the person mentioned in the text want to convey to us through ‚Äòtrying to endure many hardships while worrying about how to repay the mortgaged house price‚Äô"
                   GOOD: Sarah has 12 apples. She gives 5 apples to her friend Emma. Then, she buys 8 more apples from the store.
                   How many apples does Sarah have now?
                   GOOD: Solve for x: 2x^2 - 3x - 5 = 0G
                   """
            )
        }
    }
    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            educationLevel: parameters.educationLevel,
            difficulty: parameters.difficulty,
            language: parameters.language
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
            .replacingOccurrences(of: "{difficulty}", with: parameters.difficulty.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": ["type": "array", "items": ["type": "string"]],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint" ]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        print("ü§ñ OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages Î∞∞Ïó¥ÏùÑ ÎØ∏Î¶¨ ÏÑ†Ïñ∏
        var messages: [[String: Any]]

        // Íµ¨Ï°∞ÌôîÎêú Î©îÏãúÏßÄ ÏÉùÏÑ±
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI Í≥µÏãù Î©ÄÌã∞Î™®Îã¨ Ìè¨Îß∑ ÏÇ¨Ïö©
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        print("""
        üåê API Request:
        ‚Ä¢ URL: \(baseURL)
        ‚Ä¢ Method: POST
        ‚Ä¢ Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            üåê API Response:
            ‚Ä¢ Status Code: \(httpResponse.statusCode)
            ‚Ä¢ Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                difficulty: parameters.difficulty,
                question: questionData.question,
                options: questionData.options,
                correctAnswer: questionData.correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        ‚úÖ Questions Generated:
        ‚Ä¢ Count: \(questions.count)
        ‚Ä¢ Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


// ./AISnapStudy/Services/VisionService.swift

// Services/VisionService.swift

import Vision
import UIKit

// Vision Í¥ÄÎ†® ÏóêÎü¨ ÌÉÄÏûÖ Ï†ïÏùò
enum VisionError: Error {
    case invalidImage
    case processingFailed
    case noTextFound
    case unknown(Error)
}

class VisionService {
    static let shared = VisionService()
    
    private init() {}
    
    func extractText(from image: UIImage) async throws -> String {
        print("üîç Starting universal text extraction...")
        
        guard let cgImage = image.cgImage else {
            print("‚ùå Failed to get CGImage from UIImage")
            throw VisionError.invalidImage
        }

        let requestHandler = VNImageRequestHandler(cgImage: cgImage, options: [:])
        let request = VNRecognizeTextRequest()
        
        // Î≤îÏö© ÌÖçÏä§Ìä∏ Ïù∏Ïãù ÏÑ§Ï†ï
        request.recognitionLevel = .accurate
        request.usesLanguageCorrection = true
        request.automaticallyDetectsLanguage = true
        // recognitionLanguagesÎ•º ÏÑ§Ï†ïÌïòÏßÄ ÏïäÏùåÏúºÎ°úÏç®
        // VisionÏù¥ Î™®Îì† Í∞ÄÎä•Ìïú Ïñ∏Ïñ¥Î•º ÏûêÎèôÏúºÎ°ú Í∞êÏßÄÌïòÎèÑÎ°ù Ìï®
        
        print("üìù Configured for universal text recognition")
        
        do {
            try requestHandler.perform([request])
            
            let observations = request.results ?? []
            print("üìä Found \(observations.count) text observations")
            
            var extractedTexts: [String] = []
            
            for observation in observations {
                if let candidate = observation.topCandidates(1).first {
                    let text = candidate.string
                    let confidence = candidate.confidence
                    
//                    print("""
//                        üî§ Extracted text segment:
//                        ‚Ä¢ Text: \(text)
//                        ‚Ä¢ Confidence: \(confidence)
//                        """)
                    
                    if confidence > 0.3 { // Ïã†Î¢∞ÎèÑ ÏûÑÍ≥ÑÍ∞íÏùÑ ÎÇÆÏ∂§
                        extractedTexts.append(text)
                    }
                }
            }
            
            let finalText = extractedTexts.joined(separator: "\n")
//            print("‚úÖ Final extracted text:\n\(finalText)")
            
            // ÌÖçÏä§Ìä∏ Í≤ÄÏ¶ù
            guard !finalText.isEmpty else {
                print("‚ö†Ô∏è No valid text extracted")
                throw VisionError.noTextFound
            }
            
            return finalText
            
        } catch {
            print("‚ùå Text extraction failed: \(error.localizedDescription)")
            throw VisionError.processingFailed
        }
    }
}


// ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    // MARK: - Singleton
    static let shared = NetworkMonitor()
    
    // MARK: - Properties
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    private var timestampQueue: TimestampQueue
    
    // MARK: - Published Properties
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    // MARK: - Constants
    private let maxTimestamps = 1000
    private let cleanupInterval: TimeInterval = 300 // 5 minutes
    
    // MARK: - Debug Control
    private var shouldLog: Bool {
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    // MARK: - Initialization
    private init() {
        self.timestampQueue = TimestampQueue(maxSize: maxTimestamps)
        setupPeriodicCleanup()
        startMonitoring()
    }
    
    // MARK: - Monitoring
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            guard let self = self else { return }
            self.timestampQueue.enqueue(Date().timeIntervalSince1970)
            
            DispatchQueue.main.async {
                self.updateNetworkStatus(path)
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    private func updateNetworkStatus(_ path: NWPath) {
        self.status = path.status
        self.isReachable = path.status == .satisfied
        self.connectionType = path.availableInterfaces.first?.type
        self.isExpensive = path.isExpensive
        self.isConstrained = path.isConstrained
        
        if shouldLog {
            switch path.status {
            case .satisfied:
                // Ï§ëÏöîÌïú ÎÑ§Ìä∏ÏõåÌÅ¨ ÏÉÅÌÉú Î≥ÄÍ≤ΩÎßå ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Î∞úÏÜ°
                if !isReachable {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            case .unsatisfied:
                Logger.log("Network disconnected", category: "Network")
            default:
                break
            }
        }
    }
    
    // MARK: - Network Status Check
    func checkNetworkAvailability() -> Bool {
        return status == .satisfied
    }
    
    func handleNetworkError(_ error: Error) async throws -> Bool {
        if !checkNetworkAvailability() {
            throw NetworkError.noConnection
        }
        return true
    }
    
    // MARK: - Timestamp Management
    private func setupPeriodicCleanup() {
        Timer.scheduledTimer(withTimeInterval: cleanupInterval, repeats: true) { [weak self] _ in
            self?.performTimestampCleanup()
        }
    }
    
    private func performTimestampCleanup() {
        let currentTime = Date().timeIntervalSince1970
        timestampQueue.removeTimestampsBefore(currentTime - cleanupInterval)
        if shouldLog {
            Logger.log("Timestamp cleanup completed", category: "Network")
        }
    }
    
    // MARK: - Utility Methods
    func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    // MARK: - Connection Management
    func getConnectionDetails() -> String {
        """
        Network Status:
        ‚Ä¢ Connection: \(isReachable ? "Connected" : "Disconnected")
        ‚Ä¢ Type: \(getInterfaceTypeString(connectionType))
        ‚Ä¢ Expensive: \(isExpensive ? "Yes" : "No")
        ‚Ä¢ Constrained: \(isConstrained ? "Yes" : "No")
        """
    }
    
    // MARK: - Cleanup
    func stopMonitoring() {
        monitor.cancel()
        if shouldLog {
            Logger.log("Network monitoring stopped", category: "Network")
        }
    }
    
    deinit {
        stopMonitoring()
    }
}

// MARK: - TimestampQueue
private class TimestampQueue {
    private var timestamps: [TimeInterval]
    private let maxSize: Int
    
    init(maxSize: Int) {
        self.maxSize = maxSize
        self.timestamps = []
        timestamps.reserveCapacity(maxSize)
    }
    
    func enqueue(_ timestamp: TimeInterval) {
        if timestamps.count >= maxSize {
            timestamps.removeFirst()
        }
        timestamps.append(timestamp)
    }
    
    func removeTimestampsBefore(_ time: TimeInterval) {
        timestamps.removeAll { $0 < time }
    }
    
    var count: Int {
        timestamps.count
    }
}

// MARK: - Logger
private class Logger {
    static func log(_ message: String, category: String) {
        #if DEBUG
        print("üì± [\(category)] \(message)")
        #endif
    }
}


