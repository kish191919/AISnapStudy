## ./AISnapStudy/ViewModels/QuestionSettingsViewModel.swift


import Foundation
import SwiftUI
import PhotosUI

class QuestionSettingsViewModel: ObservableObject {
    private let homeViewModel: HomeViewModel
    private let networkMonitor = NetworkMonitor.shared
    private let imageService = ImageService.shared
    private var openAIService: OpenAIService?
    private let totalMaximumQuestions = 20
    
    // UserDefaults keys
    private enum UserDefaultsKeys {
        static let lastSubject = "lastSelectedSubject"
        static let lastEducationLevel = "lastEducationLevel"
        static let lastDifficulty = "lastDifficulty"
        static let lastMultipleChoiceCount = "lastMultipleChoiceCount"
        static let lastFillInBlanksCount = "lastFillInBlanksCount"
        static let lastTrueFalseCount = "lastTrueFalseCount"
    }
    
    @Published var selectedImages: [UIImage] = []
    @Published var hasCameraImage: Bool = false
    @Published var hasGalleryImages: Bool = false
    @Published var questionText: String = ""
    @Published var isUsingTextInput: Bool = false
    @Published var isTextInputActive: Bool = false
    @Published var hasSelectedCamera: Bool = false
    @Published var hasSelectedGallery: Bool = false
    @Published var shouldCollapseQuestionTypes = false
    @Published var shouldShowStudyView = false
    
    let subject: Subject
    
    // MARK: - Published Properties with UserDefaults persistence
     @Published var selectedSubject: Subject {
         didSet {
             UserDefaults.standard.set(selectedSubject.rawValue, forKey: UserDefaultsKeys.lastSubject)
         }
     }
     
     @Published var educationLevel: EducationLevel {
         didSet {
             UserDefaults.standard.set(educationLevel.rawValue, forKey: UserDefaultsKeys.lastEducationLevel)
             print("ğŸ“š ViewModel - Education Level updated from \(oldValue) to \(educationLevel)")
         }
     }
     
     @Published var difficulty: Difficulty {
         didSet {
             UserDefaults.standard.set(difficulty.rawValue, forKey: UserDefaultsKeys.lastDifficulty)
         }
     }
     
     @Published var multipleChoiceCount: Int {
         didSet {
             UserDefaults.standard.set(multipleChoiceCount, forKey: UserDefaultsKeys.lastMultipleChoiceCount)
             print("ViewModel - Multiple Choice Count updated to: \(multipleChoiceCount)")
         }
     }
     
     @Published var fillInBlanksCount: Int {
         didSet {
             UserDefaults.standard.set(fillInBlanksCount, forKey: UserDefaultsKeys.lastFillInBlanksCount)
             print("ViewModel - Fill in Blanks Count updated to: \(fillInBlanksCount)")
         }
     }
     
     
     @Published var trueFalseCount: Int {
         didSet {
             UserDefaults.standard.set(trueFalseCount, forKey: UserDefaultsKeys.lastTrueFalseCount)
             print("ViewModel - True/False Count updated to: \(trueFalseCount)")
         }
     }
     
     // ë‹¤ë¥¸ published ì†ì„±ë“¤...
     
     // MARK: - Initialization
     init(subject: Subject, homeViewModel: HomeViewModel) {
         self.subject = subject
         self.homeViewModel = homeViewModel
         
         // Load last used values from UserDefaults
         let lastSubjectRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastSubject)
         let lastEducationLevelRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastEducationLevel)
         let lastDifficultyRaw = UserDefaults.standard.string(forKey: UserDefaultsKeys.lastDifficulty)
         
         // Initialize with last used values or defaults
         self.selectedSubject = Subject(rawValue: lastSubjectRaw ?? "") ?? subject
         self.educationLevel = EducationLevel(rawValue: lastEducationLevelRaw ?? "") ?? .elementary
         self.difficulty = Difficulty(rawValue: lastDifficultyRaw ?? "") ?? .medium
         
         // Load last question counts
         self.multipleChoiceCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         self.fillInBlanksCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastFillInBlanksCount)
         self.trueFalseCount = UserDefaults.standard.integer(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         self.isLoading = false
         self.networkError = nil
         self.isNetworkAvailable = true
         self.showImagePicker = false
         self.showCamera = false
         self.selectedImages = []
         self.showAlert = false
         self.alertTitle = ""
         self.alertMessage = ""
         self.trueFalseCount = 0
         self.selectedImages = []
         
         // After all properties are initialized, setup network monitoring
         self.isNetworkAvailable = networkMonitor.isReachable
         
         // Initialize OpenAI service
         do {
             self.openAIService = try OpenAIService()
         } catch {
             self.error = error
             print("Failed to initialize OpenAI service:", error)
         }
     }
     
     // ê¸°ì¡´ resetCounts ë©”ì„œë“œ ìˆ˜ì •
     func resetCounts() {
         // Reset counts without clearing UserDefaults
         multipleChoiceCount = 0
         fillInBlanksCount = 0
         trueFalseCount = 0
         hasCameraImage = false
         hasGalleryImages = false
     }
     
     // UserDefaults ì™„ì „ ì´ˆê¸°í™”ê°€ í•„ìš”í•œ ê²½ìš°ë¥¼ ìœ„í•œ ìƒˆë¡œìš´ ë©”ì„œë“œ
     func resetAllSettings() {
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastSubject)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastEducationLevel)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastDifficulty)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastMultipleChoiceCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastFillInBlanksCount)
         UserDefaults.standard.removeObject(forKey: UserDefaultsKeys.lastTrueFalseCount)
         
         // Reset to defaults
         selectedSubject = subject
         educationLevel = .elementary
         difficulty = .medium
         resetCounts()
     }
    
    
    @Published var isLoading: Bool
    @Published var error: Error?
    @Published var networkError: NetworkError?
    @Published var isNetworkAvailable: Bool
    @Published var showImagePicker = false
    @Published var showCamera = false
    @Published var selectedImage: UIImage?
    @Published var showAlert: Bool
    @Published var alertTitle: String
    @Published var alertMessage: String
    
    // questionTextê°€ ë¹„ì–´ìˆì§€ ì•Šìœ¼ë©´ ì´ë¯¸ì§€ ì˜µì…˜ì„ ìˆ¨ê¸°ê¸° ìœ„í•œ ê³„ì‚° ì†ì„±
    var shouldShowImageOptions: Bool {
        questionText.isEmpty && !hasCameraImage && !hasGalleryImages
    }
    
    // í…ìŠ¤íŠ¸ ì…ë ¥ì„ ë¦¬ì…‹í•˜ëŠ” ë©”ì„œë“œ
    func resetTextInput() {
        questionText = ""
        isUsingTextInput = false
    }
    
    // Update computed property
    var canUseTextInput: Bool {
        return selectedImages.isEmpty // ì‹¤ì œ ì„ íƒëœ ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œë§Œ ì²´í¬
    }
    
    func collapseQuestionTypes() {
        shouldCollapseQuestionTypes = true
        // ë‹¤ìŒ ìƒíƒœ ë³€ê²½ì„ ìœ„í•´ ë¦¬ì…‹
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.shouldCollapseQuestionTypes = false
        }
    }

    var canUseImageInput: Bool {
        return !isTextInputActive || questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    func toggleTextInput() {
        isTextInputActive.toggle()
        if !isTextInputActive {
            questionText = ""
        }
    }
    
    func onImageOptionSelected() {
            shouldCollapseQuestionTypes = true
            // ìƒíƒœ ë¦¬ì…‹
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.shouldCollapseQuestionTypes = false
            }
        }

    var totalQuestionCount: Int {
        multipleChoiceCount + fillInBlanksCount + trueFalseCount
    }
    
    func canAddMoreQuestions() -> Bool {
        return totalQuestionCount < totalMaximumQuestions
    }
    
    func remainingQuestions() -> Int {
        return totalMaximumQuestions - totalQuestionCount
    }
    
    // MARK: - Network Monitoring
    private func setupNetworkMonitoring() {
        isNetworkAvailable = networkMonitor.isReachable
    }
    
    var hasValidQuestionCount: Bool {
        multipleChoiceCount + fillInBlanksCount + trueFalseCount > 0
    }
    
    @MainActor
    func loadData() async {
        await homeViewModel.loadData()
    }
    
    // MARK: - Image Management
    @MainActor
    func addImage(_ image: UIImage) async {
        do {
            let compressedData = try await Task {
                try ImageService.shared.compressForAPI(image)
            }.value
            
            if let compressedImage = UIImage(data: compressedData) {
                selectedImages.append(compressedImage)
                if hasCameraImage {
                    hasSelectedCamera = true
                }
                if hasGalleryImages {
                    hasSelectedGallery = true
                }
            }
        } catch {
            self.error = error
            showError(error)
        }
    }
    

    func removeImage(at index: Int) {
        selectedImages.remove(at: index)
        if selectedImages.isEmpty {
            hasCameraImage = false
            hasGalleryImages = false
            isUsingTextInput = false
            hasSelectedCamera = false    // Reset states
            hasSelectedGallery = false   // Reset states
        }
    }
    
    @MainActor
    func sendAllImages() async {
       print("\nğŸš€ Starting sendAllImages")
       print("Current state:")
       print("â€¢ Selected Subject: \(selectedSubject.displayName)")
       print("â€¢ Selected Images: \(selectedImages.count)")
       print("â€¢ Question Text: \(questionText.isEmpty ? "Empty" : "Has content")")
       print("â€¢ Is Loading: \(isLoading)")
       
       guard !selectedImages.isEmpty || !questionText.isEmpty else {
           print("âŒ No content to generate questions from")
           return
       }
       
       guard networkMonitor.isReachable else {
           print("âŒ No network connection")
           showError(NetworkError.noConnection as Error)
           return
       }
       
       isLoading = true
       print("ğŸ”„ Started loading state")
       
       do {
           // ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë  questionTypes
           let questionTypes: [QuestionType: Int] = [
               .multipleChoice: multipleChoiceCount,
               .fillInBlanks: fillInBlanksCount,
               .trueFalse: trueFalseCount
           ].filter { $0.value > 0 }
           
           // ê³µí†µ parameters
           let parameters = OpenAIService.QuestionParameters(
               subject: selectedSubject,
               difficulty: difficulty,
               educationLevel: educationLevel,
               questionTypes: questionTypes
           )
           
           print("""
           ğŸ“ Question Generation Parameters:
           â€¢ Subject: \(selectedSubject.displayName)
           â€¢ Difficulty: \(difficulty.displayName)
           â€¢ Education Level: \(educationLevel.displayName)
           â€¢ Question Types: \(questionTypes.map { "- \($0.key.rawValue): \($0.value)" }.joined(separator: "\n"))
           """)
           
           if !selectedImages.isEmpty {
               print("ğŸ“¸ Processing \(selectedImages.count) images")
               for (index, image) in selectedImages.enumerated() {
                   print("ğŸ–¼ï¸ Processing image \(index + 1) of \(selectedImages.count)")
                   let compressedData = try await Task {
                       try ImageService.shared.compressForAPI(image)
                   }.value
                   
                   let input = OpenAIService.QuestionInput(
                       content: compressedData,
                       isImage: true
                   )
                   
                   await generateQuestions(from: input, parameters: parameters)
               }
               selectedImages.removeAll()
               print("âœ… All images processed and cleared")
           } else if !questionText.isEmpty {
               print("ğŸ“ Processing text input: \(questionText)")
               guard let textData = questionText.data(using: .utf8) else {
                   throw NetworkError.invalidData
               }
               let input = OpenAIService.QuestionInput(
                   content: textData,
                   isImage: false
               )
               
               await generateQuestions(from: input, parameters: parameters)
               print("âœ… Text input processed")
           }
           
           print("âœ… Successfully generated questions")
           showSuccess()
           
           // Study Viewë¡œ ìë™ ì „í™˜
           shouldShowStudyView = true
           
       } catch {
           print("âŒ Error in sendAllImages: \(error)")
           self.error = error
           showError(error)
       }
       
       isLoading = false
       print("âœ… Finished loading state")
    }
    
    // MARK: - Image Capture Methods
    @MainActor
    func takePhoto() async {
        print("ğŸ“¸ Taking photo...")
        do {
            let hasPermission = try await imageService.requestPermission(for: .camera)
            if hasPermission {
                showCamera = true
                hasCameraImage = true
            } else {
                self.error = ImageServiceError.permissionDenied
                showError(ImageServiceError.permissionDenied)
            }
        } catch {
            if let imageError = error as? ImageServiceError {
                showError(imageError)
            } else {
                showError(error)
            }
        }
    }
    
    @MainActor
    func handleCameraImage(_ image: UIImage?) {
        print("ğŸ“¸ Processing camera image...")
        guard let image = image else {
            print("âŒ No image captured")
            return
        }

        Task {
            do {
                await addImage(image)
                hasCameraImage = true
                hasSelectedCamera = true
                print("âœ… Camera image added successfully")
            } catch {
                print("âŒ Failed to add camera image: \(error)")
                showError(error)
            }
        }
    }
     
     @MainActor
     func selectFromGallery() async {
         do {
             let hasPermission = try await imageService.requestPermission(for: .gallery)
             if hasPermission {
                 showImagePicker = true
                 hasGalleryImages = true
             } else {
                 self.error = ImageServiceError.permissionDenied
                 showError(ImageServiceError.permissionDenied)
             }
         } catch {
             if let imageError = error as? ImageServiceError {
                 showError(imageError)
             } else {
                 showError(error)
             }
         }
     }
    
    // MARK: - Question Generation
    @MainActor
    private func generateQuestions(from input: OpenAIService.QuestionInput, parameters: OpenAIService.QuestionParameters) async {
        guard let openAIService = openAIService else {
            print("âŒ OpenAI service not initialized")
            return
        }
        
        do {
            let questionTypes: [QuestionType: Int] = [
                .multipleChoice: multipleChoiceCount,
                .fillInBlanks: fillInBlanksCount,
                .trueFalse: trueFalseCount
            ].filter { $0.value > 0 }
            
            // ë¡œê¹…
            print("ğŸš€ Preparing to send data to OpenAI API:")
            print("â€¢ Subject: \(subject.rawValue)")
            print("â€¢ Difficulty: \(difficulty.rawValue)")
            print("â€¢ Education Level: \(educationLevel.rawValue)")
            print("â€¢ Question Types: \(questionTypes)")
            
            let questions = try await openAIService.generateQuestions(
                from: input,
                parameters: parameters
            )
            
            print("âœ… Generated \(questions.count) questions")
            await processGeneratedQuestions(questions)
        } catch {
            print("âŒ Question generation error: \(error)")
            self.error = error
            showError(error)
        }
    }
    
    @MainActor
    func processGeneratedQuestions(_ questions: [Question]) async {
        print("\nğŸ”„ Processing Generated Questions:")
        print("Number of questions by type:")
        let questionsByType = Dictionary(grouping: questions, by: { $0.type })
        questionsByType.forEach { type, questions in
            print("- \(type.rawValue): \(questions.count) questions")
        }
        
        let subject = questions.first?.subject ?? self.subject
        let problemSet = ProblemSet(
            id: UUID().uuidString,
            title: "Generated Questions",
            subject: subject,
            difficulty: difficulty,
            questions: questions,
            createdAt: Date(),
            educationLevel: self.educationLevel, // ì¶”ê°€
            name: "Default Name" // ì¶”ê°€
        )

        
        print("\nğŸ“¦ Setting ProblemSet in HomeViewModel")
        // ProblemSet ì €ì¥
        await homeViewModel.saveProblemSet(problemSet)
        // ì €ì¥ëœ ProblemSetì„ ë°”ë¡œ ì„ íƒí•˜ì—¬ ì‚¬ìš©
        await homeViewModel.setSelectedProblemSet(problemSet)
        
        // Study íƒ­ìœ¼ë¡œ ìë™ ì „í™˜
        NotificationCenter.default.post(
            name: Notification.Name("ShowStudyView"),
            object: nil
        )
    }

    @MainActor
    private func showSuccess() {
       alertTitle = "Success"
       alertMessage = "Questions have been successfully generated."
       showAlert = true
    }
    
    
    // MARK: - Error Handling
    @MainActor
    private func showError(_ error: Error) {
        print("Error details:", error.localizedDescription)
        
        if let networkError = error as? NetworkError {
            alertTitle = "Network Error"
            alertMessage = networkError.errorDescription ?? "A network error occurred"
        } else if let imageError = error as? ImageServiceError {
            switch imageError {
            case .permissionDenied:
                alertTitle = "Permission Required"
                alertMessage = """
                    Camera or photo library access is not authorized.
                    Please enable access in Settings.
                    
                    Go to: Settings > Privacy > Camera/Photos
                    """
            case .unavailable:
                alertTitle = "Feature Unavailable"
                alertMessage = "This feature is not available on your device."
            case .compressionFailed:
                alertTitle = "Image Processing Error"
                alertMessage = "Failed to process the image. Please try another image."
            case .unknown(let underlyingError):
                alertTitle = "Unknown Error"
                alertMessage = "An unexpected error occurred: \(underlyingError.localizedDescription)"
            }
        } else {
            alertTitle = "Error"
            alertMessage = """
                An error occurred. Please try again.
                Error: \(error.localizedDescription)
                """
        }
        showAlert = true
    }
    
}

extension QuestionSettingsViewModel {
    @MainActor
    func selectMultiplePhotos() {
        showImagePicker = true
    }
}


## ./AISnapStudy/ViewModels/StatViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StatViewModel: ObservableObject {
    @Published var weeklyProgress: [DailyProgress] = []
    @Published var totalQuestions = 0
    @Published var averageScore: Double = 0.0
    @Published var languageArtsProgress: Double = 0.0
    @Published var mathProgress: Double = 0.0
    @Published var streak: Int = 0
    @Published var totalPoints: Int = 0
    @Published var completedQuestions: Int = 0
    @Published var accuracyRate: Double = 0.0
    @Published var correctAnswers: Int = 0
    @Published var isLoading = false
    @Published var selectedTab: Int = 0
    
    private var cancellables = Set<AnyCancellable>()
    private let context: NSManagedObjectContext
    private let calendar = Calendar.current
    private var homeViewModel: HomeViewModel?
    
    init(context: NSManagedObjectContext) {
        self.context = context
        loadStats()
    }
    
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
    }
    
    func logCurrentQuestionState() {
        if let studyViewModel = homeViewModel?.studyViewModel, let question = studyViewModel.currentQuestion {
            print("ğŸ”„ Study View update initiated - currentQuestion: \(question.question), currentIndex: \(studyViewModel.currentIndex)")
        } else {
            print("ğŸ”„ Study View update initiated - No current question loaded, currentIndex: \(homeViewModel?.studyViewModel?.currentIndex ?? -1)")
        }
    }


    func loadStats() {
        isLoading = true
        let request: NSFetchRequest<CDStudySession> = CDStudySession.fetchRequest()
        
        do {
            let sessions = try context.fetch(request)
            calculateStats(from: sessions)
        } catch {
            print("Failed to fetch study sessions:", error)
        }
        
        isLoading = false
    }

    private func calculateStats(from sessions: [CDStudySession]) {
        totalQuestions = sessions.reduce(0) { total, session in
            total + (session.questions?.count ?? 0)
        }
        
        let totalCorrect = sessions.reduce(0) { total, session in
            total + (session.questions?.filter { ($0 as? CDQuestion)?.isCorrect == true }.count ?? 0)
        }
        
        averageScore = totalQuestions > 0 ? (Double(totalCorrect) / Double(totalQuestions)) * 100 : 0
        correctAnswers = totalCorrect
        completedQuestions = totalQuestions
        totalPoints = completedQuestions * 10
        accuracyRate = completedQuestions > 0 ? (Double(correctAnswers) / Double(completedQuestions)) * 100 : 0
        streak = calculateStreak(from: sessions)
    }

    private func calculateStreak(from sessions: [CDStudySession]) -> Int {
        let sortedSessions = sessions.compactMap { $0.endTime }.sorted(by: { $0 > $1 })
        
        var currentStreak = 0
        var streakDate = Date()
        
        for date in sortedSessions {
            if calendar.isDate(date, inSameDayAs: streakDate) || calendar.isDate(date, inSameDayAs: calendar.date(byAdding: .day, value: -1, to: streakDate)!) {
                currentStreak += 1
                streakDate = date
            } else {
                break
            }
        }
        
        return currentStreak
    }
    
    func formatProgress(_ progress: Double) -> String {
        return String(format: "%.1f%%", progress)
    }
    
    func resetProgress() {
        correctAnswers = 0
        completedQuestions = 0
        accuracyRate = 0
        
        if let homeViewModel = homeViewModel, let studyViewModel = homeViewModel.studyViewModel {
            if let currentProblemSet = homeViewModel.selectedProblemSet {
                Task {
                    print("ğŸ”„ Starting StudyViewModel resetState...")
                    await studyViewModel.resetState()
                    
                    print("ğŸ”„ Starting ProblemSet reset with ID: \(currentProblemSet.id)")
                    await homeViewModel.resetAndSetProblemSet(currentProblemSet)
                    
                    // Study íƒ­ìœ¼ë¡œ ì´ë™
                    await MainActor.run {
                        print("ğŸ”„ Switching to Study Tab")
                        selectedTab = 1
                    }
                }
            } else {
                print("âŒ No selected problem set found.")
            }
        } else {
            print("âŒ homeViewModel or studyViewModel is nil in resetProgress")
        }
        
        loadStats()
    }
    

}


## ./AISnapStudy/ViewModels/HomeViewModel.swift

// ./AISnapStudy/ViewModels/HomeViewModel.swift

import Foundation
import Combine

@MainActor
class HomeViewModel: ObservableObject {
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published var correctAnswers: Int = 0
    @Published var totalQuestions: Int = 0
    @Published private(set) var selectedProblemSet: ProblemSet?
    var studyViewModel: StudyViewModel?
    
    private let coreDataService = CoreDataService.shared
    private var cancellables = Set<AnyCancellable>()
    private var hasLoadedData = false
    
    // Singleton instance
    static let shared = HomeViewModel()

    
    init() {
        Task {
            await loadInitialData()
        }
    }
    
    func resetAndSetProblemSet(_ problemSet: ProblemSet) {
        print("ğŸ”„ Starting complete ProblemSet reset")
        
        // ë¨¼ì € StudyViewModel ìƒíƒœ ë¦¬ì…‹
        studyViewModel?.resetState()
        
        // ìƒˆë¡œìš´ ProblemSet ì„¤ì •
        self.selectedProblemSet = problemSet
        
        // ë¬¸ì œ ë‹¤ì‹œ ë¡œë“œ
        studyViewModel?.loadQuestions(problemSet.questions)
        
        print("""
        âœ… ProblemSet reset complete:
        â€¢ ID: \(problemSet.id)
        â€¢ Questions: \(problemSet.questions.count)
        â€¢ Index reset to 0
        """)
    }
    
    // MARK: - Data Loading
    @MainActor
    private func loadInitialData() async {
        guard !hasLoadedData else { return }
        
        do {
            print("ğŸ”µ HomeViewModel - Initial data loading")
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            self.savedQuestions = try coreDataService.fetchSavedQuestions()
            
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            hasLoadedData = true
            print("âœ… Initial data loaded successfully")
        } catch {
            print("âŒ Failed to load initial data: \(error)")
        }
    }
    
    @MainActor
    func loadData() async {
        guard !isLoading else { return }
        
        print("ğŸ”µ HomeViewModel - Loading data")
        isLoading = true
        error = nil
        
        do {
            let loadedProblemSets = try coreDataService.fetchProblemSets()
            self.problemSets = loadedProblemSets
            
            // Get saved questions from all problem sets
            self.savedQuestions = loadedProblemSets
                .flatMap { $0.questions }
                .filter { $0.isSaved }
            
            // ìµœê·¼ ProblemSetì„ selectedProblemSetìœ¼ë¡œ ì„¤ì •
            if selectedProblemSet == nil && !problemSets.isEmpty {
                setSelectedProblemSet(problemSets[0])
            }
            
            print("âœ… Loaded problem sets: \(problemSets.count)")
            print("âœ… Loaded saved questions: \(savedQuestions.count)")
            
        } catch {
            self.error = error
            print("âŒ Error in loadData: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Problem Set Management
    @MainActor
    func saveProblemSet(_ problemSet: ProblemSet) async {
        do {
            print("ğŸ’¾ Saving ProblemSet with \(problemSet.questions.count) questions")
            try await coreDataService.saveProblemSet(problemSet)
            
            // ë°ì´í„° ë¦¬ë¡œë“œ ëŒ€ì‹  ë¬¸ì œ ì„¸íŠ¸ ì§ì ‘ ì¶”ê°€
            problemSets.insert(problemSet, at: 0)
            setSelectedProblemSet(problemSet)
            
            print("âœ… Saved ProblemSet: \(problemSet.questions.count) questions")
        } catch {
            self.error = error
            print("âŒ Failed to save ProblemSet: \(error)")
        }
    }
    
    @MainActor
    func setSelectedProblemSet(_ problemSet: ProblemSet?) {
        guard selectedProblemSet?.id != problemSet?.id else { return }
        
        print("ğŸ”µ HomeViewModel - Setting selected problem set")
        
        // ìƒíƒœ ë³€ê²½ì„ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ í•œë²ˆì— ì²˜ë¦¬
        DispatchQueue.main.async {
            self.selectedProblemSet = problemSet
            
            if let problemSet = problemSet {
                print("""
                âœ… ProblemSet set successfully:
                â€¢ ID: \(problemSet.id)
                â€¢ Questions: \(problemSet.questions.count)
                """)
            }
        }
    }
    
    @MainActor
    func clearSelectedProblemSet() {
        self.selectedProblemSet = nil
    }
    
    // MARK: - Question Management
    @MainActor
    func saveQuestion(_ question: Question) async {
        do {
            try await coreDataService.saveQuestion(question)
            savedQuestions.append(question)
        } catch {
            self.error = error
            print("âŒ Error saving question: \(error)")
        }
    }
    
    @MainActor
    func deleteQuestion(_ question: Question) async {
        guard let index = savedQuestions.firstIndex(where: { $0.id == question.id }) else {
            return
        }
        
        let deletedQuestion = savedQuestions.remove(at: index)
        
        do {
            try await coreDataService.deleteQuestion(question)
        } catch {
            self.error = error
            savedQuestions.insert(deletedQuestion, at: index)
            print("âŒ Error deleting question: \(error)")
        }
    }
    
    // MARK: - Debug Helper
    @MainActor
    func verifyProblemSetStorage() {
        Task {
            do {
                let storedSets = try coreDataService.fetchProblemSets()
                print("""
                ğŸ“ Stored ProblemSets:
                â€¢ Count: \(storedSets.count)
                â€¢ Details: \(storedSets.map { "[\($0.id): \($0.questions.count) questions]" })
                """)
            } catch {
                print("âŒ Failed to verify storage: \(error)")
            }
        }
    }
}


## ./AISnapStudy/ViewModels/HistoryViewModel.swift


import Foundation

import Foundation

@MainActor
class HistoryViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var studySessions: [StudySession] = []
    @Published private(set) var isLoading = false
    @Published private(set) var error: Error?
    @Published private(set) var problemSets: [ProblemSet] = []
    @Published private(set) var savedQuestions: [Question] = []

    // MARK: - Dependencies
    private let storageService: StorageService
    private weak var homeViewModel: HomeViewModel?
    
    // MARK: - Initialization
    init(storageService: StorageService = StorageService(),
         homeViewModel: HomeViewModel? = nil) {
        self.storageService = storageService
        self.homeViewModel = homeViewModel
        loadStudySessions()
    }
    
    // MARK: - Data Loading
    private func loadStudySessions() {
        isLoading = true
        
        do {
            studySessions = try storageService.getStudySessions()
            studySessions.sort { $0.startTime > $1.startTime }
            
            // Update problemSets and savedQuestions from homeViewModel
            if let homeVM = homeViewModel {
                problemSets = homeVM.problemSets
                savedQuestions = homeVM.savedQuestions
            }
            
            print("""
            ğŸ“š History Data Loaded:
            â€¢ Study Sessions: \(studySessions.count)
            â€¢ Problem Sets: \(problemSets.count)
            â€¢ Saved Questions: \(savedQuestions.count)
            """)
        } catch {
            self.error = error
            print("âŒ Failed to load study sessions: \(error)")
        }
        
        isLoading = false
    }
    
    // MARK: - Session Management
    func deleteSession(_ session: StudySession) {
        guard let index = studySessions.firstIndex(where: { $0.id == session.id }) else {
            return
        }
        
        let deletedSession = studySessions.remove(at: index)
        
        Task {
            do {
                try await Task.detached {
                    try self.storageService.deleteStudySession(session)
                }.value
                print("âœ… Successfully deleted study session: \(session.id)")
            } catch {
                await MainActor.run {
                    self.error = error
                    self.studySessions.insert(deletedSession, at: index)
                    print("âŒ Failed to delete study session: \(error)")
                }
            }
        }
    }
    
    // MARK: - Data Refresh
    func refreshData() {
        loadStudySessions()
    }
    
    // MARK: - HomeViewModel Management
    func setHomeViewModel(_ viewModel: HomeViewModel) {
        self.homeViewModel = viewModel
        // Update data immediately when HomeViewModel is set
        problemSets = viewModel.problemSets
        savedQuestions = viewModel.savedQuestions
        print("ğŸ“± HomeViewModel reference set in HistoryViewModel")
    }
    
    // MARK: - Data Access Methods
    func getProblemSets() -> [ProblemSet] {
        problemSets
    }
    
    func getSavedQuestions() -> [Question] {
        savedQuestions
    }
}


## ./AISnapStudy/ViewModels/StudyViewModel.swift

import Foundation
import Combine
import CoreData

@MainActor
class StudyViewModel: ObservableObject {
   // OpenAIService íƒ€ì… ì°¸ì¡° ì¶”ê°€
   typealias QuestionInput = OpenAIService.QuestionInput
   typealias QuestionParameters = OpenAIService.QuestionParameters

   @Published private(set) var loadedQuestions: [Question] = []
   @Published private(set) var loadingProgress = 0
   
   private let openAIService: OpenAIService
   
   @Published private(set) var currentQuestion: Question?
   @Published var selectedAnswer: String?
   @Published var showExplanation = false
   private var questions: [Question] = []
   private var cancellables = Set<AnyCancellable>()
   @Published private(set) var currentIndex = 0
   @Published var correctAnswers: Int = 0
    
    // ì§ˆë¬¸ ìƒì„± ê´€ë ¨ í”„ë¡œí¼í‹° ì¶”ê°€
    @Published var isGeneratingQuestions = false
    @Published var generatedQuestionCount = 0
    @Published var totalExpectedQuestions = 0
    @Published var generatedQuestions: [Question] = []
    @Published var isLoadingQuestions: Bool = false
    

    
    func updateGeneratedQuestions(_ question: Question) {
        generatedQuestions.append(question)
        generatedQuestionCount = generatedQuestions.count
    }
    
    func setTotalExpectedQuestions(_ total: Int) {
        totalExpectedQuestions = total
    }
    
   var totalQuestions: Int {
       questions.count
   }
   
   private let context: NSManagedObjectContext
   private var currentSession: CDStudySession?
   private let homeViewModel: HomeViewModel
   
   private var hasInitialized = false
   
   init(homeViewModel: HomeViewModel, context: NSManagedObjectContext) {
       self.context = context
       self.homeViewModel = homeViewModel
       
       // OpenAIService ì´ˆê¸°í™”
       do {
           self.openAIService = try OpenAIService()
       } catch {
           fatalError("Failed to initialize OpenAI service: \(error)")
       }
       
       Task { @MainActor in
           homeViewModel.$selectedProblemSet
               .compactMap { $0 }
               .removeDuplicates(by: { $0.id == $1.id })
               .receive(on: RunLoop.main)
               .sink { [weak self] problemSet in
                   guard let self = self else { return }
                   self.resetState()
                   Task { @MainActor in
                       self.loadQuestions(problemSet.questions)
                   }
               }
               .store(in: &self.cancellables)
       }
       
       setupCurrentSession()
   }
   
    func startQuestionGeneration(input: QuestionInput, parameters: QuestionParameters) async {
        isLoadingQuestions = true  // ì´ì œ í• ë‹¹ ê°€ëŠ¥
        loadingProgress = 0
        loadedQuestions = []
        isGeneratingQuestions = true
        generatedQuestionCount = 0
        generatedQuestions = []
        
        // ì˜ˆìƒë˜ëŠ” ì´ ì§ˆë¬¸ ìˆ˜ ê³„ì‚°
        let totalQuestions = parameters.questionTypes.values.reduce(0, +)
        setTotalExpectedQuestions(totalQuestions)
        
        do {
            for try await question in openAIService.streamQuestions(from: input, parameters: parameters) {
                await MainActor.run {
                    updateGeneratedQuestions(question)
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }
        
        await MainActor.run {
            isGeneratingQuestions = false
        }

        do {
            for try await question in openAIService.streamQuestions(from: input, parameters: parameters) {
                await MainActor.run {
                    loadedQuestions.append(question)
                    loadingProgress = min(100, Int((Float(loadedQuestions.count) / Float(parameters.questionTypes.values.reduce(0, +))) * 100))
                }
            }
        } catch {
            print("Error generating questions: \(error)")
        }
        
        await MainActor.run {
            isLoadingQuestions = false  // ì´ì œ í• ë‹¹ ê°€ëŠ¥
        }
    }
   
   func resetState() {
       print("ğŸ”„ Performing complete state reset")
       currentIndex = 0
       selectedAnswer = nil
       showExplanation = false
       correctAnswers = 0
       
       questions.removeAll()
       
       if let problemSet = homeViewModel.selectedProblemSet {
           loadQuestions(problemSet.questions)
       }

       currentQuestion = questions.first
       print("âœ… Reset to first question with question: \(currentQuestion?.question ?? "No question loaded"), currentIndex: \(currentIndex)")
   }
   
   func loadQuestions(_ newQuestions: [Question]) {
       print("ğŸ“ Loading fresh set of \(newQuestions.count) questions")
       questions = newQuestions
       currentIndex = 0
       currentQuestion = questions.isEmpty ? nil : questions[0]
       
       print("âœ… First question loaded explicitly: \(currentQuestion?.question ?? "No question loaded") with currentIndex: \(currentIndex)")
   }
   
   private func setupCurrentSession() {
       let session = CDStudySession(context: context)
       session.startTime = Date()
       currentSession = session
       saveContext()
   }
   
   func submitAnswer() {
       guard let currentQuestion = currentQuestion else { return }
       
       let isCorrect = currentQuestion.correctAnswer == selectedAnswer
       if isCorrect {
           correctAnswers += 1
       }
       
       if let session = currentSession {
           let question = CDQuestion(context: context)
           question.isCorrect = isCorrect
           question.question = currentQuestion.question
           question.session = session
           saveContext()
       }
       
       showExplanation = true
   }
   
   func nextQuestion() {
       guard currentIndex < questions.count - 1 else { return }
       currentIndex += 1
       currentQuestion = questions[currentIndex]
       resetAnswers()
   }
   
   func saveProgress() {
       print("Saving progress...")
       saveContext()
   }
   
   private func saveContext() {
       do {
           try context.save()
       } catch {
           print("Failed to save context: \(error)")
       }
   }
   
   var hasQuestions: Bool {
       return !questions.isEmpty
   }
   
   var progress: Double {
       guard totalQuestions > 0 else { return 0 }
       return Double(currentIndex + 1) / Double(totalQuestions)
   }
   
   var isLastQuestion: Bool {
       currentIndex == questions.count - 1
   }
   
   var canSubmit: Bool {
       guard let question = currentQuestion else { return false }
       
       switch question.type {
       case .multipleChoice, .fillInBlanks, .trueFalse:
           return selectedAnswer != nil
       }
   }
   
   private func resetAnswers() {
       selectedAnswer = nil
       showExplanation = false
   }
}

extension StudyViewModel {
   @MainActor
   func toggleSaveQuestion(_ question: Question) async {
       var updatedQuestion = question
       updatedQuestion.isSaved.toggle()
       
       do {
           if updatedQuestion.isSaved {
               try await homeViewModel.saveQuestion(updatedQuestion)
           } else {
               try await homeViewModel.deleteQuestion(updatedQuestion)
           }
           print("âœ… Question save state toggled successfully")
       } catch {
           print("âŒ Failed to toggle question save state: \(error)")
       }
   }
}


## ./AISnapStudy/ViewModels/ProfileViewModel.swift



import SwiftUI

class ProfileViewModel: ObservableObject {
    @Published var user: User
    @Published var isDarkMode: Bool {
        didSet {
            UserDefaults.standard.set(isDarkMode, forKey: "isDarkMode")
        }
    }
    @Published var notificationsEnabled: Bool {
        didSet {
            UserDefaults.standard.set(notificationsEnabled, forKey: "notificationsEnabled")
        }
    }
    
    init() {
        // ì‹¤ì œ ì•±ì—ì„œëŠ” ì‚¬ìš©ì ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ë¡œì§ êµ¬í˜„
        self.user = User(
            id: "1",
            name: "Test User",
            email: "test@example.com",
            preferences: User.UserPreferences(
                isDarkMode: false,
                notificationsEnabled: true,
                dailyGoal: 5,
                preferredDifficulty: .medium
            ),
            createdAt: Date(),
            lastActive: Date()
        )
        
        self.isDarkMode = UserDefaults.standard.bool(forKey: "isDarkMode")
        self.notificationsEnabled = UserDefaults.standard.bool(forKey: "notificationsEnabled")
    }
    
    func showTerms() {
        guard let url = URL(string: "https://example.com/terms") else { return }
        UIApplication.shared.open(url)
    }
    
    func showPrivacyPolicy() {
        guard let url = URL(string: "https://example.com/privacy") else { return }
        UIApplication.shared.open(url)
    }
    
    func signOut() {
        // ë¡œê·¸ì•„ì›ƒ ë¡œì§ êµ¬í˜„
    }
}


## ./AISnapStudy/App/AISnapStudyApp.swift

import SwiftUI
import CoreData

@main
struct AISnapStudyApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    init() {
        SecureArrayTransformer.register()
        setupAppearance()
    }

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environment(\.managedObjectContext, CoreDataService.shared.viewContext)
        }
    }
    
    private func setupAppearance() {
        // ë„¤ë¹„ê²Œì´ì…˜ ë°” ìŠ¤íƒ€ì¼ ì„¤ì •
        let appearance = UINavigationBarAppearance()
        appearance.configureWithOpaqueBackground()
        UINavigationBar.appearance().standardAppearance = appearance
        UINavigationBar.appearance().scrollEdgeAppearance = appearance
        
        // íƒ­ ë°” ìŠ¤íƒ€ì¼ ì„¤ì •
        let tabBarAppearance = UITabBarAppearance()
        tabBarAppearance.configureWithOpaqueBackground()
        UITabBar.appearance().standardAppearance = tabBarAppearance
        UITabBar.appearance().scrollEdgeAppearance = tabBarAppearance
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
        setupCoreData()
        return true
    }
    
    private func setupCoreData() {
        let container = CoreDataService.shared.persistentContainer
        
        print("""
        ğŸ“Š CoreData Configuration:
        â€¢ Store Descriptions: \(container.persistentStoreDescriptions.count)
        â€¢ View Context: \(container.viewContext)
        """)
        
        guard let storeURL = container.persistentStoreDescriptions.first?.url else {
            print("âŒ No store URL found")
            return
        }
        
        print("â€¢ Store URL: \(storeURL)")
        createCoreDataDirectoryIfNeeded(at: storeURL)
        setupCoreDataOptions(container: container)
    }
    
    private func createCoreDataDirectoryIfNeeded(at storeURL: URL) {
        let fileManager = FileManager.default
        let parentDirectory = storeURL.deletingLastPathComponent().path
        
        guard !fileManager.fileExists(atPath: parentDirectory) else { return }
        
        do {
            try fileManager.createDirectory(
                atPath: parentDirectory,
                withIntermediateDirectories: true,
                attributes: nil
            )
            print("âœ… Created CoreData directory")
        } catch {
            print("âŒ Failed to create CoreData directory: \(error)")
        }
    }
    
    private func setupCoreDataOptions(container: NSPersistentContainer) {
        // CoreData ì˜µì…˜ ì„¤ì •
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        // ì„±ëŠ¥ ìµœì í™” ì„¤ì •
        container.viewContext.shouldDeleteInaccessibleFaults = true
        container.viewContext.name = "MainContext"
    }
    
    // MARK: - Memory Management
    func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
        CoreDataService.shared.viewContext.refreshAllObjects()
    }
}


## ./AISnapStudy/CoreData/SecureArrayTransformer.swift



import Foundation

@objc(SecureArrayTransformer)
final class SecureArrayTransformer: NSSecureUnarchiveFromDataTransformer {
    
    static let transformerName = NSValueTransformerName(rawValue: "SecureArrayTransformer")
    
    override static var allowedTopLevelClasses: [AnyClass] {
        [NSArray.self, NSString.self, NSDictionary.self]
    }
    
    static func register() {
        let transformer = SecureArrayTransformer()
        ValueTransformer.setValueTransformer(
            transformer,
            forName: transformerName
        )
    }
}


## ./AISnapStudy/CoreData/CoreDataService.swift




import CoreData
import Foundation



class CoreDataService {
    static let shared = CoreDataService()
    
    // private -> publicìœ¼ë¡œ ë³€ê²½
    public var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "AISnapStudy")
        
        // ì €ì¥ì†Œ ì„¤ëª… ìƒì„±
        let storeDescription = NSPersistentStoreDescription()
        
        // Application Support ë””ë ‰í† ë¦¬ ìƒì„± í™•ì¸
        if let applicationSupportURL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
            // Application Support ë””ë ‰í† ë¦¬ê°€ ì—†ë‹¤ë©´ ìƒì„±
            if !FileManager.default.fileExists(atPath: applicationSupportURL.path) {
                do {
                    try FileManager.default.createDirectory(
                        at: applicationSupportURL,
                        withIntermediateDirectories: true,
                        attributes: nil
                    )
                    print("âœ… Created Application Support directory")
                } catch {
                    print("âŒ Failed to create Application Support directory: \(error)")
                }
            }
            
            // ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ URL ì„¤ì •
            let storeURL = applicationSupportURL.appendingPathComponent("AISnapStudy.sqlite")
            storeDescription.url = storeURL
            
            print("ğŸ“ CoreData store URL: \(storeURL.path)")
            
            // ë§ˆì´ê·¸ë ˆì´ì…˜ ì˜µì…˜ ì„¤ì •
            storeDescription.setOption(true as NSNumber, forKey: NSMigratePersistentStoresAutomaticallyOption)
            storeDescription.setOption(true as NSNumber, forKey: NSInferMappingModelAutomaticallyOption)
            storeDescription.setOption(["journal_mode": "WAL"] as NSDictionary, forKey: NSSQLitePragmasOption)
            storeDescription.setOption(FileProtectionType.complete as NSString, forKey: NSPersistentStoreFileProtectionKey)
            
            container.persistentStoreDescriptions = [storeDescription]
        }
        
        // ì €ì¥ì†Œ ë¡œë“œ
        container.loadPersistentStores { description, error in
            if let error = error {
                print("""
                âŒ CoreData Error:
                â€¢ Error: \(error.localizedDescription)
                â€¢ Description: \(description)
                â€¢ Store URL: \(description.url?.absoluteString ?? "unknown")
                """)
                
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì €ì¥ì†Œ ì¬ìƒì„± ì‹œë„
                if let storeURL = description.url {
                    do {
                        try FileManager.default.removeItem(at: storeURL)
                        print("ğŸ”„ Removed existing store file")
                        
                        // ì €ì¥ì†Œ ì¬ìƒì„±
                        try container.persistentStoreCoordinator.addPersistentStore(
                            ofType: NSSQLiteStoreType,
                            configurationName: nil,
                            at: storeURL,
                            options: [
                                NSMigratePersistentStoresAutomaticallyOption: true,
                                NSInferMappingModelAutomaticallyOption: true
                            ]
                        )
                        print("âœ… Successfully recreated store")
                    } catch {
                        print("âŒ Failed to recreate store: \(error)")
                        fatalError("Unresolved error \(error)")
                    }
                }
            } else {
                print("âœ… CoreData store loaded successfully")
            }
        }
        
        // Context ì„¤ì •
        container.viewContext.automaticallyMergesChangesFromParent = true
        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        
        return container
    }()
    
    // MARK: - Question Operations ì„¹ì…˜ì— ì¶”ê°€
    // MARK: - Question Operations
    public func fetchSavedQuestions() throws -> [Question] {
        print("ğŸ“Š Fetching Saved Questions from CoreData")
        let request: NSFetchRequest<CDQuestion> = CDQuestion.fetchRequest()
        request.predicate = NSPredicate(format: "isSaved == true")
        request.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: false)]
        
        do {
            let cdQuestions = try viewContext.fetch(request)
            print("ğŸ“Š Found \(cdQuestions.count) saved questions")
            
            let questions = cdQuestions.compactMap { cdQuestion -> Question? in
                guard let id = cdQuestion.id,
                      let type = cdQuestion.type,
                      let questionText = cdQuestion.question,
                      let correctAnswer = cdQuestion.correctAnswer,
                      let explanation = cdQuestion.explanation else {
                    print("âš ï¸ Invalid question data found")
                    return nil
                }
                
                let options = cdQuestion.options as? [String] ?? []
                
                return Question(
                    id: id,
                    type: QuestionType(rawValue: type) ?? .multipleChoice,
                    subject: Subject(rawValue: cdQuestion.problemSet?.subject ?? "") ?? .math,
                    difficulty: Difficulty(rawValue: cdQuestion.problemSet?.difficulty ?? "") ?? .medium,
                    question: questionText,
                    options: options,
                    correctAnswer: correctAnswer,
                    explanation: explanation,
                    hint: cdQuestion.hint,
                    isSaved: cdQuestion.isSaved,
                    createdAt: cdQuestion.createdAt ?? Date()
                )
            }
            
            print("âœ… Successfully mapped \(questions.count) saved questions")
            return questions
            
        } catch {
            print("âŒ Failed to fetch saved questions: \(error)")
            throw error
        }
    }

    // ê¸°ì¡´ saveQuestion ë©”ì„œë“œ ìˆ˜ì •
    public func saveQuestion(_ question: Question) throws {
        print("ğŸ’¾ Attempting to save question: \(question.id)")
        
        // ë¨¼ì € ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
        let request: NSFetchRequest<CDQuestion> = CDQuestion.fetchRequest()
        request.predicate = NSPredicate(format: "id == %@", question.id)
        
        do {
            let existingQuestions = try viewContext.fetch(request)
            let cdQuestion: CDQuestion
            
            if let existingQuestion = existingQuestions.first {
                print("ğŸ“ Updating existing question")
                cdQuestion = existingQuestion
            } else {
                print("ğŸ“ Creating new question")
                cdQuestion = CDQuestion(context: viewContext)
            }
            
            // ì§ˆë¬¸ ë°ì´í„° ì—…ë°ì´íŠ¸
            updateCDQuestion(cdQuestion, with: question)
            
            try viewContext.save()
            print("âœ… Successfully saved question: \(question.id)")
            
        } catch {
            print("âŒ Failed to save question: \(error)")
            viewContext.rollback()
            throw error
        }
    }
    
    // viewContextì— ëŒ€í•œ public ì ‘ê·¼ì ì¶”ê°€
    public var viewContext: NSManagedObjectContext {
        persistentContainer.viewContext
    }
    
    private init() {}
    
    // ê³µê°œ ë©”ì„œë“œë“¤...
    public func saveContext() {
        if viewContext.hasChanges {
            do {
                try viewContext.save()
                print("âœ… CoreData context saved successfully")
            } catch {
                print("âŒ CoreData context save error: \(error)")
                viewContext.rollback()
            }
        }
    }
    
    public func newBackgroundContext() -> NSManagedObjectContext {
        let context = persistentContainer.newBackgroundContext()
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return context
    }
    
    // MARK: - ProblemSet Operations
    // File: ./AISnapStudy/CoreData/CoreDataService.swift

    public func fetchProblemSets() throws -> [ProblemSet] {
        print("ğŸ“Š Fetching ProblemSets from CoreData")
        let request: NSFetchRequest<CDProblemSet> = CDProblemSet.fetchRequest()
        request.sortDescriptors = [NSSortDescriptor(key: "createdAt", ascending: false)]
        
        do {
            let cdProblemSets = try viewContext.fetch(request)
            print("ğŸ“Š Fetched \(cdProblemSets.count) ProblemSets from CoreData")
            
            return try cdProblemSets.map { cdProblemSet -> ProblemSet in
                let questions = (cdProblemSet.questions?.allObjects as? [CDQuestion])?
                    .compactMap { cdQuestion -> Question? in
                        guard let id = cdQuestion.id,
                              let type = cdQuestion.type,
                              let questionText = cdQuestion.question,
                              let correctAnswer = cdQuestion.correctAnswer,
                              let explanation = cdQuestion.explanation else {
                            print("âš ï¸ Invalid question data found")
                            return nil
                        }
                        
                        let options = cdQuestion.options as? [String] ?? []
                
                        
                        return Question(
                            id: id,
                            type: QuestionType(rawValue: type) ?? .multipleChoice,
                            subject: Subject(rawValue: cdProblemSet.subject ?? "") ?? .math,
                            difficulty: Difficulty(rawValue: cdProblemSet.difficulty ?? "") ?? .medium,
                            question: questionText,
                            options: options,
                            correctAnswer: correctAnswer,
                            explanation: explanation,
                            hint: cdQuestion.hint,
                            isSaved: cdQuestion.isSaved,
                            createdAt: cdQuestion.createdAt ?? Date()
                        )
                    } ?? []
                
                print("ğŸ“š Loaded \(questions.count) questions for ProblemSet: \(cdProblemSet.id ?? "")")
                
                return ProblemSet(
                    id: cdProblemSet.id ?? UUID().uuidString,
                    title: cdProblemSet.title ?? "",
                    subject: Subject(rawValue: cdProblemSet.subject ?? "") ?? .math,
                    difficulty: Difficulty(rawValue: cdProblemSet.difficulty ?? "") ?? .medium,
                    questions: questions,
                    createdAt: cdProblemSet.createdAt ?? Date(),
                    lastAttempted: cdProblemSet.lastAttempted,
                    educationLevel: EducationLevel(rawValue: cdProblemSet.educationLevel ?? "") ?? .elementary, // ì¶”ê°€
                    name: cdProblemSet.name ?? "Default Name" // ì¶”ê°€
                )

            }
        } catch {
            print("âŒ Failed to fetch ProblemSets: \(error)")
            throw error
        }
    }
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        print("ğŸ“ Starting to save ProblemSet: \(problemSet.id)")
        
        let cdProblemSet = CDProblemSet(context: viewContext)
        cdProblemSet.id = problemSet.id
        cdProblemSet.title = problemSet.title
        cdProblemSet.subject = problemSet.subject.rawValue
        cdProblemSet.difficulty = problemSet.difficulty.rawValue
        cdProblemSet.createdAt = problemSet.createdAt
        cdProblemSet.lastAttempted = problemSet.lastAttempted
        
        // ë¬¸ì œ ì €ì¥ ì „ ë¡œê·¸
        print("ğŸ’¾ Preparing to save \(problemSet.questions.count) questions")
        
        // questions ê´€ê³„ ì„¤ì •
        let questionSet = NSMutableSet()
        
        for question in problemSet.questions {
            let cdQuestion = CDQuestion(context: viewContext)
            cdQuestion.id = question.id
            cdQuestion.type = question.type.rawValue
            cdQuestion.question = question.question
            
            // options ë°°ì—´ ë³€í™˜ ë° ì €ì¥
            cdQuestion.options = NSArray(array: question.options)
            
            cdQuestion.correctAnswer = question.correctAnswer
            cdQuestion.explanation = question.explanation
            cdQuestion.hint = question.hint
            cdQuestion.isSaved = question.isSaved
            cdQuestion.createdAt = question.createdAt
            cdQuestion.problemSet = cdProblemSet
            
            questionSet.add(cdQuestion)
            
            print("âœï¸ Prepared question: \(question.id)")
        }
        
        cdProblemSet.questions = questionSet
        
        do {
            try viewContext.save()
            print("âœ… Successfully saved ProblemSet with \(questionSet.count) questions")
            
            // ì €ì¥ í›„ í™•ì¸
            if let savedQuestions = cdProblemSet.questions {
                print("ğŸ“š Verified \(savedQuestions.count) questions in CoreData")
            }
        } catch {
            print("âŒ Failed to save ProblemSet: \(error)")
            viewContext.rollback()
            throw error
        }
    }
    
    public func deleteQuestion(_ question: Question) throws {
        // Type annotationì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •
        let request = NSFetchRequest<CDQuestion>(entityName: "CDQuestion")
        // ë˜ëŠ” ì•„ë˜ì™€ ê°™ì´ ì‘ì„± ê°€ëŠ¥
        // let request: NSFetchRequest<CDQuestion> = NSFetchRequest(entityName: "CDQuestion")
        
        request.predicate = NSPredicate(format: "id == %@", question.id)
        
        do {
            let questions = try viewContext.fetch(request)
            if let cdQuestion = questions.first {
                viewContext.delete(cdQuestion)
                try viewContext.save()
                print("âœ… Deleted Question: \(question.id)")
            }
        } catch {
            print("âŒ Failed to delete Question: \(error)")
            viewContext.rollback()
            throw error
        }
    }
    
    // MARK: - Helper Methods
    // ì¡°íšŒ ë¡œì§ë„ ìˆ˜ì •
    private func updateCDQuestion(_ cdQuestion: CDQuestion, with question: Question) {
        cdQuestion.id = question.id
        cdQuestion.type = question.type.rawValue
        cdQuestion.question = question.question
        
        // Convert String arrays to NSArray
        cdQuestion.options = NSArray(array: question.options)
        cdQuestion.correctAnswer = question.correctAnswer
        cdQuestion.explanation = question.explanation
        cdQuestion.hint = question.hint
        cdQuestion.isSaved = question.isSaved
        cdQuestion.createdAt = question.createdAt
    }
}

// CDQuestion+Extension ìˆ˜ì •
extension CDQuestion {
    func toDomain() -> Question? {
        guard let id = self.id,
              let type = self.type,
              let question = self.question,
              let correctAnswer = self.correctAnswer,
              let explanation = self.explanation else {
            return nil
        }
        
        // NSArrayë¥¼ [String]ìœ¼ë¡œ ë³€í™˜
        let options = (self.options as? [String]) ?? []
        
        return Question(
            id: id,
            type: QuestionType(rawValue: type) ?? .multipleChoice,
            subject: Subject(rawValue: self.problemSet?.subject ?? "") ?? .math,
            difficulty: Difficulty(rawValue: self.problemSet?.difficulty ?? "") ?? .medium,
            question: question,
            options: options,
            correctAnswer: correctAnswer,
            explanation: explanation,
            hint: self.hint,
            isSaved: self.isSaved,
            createdAt: self.createdAt ?? Date()
        )
    }
}


## ./AISnapStudy/CoreData/CoreDataModels+Extensions.swift



import Foundation
import CoreData

// MARK: - CDProblemSet Extension
extension CDProblemSet {
    func toDomain() -> ProblemSet {
        let questions = (self.questions?.allObjects as? [CDQuestion])?.compactMap { question -> Question? in
            question.toDomain()
        } ?? []

        return ProblemSet(
            id: self.id ?? UUID().uuidString,
            title: self.title ?? "",
            subject: Subject(rawValue: self.subject ?? "") ?? .math,
            difficulty: Difficulty(rawValue: self.difficulty ?? "") ?? .medium,
            questions: questions,
            createdAt: self.createdAt ?? Date(),
            lastAttempted: self.lastAttempted,
            educationLevel: EducationLevel(rawValue: self.educationLevel ?? "") ?? .elementary, // ì¶”ê°€
            name: self.name ?? "", // ì¶”ê°€
            tags: self.tags as? [String] ?? [], // ì¶”ê°€
            problemSetDescription: self.problemSetDescription,
            isFavorite: self.isFavorite
        )
    }
}

// MARK: - CDQuestion Extension
extension CDQuestion {
    func toDomain() -> Question {
        Question(
            id: self.id ?? UUID().uuidString,
            type: QuestionType(rawValue: self.type ?? "") ?? .multipleChoice,
            subject: Subject(rawValue: self.problemSet?.subject ?? "") ?? .math,
            difficulty: Difficulty(rawValue: self.problemSet?.difficulty ?? "") ?? .medium,
            question: self.question ?? "",
            options: self.options as? [String] ?? [],
            correctAnswer: self.correctAnswer ?? "",
            explanation: self.explanation ?? "",
            hint: self.hint,
            isSaved: self.isSaved,
            createdAt: self.createdAt ?? Date()
        )
    }
}

// MARK: - CDStudySession Extension
// MARK: - CDStudySession Extension
extension CDStudySession {
    func toDomain() -> StudySession {
        StudySession(
            id: self.id ?? UUID().uuidString,
            problemSet: self.problemSet?.toDomain() ?? ProblemSet(
                id: UUID().uuidString,
                title: "Unknown",
                subject: .math,
                difficulty: .medium,
                questions: [],
                createdAt: Date(),
                educationLevel: .elementary, // ì¶”ê°€
                name: "Default Name" // ì¶”ê°€
            ),
            startTime: self.startTime ?? Date(),
            endTime: self.endTime,
            answers: self.answers as? [String: String] ?? [:],
            score: Int(self.score)
        )
    }
}


## ./AISnapStudy/CoreData/CDQuestion+CoreDataClass.swift



import Foundation
import CoreData


public class CDQuestion: NSManagedObject {

}


## ./AISnapStudy/CoreData/CDStudySession+CoreDataClass.swift

//
//  CDStudySession+CoreDataClass.swift
//  AISnapStudy
//
//  Created by sunghwan ki on 11/10/24.
//
//

import Foundation
import CoreData


public class CDStudySession: NSManagedObject {

}


## ./AISnapStudy/CoreData/CDProblemSet+CoreDataProperties.swift



import Foundation
import CoreData


extension CDProblemSet {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDProblemSet> {
        return NSFetchRequest<CDProblemSet>(entityName: "CDProblemSet")
    }

    @NSManaged public var createdAt: Date?
    @NSManaged public var difficulty: String?
    @NSManaged public var educationLevel: String?
    @NSManaged public var id: String?
    @NSManaged public var isFavorite: Bool
    @NSManaged public var lastAttempted: Date?
    @NSManaged public var name: String?
    @NSManaged public var problemSetDescription: String?
    @NSManaged public var subject: String?
    @NSManaged public var tags: NSArray?
    @NSManaged public var title: String?
    @NSManaged public var questions: NSSet?

}

// MARK: Generated accessors for questions
extension CDProblemSet {

    @objc(addQuestionsObject:)
    @NSManaged public func addToQuestions(_ value: CDQuestion)

    @objc(removeQuestionsObject:)
    @NSManaged public func removeFromQuestions(_ value: CDQuestion)

    @objc(addQuestions:)
    @NSManaged public func addToQuestions(_ values: NSSet)

    @objc(removeQuestions:)
    @NSManaged public func removeFromQuestions(_ values: NSSet)

}

extension CDProblemSet : Identifiable {

}


## ./AISnapStudy/CoreData/CDQuestion+CoreDataProperties.swift



import Foundation
import CoreData


extension CDQuestion {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDQuestion> {
        return NSFetchRequest<CDQuestion>(entityName: "CDQuestion")
    }

    @NSManaged public var attribute: String?
    @NSManaged public var correctAnswer: String?
    @NSManaged public var createdAt: Date?
    @NSManaged public var explanation: String?
    @NSManaged public var hint: String?
    @NSManaged public var id: String?
    @NSManaged public var isCorrect: Bool
    @NSManaged public var isSaved: Bool
    @NSManaged public var options: NSObject?
    @NSManaged public var question: String?
    @NSManaged public var type: String?
    @NSManaged public var problemSet: CDProblemSet?
    @NSManaged public var session: CDStudySession?

}

extension CDQuestion : Identifiable {

}


## ./AISnapStudy/CoreData/CDStudySession+CoreDataProperties.swift

//
//  CDStudySession+CoreDataProperties.swift
//  AISnapStudy
//
//  Created by sunghwan ki on 11/10/24.
//
//

import Foundation
import CoreData


extension CDStudySession {

    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDStudySession> {
        return NSFetchRequest<CDStudySession>(entityName: "CDStudySession")
    }

    @NSManaged public var answers: NSObject?
    @NSManaged public var endTime: Date?
    @NSManaged public var id: String?
    @NSManaged public var score: Int16
    @NSManaged public var startTime: Date?
    @NSManaged public var problemSet: CDProblemSet?
    @NSManaged public var questions: NSSet?

}

// MARK: Generated accessors for questions
extension CDStudySession {

    @objc(addQuestionsObject:)
    @NSManaged public func addToQuestions(_ value: CDQuestion)

    @objc(removeQuestionsObject:)
    @NSManaged public func removeFromQuestions(_ value: CDQuestion)

    @objc(addQuestions:)
    @NSManaged public func addToQuestions(_ values: NSSet)

    @objc(removeQuestions:)
    @NSManaged public func removeFromQuestions(_ values: NSSet)

}

extension CDStudySession : Identifiable {

}


## ./AISnapStudy/CoreData/CDProblemSet+CoreDataClass.swift

//
//  CDProblemSet+CoreDataClass.swift
//  AISnapStudy
//
//  Created by sunghwan ki on 11/11/24.
//
//

import Foundation
import CoreData


public class CDProblemSet: NSManagedObject {

}


## ./AISnapStudy/Utils/Constants.swift


import SwiftUI

enum Constants {
    enum API {
        static let baseURL = "https://api.openai.com/v1"
        static let version = "v1"
    }
    
    enum UI {
        static let cornerRadius: CGFloat = 10
        static let spacing: CGFloat = 16
        static let padding: CGFloat = 20
    }
    
    enum Storage {
        static let problemSetsKey = "problemSets"
        static let savedQuestionsKey = "savedQuestions"
        static let userPreferencesKey = "userPreferences"
    }
}


## ./AISnapStudy/Utils/HapticManager.swift

// File: ./AISnapStudy/Utils/HapticManager.swift

import UIKit

class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.impactOccurred()
    }
    
    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.notificationOccurred(type)
    }
    
    func selection() {
        let generator = UISelectionFeedbackGenerator()
        generator.selectionChanged()
    }
}


## ./AISnapStudy/Utils/Extensions/Date+Extension.swift


import Foundation
import SwiftUI

extension Date {
    var timeAgo: String {
        let calendar = Calendar.current
        let now = Date()
        let components = calendar.dateComponents([.minute, .hour, .day], from: self, to: now)
        
        if let days = components.day, days > 0 {
            return days == 1 ? "1 day ago" : "\(days) days ago"
        }
        
        if let hours = components.hour, hours > 0 {
            return hours == 1 ? "1 hour ago" : "\(hours) hours ago"
        }
        
        if let minutes = components.minute, minutes > 0 {
            return minutes == 1 ? "1 minute ago" : "\(minutes) minutes ago"
        }
        
        return "Just now"
    }
    
    func format(_ format: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = format
        return formatter.string(from: self)
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}


## ./AISnapStudy/Utils/Extensions/Bundle+Extension.swift



import Foundation

extension Bundle {
    var appVersion: String {
        return infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0"
    }
}


## ./AISnapStudy/Utils/Extensions/Color+Extension.swift


import SwiftUI

extension Color {
    static let mainBackground = Color("MainBackground")
    static let customAccent = Color("AccentColor")
    
    // Custom colors for subjects
    static let languageArtsLight = Color.blue.opacity(0.2)
    static let mathLight = Color.green.opacity(0.2)
    
    // Custom colors for difficulties
    static let easyBackground = Color.green.opacity(0.2)
    static let mediumBackground = Color.orange.opacity(0.2)
    static let hardBackground = Color.red.opacity(0.2)
}



## ./AISnapStudy/Utils/Extensions/View+Extension.swift


import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
    
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .leading,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}


## ./AISnapStudy/Utils/Helpers/ImageCompressor.swift

// Utils/Helpers/ImageCompressor.swift
import UIKit

enum ImageCompressorError: Error {
    case compressionFailed
    case invalidImage
}

class ImageCompressor {
    static let shared = ImageCompressor()
    
    private enum Constraints {
        // íŒŒì¼ í¬ê¸° ì œí•œì„ ë” ë‚®ê²Œ ì„¤ì • (400KBë¡œ ì¤„ì„)
        static let targetFileSize = 400 * 1024  // 400KB
        // ìµœëŒ€ ì¹˜ìˆ˜ë¥¼ ë” ì‘ê²Œ ì„¤ì • (800 -> 640)
        static let maxDimension: CGFloat = 640
        static let minDimension: CGFloat = 320
        // ìµœì†Œ í’ˆì§ˆì„ ë‚®ì¶¤ (0.5 -> 0.3)
        static let minimumQuality: CGFloat = 0.3
    }
    
    private init() {}
    
    func compress(
        image: UIImage,
        maxSize: Int = Constraints.targetFileSize,
        maxDimension: CGFloat = Constraints.maxDimension
    ) throws -> Data {
        let startTime = Date()
        
        // ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸° ë¡œê¹…
        if let originalData = image.jpegData(compressionQuality: 1.0) {
            print("ğŸ“¸ Original image size: \(formatFileSize(originalData.count))")
            print("ğŸ“ Original dimensions: \(Int(image.size.width))x\(Int(image.size.height))")
        }
        
        // ë¦¬ì‚¬ì´ì§•
        let resizedImage = resizeImage(image, maxDimension: maxDimension)
        print("âœ‚ï¸ Resized dimensions: \(Int(resizedImage.size.width))x\(Int(resizedImage.size.height))")
        
        // ì••ì¶• ì‹œì‘ í’ˆì§ˆì„ 0.6ì—ì„œ 0.3ìœ¼ë¡œ ë‚®ì¶¤
        var compression: CGFloat = 0.3
        var compressedData = resizedImage.jpegData(compressionQuality: compression)!
        
        while compressedData.count > maxSize && compression > Constraints.minimumQuality {
            compression -= 0.1
            if let newData = resizedImage.jpegData(compressionQuality: compression) {
                compressedData = newData
                print("ğŸ”„ Trying compression quality: \(String(format: "%.1f", compression))")
                print("ğŸ“¦ Current size: \(formatFileSize(compressedData.count))")
            }
        }
        
        if compressedData.count > maxSize {
            let scale = sqrt(Double(maxSize) / Double(compressedData.count))
            let newSize = CGSize(
                width: resizedImage.size.width * scale,
                height: resizedImage.size.height * scale
            )
            
            let finalImage = UIGraphicsImageRenderer(size: newSize).image { _ in
                resizedImage.draw(in: CGRect(origin: .zero, size: newSize))
            }
            
            compressedData = finalImage.jpegData(compressionQuality: compression) ?? compressedData
            print("ğŸ“ Final resize dimensions: \(Int(newSize.width))x\(Int(newSize.height))")
        }
        
        print("""
        âœ… Compression completed:
        â€¢ Duration: \(String(format: "%.2f", Date().timeIntervalSince(startTime)))s
        â€¢ Final size: \(formatFileSize(compressedData.count))
        â€¢ Compression ratio: \(String(format: "%.1f", Float(compressedData.count) / Float(image.jpegData(compressionQuality: 1.0)?.count ?? 1) * 100))%
        """)
        
        return compressedData
    }

    
    private func resizeImage(_ image: UIImage, maxDimension: CGFloat) -> UIImage {
        let originalSize = image.size
        var targetSize = originalSize
        
        // ìµœì†Œ/ìµœëŒ€ í¬ê¸° ì œí•œ ì ìš©
        if originalSize.width > maxDimension || originalSize.height > maxDimension {
            let widthRatio = maxDimension / originalSize.width
            let heightRatio = maxDimension / originalSize.height
            let ratio = min(widthRatio, heightRatio)
            targetSize = CGSize(
                width: max(Constraints.minDimension, originalSize.width * ratio),
                height: max(Constraints.minDimension, originalSize.height * ratio)
            )
        }
        
        let format = UIGraphicsImageRendererFormat()
        format.scale = 1
        
        let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
        return renderer.image { context in
            image.draw(in: CGRect(origin: .zero, size: targetSize))
        }
    }
    
    private func formatFileSize(_ bytes: Int) -> String {
        return ByteCountFormatter.string(fromByteCount: Int64(bytes), countStyle: .file)
    }
}


## ./AISnapStudy/Utils/Helpers/ErrorHandler.swift

// Utils/Helpers/ErrorHandler.swift
import Foundation

enum AppError: Error {
    case networkError(String)
    case imageProcessingError(String)
    case storageError(String)
    case openAIError(String)
}

class ErrorHandler {
    static func handle(_ error: Error) {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì—ëŸ¬ ë¡œê¹…, ì‚¬ìš©ì ì•Œë¦¼ ë“±ì„ ì²˜ë¦¬
        print("Error occurred: \(error.localizedDescription)")
    }
}


## ./AISnapStudy/Utils/Helpers/ConfigurationManager.swift

// Utils/Helpers/ConfigurationManager.swift
import Foundation

enum ConfigurationError: Error {
    case missingKey(String)
    case invalidPlistFile
}

class ConfigurationManager {
    static let shared = ConfigurationManager()
    private var configurations: [String: Any]?
    
    private init() {
        loadConfigurations()
    }
    
    private func loadConfigurations() {
        guard let plistPath = Bundle.main.path(forResource: "Configuration", ofType: "plist"),
              let plistData = FileManager.default.contents(atPath: plistPath),
              let plist = try? PropertyListSerialization.propertyList(from: plistData, format: nil) as? [String: Any] else {
            return
        }
        
        configurations = plist
    }
    
    func getValue(for key: String) throws -> String {
        guard let configurations = configurations else {
            throw ConfigurationError.invalidPlistFile
        }
        
        guard let value = configurations[key] as? String else {
            throw ConfigurationError.missingKey(key)
        }
        
        return value
    }
}


## ./AISnapStudy/Models/DailyProgress.swift


import Foundation

struct DailyProgress: Identifiable {
    let id = UUID()
    let date: Date
    let day: String          // "Mon", "Tue", etc.
    let questionsCompleted: Int
    let correctAnswers: Int
    let totalTime: TimeInterval
    
    var accuracy: Double {
        guard questionsCompleted > 0 else { return 0 }
        return Double(correctAnswers) / Double(questionsCompleted) * 100
    }
    
    init(date: Date, questionsCompleted: Int, correctAnswers: Int, totalTime: TimeInterval) {
        self.date = date
        self.day = date.formatted(.dateTime.weekday(.abbreviated))
        self.questionsCompleted = questionsCompleted
        self.correctAnswers = correctAnswers
        self.totalTime = totalTime
    }
}


## ./AISnapStudy/Models/OpenAIModels.swift



import Foundation

// MARK: - OpenAI Response Models
struct OpenAIResponse: Codable {
    let id: String
    let object: String
    let created: Int
    let model: String
    let choices: [Choice]
    let usage: Usage
}

struct Choice: Codable {
    let message: Message
    let finishReason: String?
    
    enum CodingKeys: String, CodingKey {
        case message
        case finishReason = "finish_reason"
    }
}

struct Message: Codable {
    let role: String
    let content: String
    let refusal: String? // ì¶”ê°€: Structured Outputsì˜ refusal ì²˜ë¦¬ë¥¼ ìœ„í•´
}

struct Usage: Codable {
    let promptTokens: Int
    let completionTokens: Int
    let totalTokens: Int
    
    enum CodingKeys: String, CodingKey {
        case promptTokens = "prompt_tokens"
        case completionTokens = "completion_tokens"
        case totalTokens = "total_tokens"
    }
}

// MARK: - Error Response Models
struct OpenAIErrorResponse: Codable {
    let error: OpenAIError
    
    struct OpenAIError: Codable {
        let message: String
        let type: String?
        let code: String?
    }
}

// MARK: - Question Generation Schema
struct QuestionGenerationSchema: Codable {
    let questions: [QuestionData]
    
    struct QuestionData: Codable {
        let type: String
        let question: String
        let options: [String]
        let correctAnswer: String
        let explanation: String
        let hint: String?
        
        enum CodingKeys: String, CodingKey {
            case type
            case question
            case options
            case correctAnswer
            case explanation
            case hint
        }
    }
}


## ./AISnapStudy/Models/ProblemSet.swift


import Foundation

public struct ProblemSet: Identifiable, Codable {
    public let id: String
    public let title: String
    public let subject: Subject
    public let difficulty: Difficulty
    public let questions: [Question]
    public let createdAt: Date
    public var lastAttempted: Date?
    
    
    // ìƒˆë¡œ ì¶”ê°€í•  ì†ì„±ë“¤
    public let educationLevel: EducationLevel
    public var name: String
    public var tags: [String]
    public var problemSetDescription: String?
    public var isFavorite: Bool
    
    public var questionCount: Int {
        questions.count
    }
    
    public init(
          id: String,
          title: String,
          subject: Subject,
          difficulty: Difficulty,
          questions: [Question],
          createdAt: Date,
          lastAttempted: Date? = nil,
          educationLevel: EducationLevel,
          name: String,
          tags: [String] = [],
          problemSetDescription: String? = nil,
          isFavorite: Bool = false
      ) {
          self.id = id
          self.title = title
          self.subject = subject
          self.difficulty = difficulty
          self.questions = questions
          self.createdAt = createdAt
          self.lastAttempted = lastAttempted
          self.educationLevel = educationLevel
          self.name = name
          self.tags = tags
          self.problemSetDescription = problemSetDescription
          self.isFavorite = isFavorite
      }
}

// MARK: - Hashable
extension ProblemSet: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: ProblemSet, rhs: ProblemSet) -> Bool {
        lhs.id == rhs.id
    }
}


## ./AISnapStudy/Models/HistoryFilter.swift


import Foundation

enum HistoryFilter: String, CaseIterable {
    case all = "All"
    case language = "Language"
    case math = "Math"
    case geography = "Geography"
    case history = "History"
    case science = "Science"
    case generalKnowledge = "General Knowledge"
    case saved = "Saved"
    case completed = "Completed"
    case inProgress = "In Progress"
}



## ./AISnapStudy/Models/User.swift


import Foundation

struct User: Codable, Identifiable {
    let id: String
    var name: String
    var email: String
    var preferences: UserPreferences
    var createdAt: Date
    var lastActive: Date
    
    struct UserPreferences: Codable {
        var isDarkMode: Bool
        var notificationsEnabled: Bool
        var dailyGoal: Int
        var preferredDifficulty: Difficulty
    }
}


## ./AISnapStudy/Models/Question.swift



import Foundation

public enum QuestionType: String, Codable {
    case multipleChoice = "multiple_choice"
    case fillInBlanks = "fill_in_blanks"
    case trueFalse = "true_false"  
}

public struct Question: Identifiable, Codable {
    public let id: String
    public let type: QuestionType
    public let subject: Subject
    public let difficulty: Difficulty
    public let question: String
    public let options: [String]
    public let correctAnswer: String
    public let explanation: String
    public let hint: String?
    public var isSaved: Bool
    public let createdAt: Date
    
    public init(
        id: String,
        type: QuestionType,
        subject: Subject,
        difficulty: Difficulty,
        question: String,
        options: [String] = [],
        correctAnswer: String,
        explanation: String,
        hint: String? = nil,
        isSaved: Bool = false,
        createdAt: Date = Date()
    ) {
        self.id = id
        self.type = type
        self.subject = subject
        self.difficulty = difficulty
        self.question = question
        self.options = options
        self.correctAnswer = correctAnswer
        self.explanation = explanation
        self.hint = hint
        self.isSaved = isSaved
        self.createdAt = createdAt
    }
}

// MARK: - QuestionData for NSSecureCoding
public class QuestionData: NSObject, NSSecureCoding {
    public static var supportsSecureCoding: Bool {
        return true
    }
    
    let question: Question
    
    init(question: Question) {
        self.question = question
        super.init()
    }
    
    public func encode(with coder: NSCoder) {
        coder.encode(question.id, forKey: "id")
        coder.encode(question.type.rawValue, forKey: "type")
        coder.encode(question.subject.rawValue, forKey: "subject")
        coder.encode(question.difficulty.rawValue, forKey: "difficulty")
        coder.encode(question.question, forKey: "question")
        coder.encode(question.options, forKey: "options")
        coder.encode(question.correctAnswer, forKey: "correctAnswer")
        coder.encode(question.explanation, forKey: "explanation")
        coder.encode(question.hint, forKey: "hint")
        coder.encode(question.isSaved, forKey: "isSaved")
        coder.encode(question.createdAt, forKey: "createdAt")
    }
    
    public required init?(coder: NSCoder) {
        guard let id = coder.decodeObject(of: NSString.self, forKey: "id") as String?,
              let typeRaw = coder.decodeObject(of: NSString.self, forKey: "type") as String?,
              let subjectRaw = coder.decodeObject(of: NSString.self, forKey: "subject") as String?,
              let difficultyRaw = coder.decodeObject(of: NSString.self, forKey: "difficulty") as String?,
              let questionText = coder.decodeObject(of: NSString.self, forKey: "question") as String?,
              let options = coder.decodeObject(of: [NSArray.self, NSString.self], forKey: "options") as? [String],
              let correctAnswer = coder.decodeObject(of: NSString.self, forKey: "correctAnswer") as String?,
              let explanation = coder.decodeObject(of: NSString.self, forKey: "explanation") as String? else {
            return nil
        }
        
        let hint = coder.decodeObject(of: NSString.self, forKey: "hint") as String?
        let isSaved = coder.decodeBool(forKey: "isSaved")
        let createdAt = coder.decodeObject(of: NSDate.self, forKey: "createdAt") as Date? ?? Date()
        
        let question = Question(
            id: id,
            type: QuestionType(rawValue: typeRaw) ?? .multipleChoice,
            subject: Subject(rawValue: subjectRaw) ?? .math,
            difficulty: Difficulty(rawValue: difficultyRaw) ?? .medium,
            question: questionText,
            options: options,
            correctAnswer: correctAnswer,
            explanation: explanation,
            hint: hint,
            isSaved: isSaved,
            createdAt: createdAt
        )
        
        self.question = question
        super.init()
    }
}

// MARK: - Hashable
extension Question: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: Question, rhs: Question) -> Bool {
        lhs.id == rhs.id
    }
}


## ./AISnapStudy/Models/Subject.swift


import SwiftUI

public enum Subject: String, Codable, CaseIterable {
    case language = "language"
    case math = "math"
    case geography = "geography"
    case history = "history"
    case science = "science"
    case generalKnowledge = "general_knowledge"
    
    public var color: Color {
        switch self {
        case .language:
            return .green
        case .math:
            return .green
        case .geography:
            return .green
        case .history:
            return .green
        case .science:
            return .green
        case .generalKnowledge:
            return .green
        }
    }
    
    public var displayName: String {
        switch self {
        case .language:
            return "Language"
        case .math:
            return "Mathematics"
        case .geography:
            return "Geography"
        case .history:
            return "History"
        case .science:
            return "Science"
        case .generalKnowledge:
            return "General Knowledge"
        }
    }
    
    public var icon: String {
        switch self {
        case .language:
            return "textformat"
        case .math:
            return "function"
        case .geography:
            return "globe"
        case .history:
            return "clock.fill"
        case .science:
            return "atom"
        case .generalKnowledge:
            return "book.fill"
        }
    }
}

public enum EducationLevel: String, Codable, CaseIterable {
    case elementary = "elementary"
    case middle = "middle"
    case high = "high"
    case college = "college"
    
    public var displayName: String {
        switch self {
        case .elementary:
            return "Elementary"
        case .middle:
            return "Middle"
        case .high:
            return "High"
        case .college:
            return "College"
        }
    }
    
    public var color: Color {
        switch self {
        case .elementary:
            return .green
        case .middle:
            return .green
        case .high:
            return .green
        case .college:
            return .green
        }
    }
}

public enum Difficulty: String, Codable, CaseIterable {
    case easy = "easy"
    case medium = "medium"
    case hard = "hard"
    
    public var iconName: String {
            switch self {
            case .easy:
                return "1.circle.fill"
            case .medium:
                return "2.circle.fill"
            case .hard:
                return "3.circle.fill"
            }
        }
    
    public var color: Color {
        switch self {
        case .easy:
            return .green
        case .medium:
            return .green
        case .hard:
            return .green
        }
    }
    
    public var displayName: String {
        rawValue.capitalized
    }
    
    public var icon: String {
        switch self {
        case .easy:
            return "1.circle.fill"
        case .medium:
            return "2.circle.fill"
        case .hard:
            return "3.circle.fill"
        }
    }
    
    // ë‚œì´ë„ë¥¼ ìˆ«ìë¡œ í‘œí˜„
    public var level: Int {
        switch self {
        case .easy: return 1
        case .medium: return 2
        case .hard: return 3
        }
    }
}


## ./AISnapStudy/Models/StudySession.swift


import Foundation

public struct StudySession: Identifiable, Codable {
    public let id: String
    public let problemSet: ProblemSet
    public let startTime: Date
    public var endTime: Date?
    public var answers: [String: String] // [QuestionId: UserAnswer]
    public var score: Int?
    
    public var duration: TimeInterval? {
        guard let endTime = endTime else { return nil }
        return endTime.timeIntervalSince(startTime)
    }
    
    public init(
        id: String = UUID().uuidString,
        problemSet: ProblemSet,
        startTime: Date = Date(),
        endTime: Date? = nil,
        answers: [String: String] = [:],
        score: Int? = nil
    ) {
        self.id = id
        self.problemSet = problemSet
        self.startTime = startTime
        self.endTime = endTime
        self.answers = answers
        self.score = score
    }
}

// MARK: - Computed Properties
extension StudySession {
    public var isCompleted: Bool {
        endTime != nil
    }
    
    public var isSaved: Bool {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì €ì¥ ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” ë¡œì§ ì¶”ê°€
        false
    }
    
    public var correctAnswers: [String: String] {
        var answers: [String: String] = [:]
        for question in problemSet.questions {
            answers[question.id] = question.correctAnswer
        }
        return answers
    }
}

// MARK: - Hashable
extension StudySession: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
    
    public static func == (lhs: StudySession, rhs: StudySession) -> Bool {
        lhs.id == rhs.id
    }
}


## ./AISnapStudy/Models/NetworkError.swift


import Foundation

enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case connectionLost
    case invalidResponse
    case invalidData
    case apiError(String)
    case unknown(Error)
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return "No internet connection available. Please check your connection and try again."
        case .timeout:
            return "The request timed out. Please try again."
        case .connectionLost:
            return "The network connection was lost. Please try again."
        case .invalidResponse:
            return "Invalid response received from the server."
        case .invalidData:
            return "Invalid data received from the server."
        case .apiError(let message):
            return "API Error: \(message)"
        case .unknown(let error):
            return "An unexpected error occurred: \(error.localizedDescription)"
        }
    }
}


## ./AISnapStudy/Views/Shared/CustomNavigationBar.swift


import SwiftUI

struct CustomNavigationBar: View {
    let title: String
    var subtitle: String? = nil
    var leadingButton: (() -> AnyView)? = nil
    var trailingButton: (() -> AnyView)? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                if let leading = leadingButton {
                    leading()
                }
                
                Spacer()
                
                VStack {
                    Text(title)
                        .font(.headline)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                
                if let trailing = trailingButton {
                    trailing()
                }
            }
            .padding()
            
            Divider()
        }
        .background(Color.white)
    }
}


## ./AISnapStudy/Views/Question/QuestionCardView.swift


import SwiftUI

struct QuestionCardView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    @Binding var isCorrect: Bool? // Bind to indicate if answer is correct
    var onAnswerSelected: (Bool) -> Void // Closure to handle answer selection
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.title3)
                .fontWeight(.semibold)
            
            // Answer options
            ForEach(question.options, id: \.self) { option in
                Button(action: {
                    selectedAnswer = option
                    let correct = checkAnswer(option)
                    isCorrect = correct
                    onAnswerSelected(correct) // Pass result to parent view
                }) {
                    HStack {
                        Text(option)
                        Spacer()
                        if selectedAnswer == option {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                        }
                    }
                    .padding()
                    .background(
                        selectedAnswer == option ?
                            (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                            Color.gray.opacity(0.1)
                    )
                    .cornerRadius(8)
                }
                .disabled(selectedAnswer != nil) // Disable buttons after selection
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
    
    // Check if selected answer is correct
    private func checkAnswer(_ option: String) -> Bool {
        return option == question.correctAnswer
    }
}


## ./AISnapStudy/Views/Question/QuestionSettingsView.swift


// File: ./AISnapStudy/Views/Question/QuestionSettingsView.swift

import SwiftUI
import PhotosUI
import UIKit

import SwiftUI
import PhotosUI
import UIKit

struct QuestionSettingsView: View {
   let subject: Subject
   @StateObject private var viewModel: QuestionSettingsViewModel
   @Environment(\.dismiss) private var dismiss
   @Binding var selectedTab: Int
   @State private var expandedSections: Set<SectionType> = []
   @State private var isTextInputSelected = false
   
   enum SectionType {
       case learningSubject
       case educationLevel
       case difficultyLevel
       case questionTypes
   }
   
   init(subject: Subject,
        homeViewModel: HomeViewModel,
        selectedTab: Binding<Int>) {
       self.subject = subject
       self._viewModel = StateObject(wrappedValue: QuestionSettingsViewModel(
           subject: subject,
           homeViewModel: homeViewModel
       ))
       self._selectedTab = selectedTab
   }
   
   var body: some View {
       VStack(spacing: 0) {
           Form {
               // Question About Section
               Section {
                   DisclosureGroup(
                       isExpanded: .constant(true)
                   ) {
                       VStack(spacing: 16) {
                           HStack(spacing: 12) {
                               ImageOptionCard(
                                   icon: "camera.fill",
                                   isUsed: viewModel.hasSelectedCamera,
                                   isDisabled: !viewModel.canUseImageInput,
                                   action: {
                                       if viewModel.canUseImageInput {
                                           isTextInputSelected = false
                                           Task { await viewModel.takePhoto() }
                                       }
                                   }
                               )
                               
                               ImageOptionCard(
                                   icon: "photo.fill",
                                   isUsed: viewModel.hasSelectedGallery,
                                   isDisabled: !viewModel.canUseImageInput,
                                   action: {
                                       if viewModel.canUseImageInput {
                                           isTextInputSelected = false
                                           Task { await viewModel.selectFromGallery() }
                                       }
                                   }
                               )
                               
                               ImageOptionCard(
                                   icon: "text.bubble.fill",
                                   isUsed: viewModel.isTextInputActive,
                                   isDisabled: !viewModel.canUseTextInput,
                                   action: {
                                       isTextInputSelected.toggle()
                                       viewModel.toggleTextInput()
                                   }
                               )
                           }
                           .padding(.horizontal)
                           
                           if viewModel.isTextInputActive {
                               TextField("Enter your question here...", text: $viewModel.questionText)
                                   .textFieldStyle(RoundedBorderTextFieldStyle())
                           }
                           
                           if !viewModel.selectedImages.isEmpty {
                               ScrollView(.horizontal, showsIndicators: false) {
                                   HStack(spacing: 12) {
                                       ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                           SelectedImageCell(
                                               image: viewModel.selectedImages[index],
                                               onDelete: {
                                                   viewModel.removeImage(at: index)
                                               }
                                           )
                                       }
                                   }
                                   .padding(.vertical, 8)
                               }
                           }
                       }
                   } label: {
                       HStack {
                           Text("Question About")
                               .font(.headline)
                           Spacer()
                           if !viewModel.selectedImages.isEmpty {
                               Text("\(viewModel.selectedImages.count) selected")
                                   .foregroundColor(.green)
                           } else if !viewModel.questionText.isEmpty {
                               Text("Text input")
                                   .foregroundColor(.green)
                           }
                       }
                   }
               }.listRowSpacing(0)
               
               // Learning Subject Section
               Section {
                   DisclosureGroup(
                       isExpanded: isExpandedBinding(for: .learningSubject)
                   ) {
                       LearningSubjectSection(selectedSubject: $viewModel.selectedSubject)
                   } label: {
                       HStack {
                           Text("Learning Subject")
                               .font(.headline)
                           Spacer()
                           Text(viewModel.selectedSubject.displayName)
                               .foregroundColor(.gray)
                       }
                   }
               }.listRowSpacing(0)
               
               // Question Types Section
               Section {
                   DisclosureGroup(
                       isExpanded: isExpandedBinding(for: .questionTypes)
                   ) {
                       QuestionTypesSelectionSection(viewModel: viewModel)
                   } label: {
                       HStack {
                           Text("Question Types")
                               .font(.headline)
                           Spacer()
                           Text("\(viewModel.totalQuestionCount) questions")
                               .foregroundColor(.gray)
                       }
                   }
               }.listRowSpacing(0)
               
               if isTextInputSelected {
                   // Education Level Section
                   Section {
                       DisclosureGroup(
                           isExpanded: isExpandedBinding(for: .educationLevel)
                       ) {
                           EducationLevelSelectionSection(selectedLevel: $viewModel.educationLevel)
                       } label: {
                           HStack {
                               Text("Education Level")
                                   .font(.headline)
                               Spacer()
                               Text(viewModel.educationLevel.displayName)
                                   .foregroundColor(.gray)
                           }
                       }
                   }.listRowSpacing(0)
                   
                   // Difficulty Level Section
                   Section {
                       DisclosureGroup(
                           isExpanded: isExpandedBinding(for: .difficultyLevel)
                       ) {
                           DifficultyLevelSection(difficulty: $viewModel.difficulty)
                       } label: {
                           HStack {
                               Text("Difficulty Level")
                                   .font(.headline)
                               Spacer()
                               Text(viewModel.difficulty.displayName)
                                   .foregroundColor(.gray)
                           }
                       }
                   }.listRowSpacing(0)
               }
           }.listSectionSpacing(4)
           
           // Generate Questions Button
           VStack {
               Button(action: {
                   Task {
                       await viewModel.sendAllImages()
                   }
               }) {
                   Text("Generate Questions")
                       .font(.headline)
                       .foregroundColor(.white)
                       .frame(maxWidth: .infinity)
                       .padding()
                       .background(isGenerateButtonEnabled ? Color.accentColor : Color.gray)
                       .cornerRadius(10)
               }
               .disabled(!isGenerateButtonEnabled)
               .padding()
           }
           .background(Color(UIColor.systemGroupedBackground))
       }
       .navigationBarItems(
           leading: Button("Cancel") {
               viewModel.resetCounts()
               dismiss()
           }
       )
       .navigationBarTitleDisplayMode(.inline)
       .sheet(isPresented: $viewModel.showImagePicker) {
           PhotoPicker(selectedImages: $viewModel.selectedImages)
       }
       .sheet(isPresented: $viewModel.showCamera) {
           ImagePicker(
               image: $viewModel.selectedImage,
               sourceType: .camera,
               onImageSelected: { image in
                   Task {
                       await viewModel.handleCameraImage(image)
                   }
               }
           )
       }
       .alert(isPresented: $viewModel.showAlert) {
           Alert(
               title: Text(viewModel.alertTitle),
               message: Text(viewModel.alertMessage),
               dismissButton: .default(Text("OK")) {
                   if viewModel.alertTitle == "Success" {
                       dismiss()
                   }
               }
           )
       }
       .onChange(of: viewModel.shouldShowStudyView) { show in
           if show {
               dismiss()
               selectedTab = 1  // Study íƒ­ìœ¼ë¡œ ì „í™˜
           }
       }
       .overlay {
           if viewModel.isLoading {
               LoadingView()
           }
       }
   }
   
   private var isGenerateButtonEnabled: Bool {
       let hasInput = !viewModel.selectedImages.isEmpty ||
                     (!viewModel.questionText.isEmpty && viewModel.isTextInputActive)
       let hasQuestionType = viewModel.totalQuestionCount > 0
       return hasInput && hasQuestionType
   }
   
   private func isExpandedBinding(for section: SectionType) -> Binding<Bool> {
       Binding(
           get: { expandedSections.contains(section) },
           set: { isExpanded in
               withAnimation {
                   if isExpanded {
                       expandedSections.insert(section)
                   } else {
                       expandedSections.remove(section)
                   }
               }
           }
       )
   }
}



struct LearningSubjectSection: View {
   @Binding var selectedSubject: Subject
   
   let columns = [
       GridItem(.flexible()),
       GridItem(.flexible()),
       GridItem(.flexible())
   ]
   
   var body: some View {
       LazyVGrid(columns: columns, spacing: 12) {
           ForEach(Subject.allCases, id: \.self) { subject in
               SubjectSelectionButton(
                   subject: subject,
                   isSelected: selectedSubject == subject
               ) {
                   withAnimation(.spring()) {
                       selectedSubject = subject
                   }
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SubjectSelectionButton: View {
   let subject: Subject
   let isSelected: Bool
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           VStack(spacing: 8) {
               Image(systemName: subject.icon)
                   .font(.system(size: 24))
               Text(subject.displayName)
                   .font(.caption)
                   .lineLimit(1)
                   .minimumScaleFactor(0.8)
           }
           .frame(maxWidth: .infinity)
           .padding(.vertical, 12)
           .padding(.horizontal, 8)
           .background(
               RoundedRectangle(cornerRadius: 10)
                   .fill(isSelected ? subject.color.opacity(0.2) : Color.gray.opacity(0.1))
           )
           .foregroundColor(isSelected ? subject.color : .gray)
           .overlay(
               RoundedRectangle(cornerRadius: 10)
                   .stroke(isSelected ? subject.color : Color.clear, lineWidth: 2)
           )
       }
       .buttonStyle(PlainButtonStyle())
   }
}

struct EducationLevelSelectionSection: View {
   @Binding var selectedLevel: EducationLevel
   
   var body: some View {
       LazyVGrid(columns: [
           GridItem(.flexible()),
           GridItem(.flexible())
       ], spacing: 12) {
           ForEach(EducationLevel.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: selectedLevel == level,
                   color: level.color
               ) {
                   selectedLevel = level
               }
           }
       }
       .padding(.vertical, 8)
   }
}

struct SelectableButton: View {
   let title: String
   let isSelected: Bool
   let color: Color
   let action: () -> Void
   
   var body: some View {
       Button(action: action) {
           Text(title)
               .font(.headline)
               .frame(maxWidth: .infinity)
               .padding(.vertical, 12)
               .background(
                   RoundedRectangle(cornerRadius: 8)
                       .fill(isSelected ? color.opacity(0.2) : Color.gray.opacity(0.1))
               )
               .foregroundColor(isSelected ? color : .gray)
               .overlay(
                   RoundedRectangle(cornerRadius: 8)
                       .stroke(isSelected ? color : Color.clear, lineWidth: 2)
               )
       }
       .buttonStyle(PlainButtonStyle())
   }
}

struct DifficultyLevelSection: View {
   @Binding var difficulty: Difficulty
   
   var body: some View {
       HStack(spacing: 12) {
           ForEach(Difficulty.allCases, id: \.self) { level in
               SelectableButton(
                   title: level.displayName,
                   isSelected: difficulty == level,
                   color: level.color
               ) {
                   withAnimation(.spring()) {
                       difficulty = level
                   }
               }
           }
       }
       .padding(.vertical, 8)
   }
}


struct QuestionTypeCard: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel  // ì¶”ê°€
    let title: String
    let icon: String
    @Binding var count: Int
    let maximum: Int = 10
    
    var body: some View {
        VStack(spacing: 8) {
            // Icon and Title
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(count > 0 ? .green : .gray)
                Text(title)
                    .font(.headline)
                    .foregroundColor(count > 0 ? .green : .gray)
            }
            .frame(maxWidth: .infinity)
            .padding(.top, 8)
            
            // Counter with total count
            VStack(spacing: 8) {
                HStack(spacing: 16) {
                    Button {
                        if count > 0 {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count -= 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "minus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(count > 0 ? .green : .gray)
                    }
                    .buttonStyle(BorderlessButtonStyle())

                    Text("\(count)")
                        .font(.title2.bold())
                        .foregroundColor(count > 0 ? .green : .gray)
                        .frame(minWidth: 30)
                    
                    Button {
                        if count < maximum && viewModel.canAddMoreQuestions() {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                count += 1
                                HapticManager.shared.impact(style: .light)
                            }
                        }
                    } label: {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(
                                (count < maximum && viewModel.canAddMoreQuestions()) ? .green : .gray
                            )
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
            }
            .padding(.bottom, 8)
        }
        .frame(maxWidth: .infinity)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(count > 0 ? Color.green.opacity(0.1) : Color.gray.opacity(0.1))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(count > 0 ? Color.green.opacity(0.2) : Color.clear, lineWidth: 1)
        )
    }
}

// QuestionTypesSelectionSectionë„ ìˆ˜ì •
struct QuestionTypesSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    let columns = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    var body: some View {
        Section {
            VStack(spacing: 8) {
                // ì´ ë¬¸ì œ ìˆ˜ í‘œì‹œ
                HStack {
                    Text("Question Types")
                        .font(.headline)
                    Spacer()
                    Text("Total: \(viewModel.totalQuestionCount)/20")
                        .font(.subheadline)
                        .foregroundColor(viewModel.totalQuestionCount > 0 ? .green : .gray)
                }
                .padding(.horizontal)
                
                LazyVGrid(columns: columns, spacing: 12) {
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Multiple",
                        icon: "list.bullet.circle.fill",
                        count: $viewModel.multipleChoiceCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "Fill in Blanks",
                        icon: "square.and.pencil",
                        count: $viewModel.fillInBlanksCount
                    )
                    
                    QuestionTypeCard(
                        viewModel: viewModel,
                        title: "True/False",
                        icon: "checkmark.circle.fill",
                        count: $viewModel.trueFalseCount
                    )
                }
            }
            .padding(.vertical, 8)
        }
    }
}

struct EmptyQuestionSection: View {
   var body: some View {
       Section {
           Text("Please select at least one question type")
               .foregroundColor(.secondary)
               .font(.footnote)
       }
   }
}

struct EducationLevelButton: View {
    let level: EducationLevel
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(level.displayName)
                .font(.subheadline)
                .fontWeight(isSelected ? .bold : .regular)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(isSelected ? level.color.opacity(0.2) : Color.gray.opacity(0.1))
                )
                .foregroundColor(isSelected ? level.color : .gray)
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(isSelected ? level.color : Color.clear, lineWidth: 2)
                )
        }
    }
}

// Subject Selection Section
struct SubjectSelectionSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Learning Subject") {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(Subject.allCases, id: \.self) { subject in
                        SubjectSelectionButton(
                            subject: subject,
                            isSelected: viewModel.selectedSubject == subject
                        ) {
                            viewModel.selectedSubject = subject
                        }
                    }
                }
                .padding(.vertical, 8)
            }
        }
    }
}

// Education Level Section
struct EducationLevelSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Education Level") {
            HStack(spacing: 12) {
                ForEach(EducationLevel.allCases, id: \.self) { level in
                    EducationLevelButton(
                        level: level,
                        isSelected: viewModel.educationLevel == level
                    ) {
                        viewModel.educationLevel = level
                    }
                }
            }
        }
    }
}

// Difficulty Section
struct DifficultySection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Difficulty Level") {
            Picker("Difficulty", selection: $viewModel.difficulty) {
                ForEach(Difficulty.allCases, id: \.self) { difficulty in
                    Text(difficulty.rawValue.capitalized)
                        .tag(difficulty)
                }
            }
            .pickerStyle(.segmented)
        }
    }
}

// Question Types Section
struct QuestionTypesSection: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Section("Question Types") {
            VStack(spacing: 10) {
                QuestionTypeCounter(
                    title: "Multiple",
                    count: $viewModel.multipleChoiceCount
                )
                
                QuestionTypeCounter(
                    title: "Fill in the Blanks",
                    count: $viewModel.fillInBlanksCount
                )
                
            }
        }
    }
}


// ImagePicker, PhotoPicker, LoadingView ë„ ì¶”ê°€
struct PhotoPicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]
    @Environment(\.presentationMode) var presentationMode
    
    func makeUIViewController(context: Context) -> PHPickerViewController {
        var config = PHPickerConfiguration()
        config.selectionLimit = 10
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, PHPickerViewControllerDelegate {
        let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            parent.presentationMode.wrappedValue.dismiss()
            
            for result in results {
                result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                    if let image = image as? UIImage {
                        DispatchQueue.main.async {
                            self.parent.selectedImages.append(image)
                        }
                    }
                }
            }
        }
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Environment(\.presentationMode) private var presentationMode
    @Binding var image: UIImage?
    let sourceType: UIImagePickerController.SourceType
    var onImageSelected: ((UIImage) -> Void)? // ì¶”ê°€
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.sourceType = sourceType
        picker.delegate = context.coordinator
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: ImagePicker
        
        init(_ parent: ImagePicker) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.image = image
                parent.onImageSelected?(image)  // ì½œë°± í˜¸ì¶œ
                print("ğŸ“¸ Image captured successfully")
            }
            parent.presentationMode.wrappedValue.dismiss()
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            print("ğŸ“¸ Camera capture cancelled")
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

struct LoadingView: View {
    var body: some View {
        ZStack {
            Color.black.opacity(0.4)
                .edgesIgnoringSafeArea(.all)
            
            VStack(spacing: 16) {
                ProgressView()
                    .scaleEffect(1.5)
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                Text("Processing...")
                    .font(.headline)
                    .foregroundColor(.white)
            }
            .padding()
            .background(Color.black.opacity(0.6))
            .cornerRadius(10)
        }
    }
}







## ./AISnapStudy/Views/Question/FillInBlanksView.swift

import SwiftUI

struct FillInBlanksView: View {
    let question: Question
    @Binding var answer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            // Answer Input - ìˆ˜ì •ëœ ë¶€ë¶„
            VStack(alignment: .leading, spacing: 8) {
                Text("Your Answer")
                    .font(.headline)
                    .foregroundColor(.secondary)
                
                TextEditor(text: Binding(
                    get: { answer ?? "" },
                    set: { answer = $0 }
                ))
                .font(.system(size: 18))
                .frame(minHeight: 30)  // ìµœì†Œ ë†’ì´ ì„¤ì •
                .padding(8)
                .background(RoundedRectangle(cornerRadius: 8)
                    .fill(Color(.systemBackground)))
                .overlay(
                    RoundedRectangle(cornerRadius: 8)
                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                )
                .disabled(showExplanation)
            }

            
            // Answer Result (only show when submitted)
            if showExplanation {
                if let isCorrect = isCorrect {
                    HStack {
                        Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                            .foregroundColor(isCorrect ? .green : .red)
                        
                        Text(isCorrect ? "Correct!" : "Incorrect")
                            .foregroundColor(isCorrect ? .green : .red)
                            .fontWeight(.semibold)
                    }
                    .padding(.vertical, 4)
                    
                    // Show correct answer if wrong
                    if !isCorrect {
                        Text("Answer: \(question.correctAnswer)")
                            .font(.subheadline)
                            .foregroundColor(.blue)
                            .padding(.vertical, 4)
                    }
                }
            }
            
            // Explanation Section (only show when icon is clicked)
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        // ìƒíƒœê°€ ë¦¬ì…‹ë  ë•Œ ì„¤ëª… ìˆ¨ê¸°ê¸°
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}


## ./AISnapStudy/Views/Question/TrueFalseView.swift

import SwiftUI

struct TrueFalseView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    @State private var isExplanationVisible = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Question Text
            Text(question.question)
                .font(.system(size: 22, weight: .semibold))
                .lineSpacing(4)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            VStack(alignment: .leading, spacing: 12) {
                TrueFalseButton(
                    title: "True",
                    isSelected: selectedAnswer == "true",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "true"
                }
                
                TrueFalseButton(
                    title: "False",
                    isSelected: selectedAnswer == "false",
                    disabled: showExplanation
                ) {
                    selectedAnswer = "false"
                }
            }
            
            // Answer Result
            if showExplanation {
                HStack {
                    if let isCorrect = isCorrect {
                        HStack {
                            Image(systemName: isCorrect ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect ? .green : .red)
                            
                            Text(isCorrect ? "Correct!" : "Incorrect")
                                .foregroundColor(isCorrect ? .green : .red)
                                .fontWeight(.semibold)
                        }
                        .padding(.vertical, 4)
                        
                        Spacer()
                        
                    }
                }
                
                // Show correct answer if wrong
                if let isCorrect = isCorrect, !isCorrect {
                    Text("Answer: \(question.correctAnswer)")
                        .font(.subheadline)
                        .foregroundColor(.blue)
                        .padding(.vertical, 4)
                }
            }
            
            // Explanation Section
            if showExplanation && isExplanationVisible {
                VStack(alignment: .leading, spacing: 8) {
                    Text("Explanation")
                        .font(.headline)
                    Text(question.explanation)
                        .font(.body)
                        .foregroundColor(.secondary)
                }
                .padding()
                .frame(maxWidth: .infinity, alignment: .leading)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(10)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .padding()
        .animation(.spring(), value: showExplanation)
        .animation(.spring(), value: isExplanationVisible)
        .onChange(of: question.id) { _ in
            isExplanationVisible = false
        }
    }
}

// TrueFalseButton êµ¬ì¡°ì²´ëŠ” ë³€ê²½ ì—†ìŒ
struct TrueFalseButton: View {
    let title: String
    let isSelected: Bool
    let disabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Text(title)
                    .font(.body)
                Spacer()
            }
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 10)
                    .fill(isSelected ? Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 10)
                    .stroke(isSelected ? Color.blue : Color.clear, lineWidth: 2)
            )
        }
        .disabled(disabled)
    }
}


## ./AISnapStudy/Views/Question/MultipleChoiceView.swift


import SwiftUI

struct MultipleChoiceView: View {
    let question: Question
    @Binding var selectedAnswer: String?
    let showExplanation: Bool
    let isCorrect: Bool?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(question.question)
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.bottom, 8)
            
            ForEach(question.options, id: \.self) { option in
                Button(action: { selectedAnswer = option }) {
                    HStack {
                        Text(option)
                            .font(.body)
                            .multilineTextAlignment(.leading)
                            .foregroundColor(getTextColor(for: option))
                        Spacer()
                        if selectedAnswer == option && showExplanation {
                            Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .foregroundColor(isCorrect == true ? .green : .red)
                                .transition(.scale.combined(with: .opacity))
                        }
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: 10)
                            .fill(getBackgroundColor(for: option))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 10)
                            .stroke(getBorderColor(for: option), lineWidth: 2)
                    )
                }
                .disabled(showExplanation)
            }
        }
        .padding()
        .animation(.easeInOut(duration: 0.3), value: selectedAnswer)
        .animation(.easeInOut(duration: 0.3), value: showExplanation)
        .animation(.easeInOut(duration: 0.3), value: isCorrect)
    }
    
    private func getBackgroundColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return Color.blue.opacity(0.1)  // ì„ íƒí–ˆì„ ë•Œ íŒŒë€ìƒ‰
            } else {
                return (isCorrect == true ? Color.green : Color.red).opacity(0.1)  // ì œì¶œ í›„
            }
        }
        return Color.gray.opacity(0.05)
    }
    
    private func getBorderColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue  // ì„ íƒí–ˆì„ ë•Œ íŒŒë€ìƒ‰
            } else {
                return isCorrect == true ? .green : .red  // ì œì¶œ í›„
            }
        }
        return .clear
    }
    
    private func getTextColor(for option: String) -> Color {
        if selectedAnswer == option {
            if !showExplanation {
                return .blue  // ì„ íƒí–ˆì„ ë•Œ íŒŒë€ìƒ‰
            } else {
                return isCorrect == true ? .green : .red  // ì œì¶œ í›„
            }
        }
        return .primary
    }
}


## ./AISnapStudy/Views/Components/DifficultySelector.swift


import SwiftUI

struct DifficultySelector: View {
    @Binding var selectedDifficulty: Difficulty
    
    var body: some View {
        HStack(spacing: 12) {
            ForEach(Difficulty.allCases, id: \.self) { difficulty in
                DifficultyButton(
                    difficulty: difficulty,
                    isSelected: selectedDifficulty == difficulty,
                    action: { selectedDifficulty = difficulty }
                )
            }
        }
        .padding(.horizontal)
    }
}

// ë³„ë„ì˜ ë²„íŠ¼ ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬
private struct DifficultyButton: View {
    let difficulty: Difficulty
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack {
                Image(systemName: difficulty.iconName)
                    .font(.system(size: 24))
                Text(difficulty.displayName)
                    .font(.caption)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .background(backgroundColor)
            .foregroundColor(foregroundColor)
        }
    }
    
    private var backgroundColor: some View {
        RoundedRectangle(cornerRadius: 10)
            .fill(isSelected ? Color.accentColor : Color.secondaryBackground)
    }
    
    private var foregroundColor: Color {
        isSelected ? .white : .primary
    }
}



## ./AISnapStudy/Views/Components/ProblemSetCard.swift


import SwiftUI

struct ProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // ìƒë‹¨ í—¤ë”
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                    Text(problemSet.title.isEmpty ? "No Title" : problemSet.title)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
                if problemSet.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
            }
            
            // íƒœê·¸ ëª©ë¡ (ì‘ê³  ê°„ê²°í•˜ê²Œ)
            if !problemSet.tags.isEmpty {
                HStack(spacing: 4) {
                    ForEach(problemSet.tags.prefix(3), id: \.self) { tag in // ìµœëŒ€ 3ê°œì˜ íƒœê·¸ë§Œ í‘œì‹œ
                        Text(tag)
                            .font(.caption2)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 3)
                            .background(Color.blue.opacity(0.1))
                            .foregroundColor(.blue)
                            .cornerRadius(4)
                    }
                    if problemSet.tags.count > 3 {
                        Text("+\(problemSet.tags.count - 3) more")
                            .font(.caption2)
                            .foregroundColor(.blue)
                    }
                }
            } else {
                Text("No Tags")
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            
            Divider()
            
            // ì •ë³´ ê·¸ë¦¬ë“œ
            HStack(spacing: 12) {
                InfoRow(title: "Subject", value: problemSet.subject.displayName)
                InfoRow(title: "Level", value: problemSet.educationLevel.rawValue)
                InfoRow(title: "Questions", value: "\(problemSet.questions.count)")
                InfoRow(title: "Difficulty", value: problemSet.difficulty.rawValue)
            }
            .font(.footnote)
            
            // ì„¤ëª… (ë” ì§§ê²Œ)
            if let description = problemSet.problemSetDescription, !description.isEmpty {
                Text(description)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
        }
        .padding(12)
        .background(RoundedRectangle(cornerRadius: 10).fill(Color(UIColor.systemBackground)).shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2))
        .padding(.horizontal)
    }
}

struct InfoRow: View {
    let title: String
    let value: String
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
            Text(value.isEmpty ? "N/A" : value)
                .font(.caption)
                .foregroundColor(.primary)
        }
    }
}



## ./AISnapStudy/Views/Components/StatCard.swift

import SwiftUI

struct StatCard: View {
    let title: String
    let value: String
    let icon: String
    let color: Color
    
    var body: some View {
        VStack {
            Image(systemName: icon)
                .font(.system(size: 30))
                .foregroundColor(color)
            
            Text(title)
                .font(.headline)
                .foregroundColor(.gray)
            
            Text(value)
                .font(.title3)
                .bold()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


## ./AISnapStudy/Views/Components/SearchBar.swift


import SwiftUI

struct SearchBar: View {
    @Binding var text: String
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search history...", text: $text)
                .textFieldStyle(PlainTextFieldStyle())
            
            if !text.isEmpty {
                Button(action: { text = "" }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
        }
        .padding(8)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(10)
    }
}


## ./AISnapStudy/Views/Components/HistoryCard.swift



import SwiftUI

struct HistoryCard: View {
    let session: StudySession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(session.problemSet.title)
                    .font(.headline)
                Spacer()
                
                Text(session.problemSet.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(session.problemSet.subject.color.opacity(0.2))
                    .foregroundColor(session.problemSet.subject.color)
                    .cornerRadius(4)
            }
            
            HStack {
                VStack(alignment: .leading) {
                    Text("Score")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text("\(session.score ?? 0)%")
                        .font(.title3)
                        .fontWeight(.semibold)
                }
                
                Spacer()
                
                VStack(alignment: .trailing) {
                    Text("Time")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    Text(session.duration?.formatted ?? "N/A")
                        .font(.subheadline)
                }
            }
            
            HStack {
                Text("Questions: \(session.answers.count)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

// Helper extension for time formatting
private extension TimeInterval {
    var formatted: String {
        let minutes = Int(self) / 60
        let seconds = Int(self) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}


## ./AISnapStudy/Views/Components/SavedProblemCard.swift


import SwiftUI

struct SavedProblemCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text(question.subject.rawValue.capitalized)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
                
                Text(question.difficulty.rawValue.capitalized)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
            
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Button(action: {}) {
                    Image(systemName: "arrow.right.circle.fill")
                        .foregroundColor(.accentColor)
                }
            }
        }
        .padding()
        .background(Color.white)
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}


## ./AISnapStudy/Views/Components/FilterButton.swift



import SwiftUI

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.subheadline)
                .fontWeight(isSelected ? .semibold : .regular)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    isSelected ?
                        Color.accentColor :
                        Color.gray.opacity(0.1)
                )
                .foregroundColor(isSelected ? .white : .primary)
                .cornerRadius(20)
        }
    }
}


## ./AISnapStudy/Views/Components/ImageSelectionSection.swift

// File: ./AISnapStudy/Views/Components/ImageSelectionSection.swift

import SwiftUI
import PhotosUI
import UIKit


struct ImageSelectionSection: View {
   @ObservedObject var viewModel: QuestionSettingsViewModel
   @FocusState private var isTextFieldFocused: Bool
   @State private var keyboardHeight: CGFloat = 0
   
   var body: some View {
       Section {
           DisclosureGroup(
               isExpanded: .constant(true),
               content: {
                   VStack(spacing: 16) {
                       // Input Type Selection Buttons
                       HStack(spacing: 12) {
                           // Camera Button
                           ImageOptionCard(
                               icon: "camera.fill",
                               isUsed: viewModel.hasSelectedCamera,
                               isDisabled: !viewModel.canUseImageInput,
                               action: {
                                   if viewModel.canUseImageInput {
                                       viewModel.isTextInputActive = false
                                       isTextFieldFocused = false
                                       viewModel.onImageOptionSelected()
                                       Task {
                                           await viewModel.takePhoto()
                                       }
                                   }
                               }
                           )
                           .frame(maxWidth: .infinity)
                           
                           // Gallery Button
                           ImageOptionCard(
                               icon: "photo.fill",
                               isUsed: viewModel.hasSelectedGallery,
                               isDisabled: !viewModel.canUseImageInput,
                               action: {
                                   if viewModel.canUseImageInput {
                                       viewModel.isTextInputActive = false
                                       isTextFieldFocused = false
                                       viewModel.onImageOptionSelected()
                                       Task {
                                           await viewModel.selectFromGallery()
                                       }
                                   }
                               }
                           )
                           .frame(maxWidth: .infinity)
                           
                           // Text Input Button
                           ImageOptionCard(
                               icon: "text.bubble.fill",
                               isUsed: viewModel.isTextInputActive,
                               isDisabled: !viewModel.canUseTextInput,
                               action: {
                                   if viewModel.canUseTextInput {
                                       viewModel.onImageOptionSelected()
                                       viewModel.toggleTextInput()
                                       if viewModel.isTextInputActive {
                                           DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                               isTextFieldFocused = true
                                           }
                                       } else {
                                           isTextFieldFocused = false
                                       }
                                   }
                               }
                           )
                           .frame(maxWidth: .infinity)
                       }
                       .padding(.horizontal)
                       
                       // Text Input Field and Generate Button
                       if viewModel.isTextInputActive {
                           VStack(spacing: 12) {
                               TextField("Enter your question here...", text: $viewModel.questionText)
                                   .textFieldStyle(RoundedBorderTextFieldStyle())
                                   .focused($isTextFieldFocused)
                                   .onChange(of: viewModel.questionText) { newValue in
                                       let trimmed = newValue.trimmingCharacters(in: .whitespacesAndNewlines)
                                       viewModel.isUsingTextInput = !trimmed.isEmpty
                                   }
                               
                               // Generate Button for Text Input
                               if !viewModel.questionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                                   Button {
                                       print("ğŸ”µ Generate Questions Button Tapped (Text Input)")
                                       isTextFieldFocused = false
                                       Task {
                                           print("ğŸ“ Starting question generation from text")
                                           await viewModel.sendAllImages()
                                       }
                                   } label: {
                                       HStack {
                                           Spacer()
                                           Image(systemName: "sparkles")
                                           Text("Generate Questions")
                                               .fontWeight(.semibold)
                                           Spacer()
                                       }
                                       .font(.headline)
                                       .foregroundColor(.white)
                                       .padding()
                                       .background(
                                           RoundedRectangle(cornerRadius: 12)
                                               .fill(viewModel.isLoading ? Color.gray : Color.green)
                                       )
                                       .animation(.easeInOut, value: viewModel.isLoading)
                                   }
                                   .buttonStyle(BorderlessButtonStyle())
                                   .disabled(viewModel.isLoading)
                               }
                           }
                           .padding(.horizontal)
                           .padding(.bottom, keyboardHeight > 0 ? keyboardHeight + 20 : 0)
                           .animation(.easeOut, value: keyboardHeight)
                       }
                       
                       // Selected Images Display
                       if !viewModel.selectedImages.isEmpty {
                           VStack(alignment: .leading, spacing: 12) {
                               ScrollView(.horizontal, showsIndicators: false) {
                                   HStack(spacing: 12) {
                                       ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                                           SelectedImageCell(
                                               image: viewModel.selectedImages[index],
                                               onDelete: {
                                                   viewModel.removeImage(at: index)
                                               }
                                           )
                                       }
                                   }
                                   .padding(.horizontal)
                               }
                               
                               // Generate Button for Images
                               Button {
                                   print("ğŸ”µ Generate Questions Button Tapped (Images)")
                                   Task { @MainActor in
                                       print("ğŸ“ Starting question generation from images")
                                       print("â€¢ Number of images: \(viewModel.selectedImages.count)")
                                       
                                       viewModel.isLoading = true
                                       
                                       do {
                                           await viewModel.sendAllImages()
                                       } catch {
                                           print("âŒ Error generating questions: \(error)")
                                       }
                                       
                                       viewModel.isLoading = false
                                   }
                               } label: {
                                   HStack {
                                       Spacer()
                                       Image(systemName: "sparkles")
                                       Text("Generate Questions")
                                           .fontWeight(.semibold)
                                       Spacer()
                                   }
                                   .font(.headline)
                                   .foregroundColor(.white)
                                   .padding()
                                   .background(
                                       RoundedRectangle(cornerRadius: 12)
                                           .fill(viewModel.isLoading ? Color.gray : Color.green)
                                   )
                                   .animation(.easeInOut, value: viewModel.isLoading)
                               }
                               .buttonStyle(BorderlessButtonStyle())
                               .disabled(viewModel.isLoading)
                               .padding(.horizontal)
                           }
                       }
                   }
                   .padding(.vertical, 8)
               },
               label: {
                   HStack {
                       Text("Question About")
                           .font(.headline)
                       Spacer()
                       if !viewModel.selectedImages.isEmpty {
                           Text("\(viewModel.selectedImages.count) selected")
                               .foregroundColor(viewModel.selectedImages.isEmpty ? .gray : .green)
                       } else if !viewModel.questionText.isEmpty {
                           Text("Text input")
                               .foregroundColor(.green)
                       }
                   }
               }
           )
       }
       .onTapGesture {
           isTextFieldFocused = false
       }
       .onAppear {
           NotificationCenter.default.addObserver(
               forName: UIResponder.keyboardWillShowNotification,
               object: nil,
               queue: .main
           ) { notification in
               if let keyboardFrame = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect {
                   self.keyboardHeight = keyboardFrame.height
               }
           }
           
           NotificationCenter.default.addObserver(
               forName: UIResponder.keyboardWillHideNotification,
               object: nil,
               queue: .main
           ) { _ in
               self.keyboardHeight = 0
           }
       }
   }
}

// Update ImageOptionCard to support disabled state
struct ImageOptionCard: View {
    let icon: String
    let isUsed: Bool
    let isDisabled: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 12) {
                Image(systemName: icon)
                    .font(.system(size: 30))
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 20)
            .foregroundColor(foregroundColor)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(backgroundColor)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(strokeColor, lineWidth: 1)
            )
        }
        .disabled(isDisabled)
        .buttonStyle(PlainButtonStyle())
    }
    
    private var foregroundColor: Color {
        if isDisabled {
            return .gray.opacity(0.5)
        }
        return isUsed ? .green : .gray
    }
    
    private var backgroundColor: Color {
        if isDisabled {
            return Color.gray.opacity(0.1)
        }
        return isUsed ? Color.green.opacity(0.1) : Color.gray.opacity(0.1)
    }
    
    private var strokeColor: Color {
        if isDisabled {
            return .clear
        }
        return isUsed ? Color.green.opacity(0.2) : .clear
    }
}

struct SelectedImageCell: View {
   let image: UIImage
   let onDelete: () -> Void
   
   var body: some View {
       ZStack(alignment: .topTrailing) {
           Image(uiImage: image)
               .resizable()
               .scaledToFill()
               .frame(width: 100, height: 100)
               .clipShape(RoundedRectangle(cornerRadius: 12))
               .overlay(
                   RoundedRectangle(cornerRadius: 12)
                       .stroke(Color.gray.opacity(0.2), lineWidth: 1)
               )
           
           Button(action: onDelete) {
               Image(systemName: "xmark.circle.fill")
                   .font(.system(size: 22))
                   .foregroundColor(.white)
                   .background(
                       Circle()
                           .fill(Color.black.opacity(0.5))
                           .frame(width: 24, height: 24)
                   )
           }
           .offset(x: 6, y: -6)
       }
   }
}

struct ImageSelectionButtons: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack {
            ImageSelectionButton(
                title: "Select Multiple Photos",
                icon: "photo.on.rectangle"
            ) {
                Task {
                    await viewModel.selectMultiplePhotos()
                }
            }
            
            ImageSelectionButton(
                title: "Take Photo",
                icon: "camera"
            ) {
                Task {
                    await viewModel.takePhoto()
                }
            }
            
            ImageSelectionButton(
                title: "Choose from Gallery",
                icon: "photo"
            ) {
                Task {
                    await viewModel.selectFromGallery()
                }
            }
        }
    }
}

struct ImageSelectionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Label(title, systemImage: icon)
                Spacer()
                Image(systemName: "chevron.right")
                    .foregroundColor(.gray)
            }
        }
    }
}

struct SelectedImagesView: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Selected Images")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(viewModel.selectedImages.indices, id: \.self) { index in
                        ImageCell(
                            image: viewModel.selectedImages[index],
                            onDelete: {
                                viewModel.removeImage(at: index)
                            }
                        )
                    }
                }
                .padding(.vertical, 8)
            }
            
            GenerateQuestionsButton(viewModel: viewModel)
        }
        .padding(.top, 8)
    }
}

struct ImageCell: View {
    let image: UIImage
    let onDelete: () -> Void
    
    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(width: 100, height: 100)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                Button(action: onDelete) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.white)
                        .background(Circle().fill(Color.black.opacity(0.5)))
                }
                .padding(4),
                alignment: .topTrailing
            )
    }
}

struct GenerateQuestionsButton: View {
    @ObservedObject var viewModel: QuestionSettingsViewModel
    
    var body: some View {
        Button {
            Task {
                await viewModel.sendAllImages()
            }
        } label: {
            HStack {
                Spacer()
                Label("Generate Questions", systemImage: "paperplane.fill")
                    .font(.headline)
                Spacer()
            }
            .padding()
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(10)
        }
        .buttonStyle(BorderlessButtonStyle())
        .padding(.vertical, 8)
    }
}


## ./AISnapStudy/Views/Components/MainActionButton.swift

// File: ./AISnapStudy/Views/Components/MainActionButton.swift

import SwiftUI

struct MainActionButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                Text(title)
                    .font(.headline)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 40)
            .background(Color.accentColor)
            .foregroundColor(.white)
            .cornerRadius(12)
        }
    }
}


## ./AISnapStudy/Views/Components/SavedQuestionCard.swift

import SwiftUI

struct SavedQuestionCard: View {
    let question: Question
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Subject and Difficulty Tags
            HStack {
                Text(question.subject.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.subject.color.opacity(0.2))
                    .foregroundColor(question.subject.color)
                    .cornerRadius(8)
                
                Spacer()
                
                Text(question.difficulty.displayName)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(question.difficulty.color.opacity(0.2))
                    .foregroundColor(question.difficulty.color)
                    .cornerRadius(8)
            }
            
            // Question Type
            Text(question.type.rawValue.replacingOccurrences(of: "_", with: " ").capitalized)
                .font(.caption)
                .foregroundColor(.secondary)
            
            // Question Text
            Text(question.question)
                .font(.subheadline)
                .lineLimit(2)
                .padding(.vertical, 4)
            
            // Footer
            HStack {
                Text("Saved \(question.createdAt.timeAgo)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Image(systemName: "arrow.right.circle.fill")
                    .foregroundColor(.blue)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 2)
        )
    }
}

#Preview {
    SavedQuestionCard(question: Question(
        id: UUID().uuidString,
        type: .multipleChoice,
        subject: .math,
        difficulty: .medium,
        question: "Sample Question",
        options: ["A", "B", "C", "D"],
        correctAnswer: "A",
        explanation: "Sample explanation",
        hint: "Sample hint",
        isSaved: true,
        createdAt: Date()
    ))
    .padding()
}


## ./AISnapStudy/Views/Components/ProgressRow.swift


import SwiftUI

struct ProgressRow: View {
    let subject: String
    let progress: Double
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(subject)
                    .font(.subheadline)
                Spacer()
                Text(String(format: "%.1f%%", progress))
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 8)
                    
                    // Progress
                    RoundedRectangle(cornerRadius: 4)
                        .fill(getColor(for: subject))
                        .frame(width: geometry.size.width * min(max(progress / 100, 0), 1), height: 8)
                }
            }
            .frame(height: 8)
        }
    }
    
    private func getColor(for subject: String) -> Color {
        switch subject.lowercased() {
        case "language arts":
            return .blue
        case "math":
            return .green
        default:
            return .accentColor
        }
    }
}


## ./AISnapStudy/Views/Components/QuestionTypeCounter.swift


import SwiftUI

struct QuestionTypeCounter: View {
    let title: String
    @Binding var count: Int
    let maximum: Int = 10
    
    // ê° ë²„íŠ¼ì— ëŒ€í•œ ë³„ë„ì˜ ì•¡ì…˜ ì •ì˜
    private func incrementCount() {
        if count < maximum {
            count += 1
            print("\(title): Increased to \(count)")
        }
    }
    
    private func decrementCount() {
        if count > 0 {
            count -= 1
            print("\(title): Decreased to \(count)")
        }
    }
    
    var body: some View {
        HStack {
            Text(title)
                .font(.subheadline)
            
            Spacer()
            
            HStack(spacing: 16) {
                // Decrease Button
                Button {
                    decrementCount()
                } label: {
                    Image(systemName: "minus.circle.fill")
                        .foregroundColor(.red)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // ì¤‘ìš”: ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë¶„ë¦¬
                .disabled(count <= 0)
                
                Text("\(count)")
                    .font(.headline)
                    .frame(width: 30)
                
                // Increase Button
                Button {
                    incrementCount()
                } label: {
                    Image(systemName: "plus.circle.fill")
                        .foregroundColor(.green)
                        .imageScale(.large)
                }
                .buttonStyle(BorderlessButtonStyle()) // ì¤‘ìš”: ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë¶„ë¦¬
                .disabled(count >= maximum)
            }
        }
        .padding()
        .background(Color(UIColor.secondarySystemBackground))
        .cornerRadius(10)
    }
}


## ./AISnapStudy/Views/Components/HistoryProblemSetCard.swift

import SwiftUI

struct HistoryProblemSetCard: View {
    let problemSet: ProblemSet
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text(problemSet.name.isEmpty ? "No Name" : problemSet.name)
                    .font(.headline)
                    .foregroundColor(.primary)
                Text(problemSet.title.isEmpty ? "No Title" : problemSet.title)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                Text("Created on: \(problemSet.createdAt.formatted(date: .abbreviated, time: .omitted))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            Spacer()
            if problemSet.isFavorite {
                Image(systemName: "star.fill")
                    .foregroundColor(.yellow)
            }
        }
        .padding(10)
        .background(RoundedRectangle(cornerRadius: 8)
                        .fill(Color(UIColor.systemBackground))
                        .shadow(color: Color.black.opacity(0.1), radius: 2, x: 0, y: 1))
        .padding(.vertical, 4)
    }
}


## ./AISnapStudy/Views/Profile/EditProfileView.swift



import SwiftUI

struct EditProfileView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = EditProfileViewModel()
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    TextField("Name", text: $viewModel.name)
                        .textContentType(.name)
                    
                    TextField("Email", text: $viewModel.email)
                        .textContentType(.emailAddress)
                        .keyboardType(.emailAddress)
                }
                
                Section {
                    Button(action: viewModel.changePassword) {
                        Text("Change Password")
                    }
                }
            }
            .navigationTitle("Edit Profile")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        Task {
                            await viewModel.saveChanges()
                            dismiss()
                        }
                    }
                    .disabled(!viewModel.hasChanges)
                }
            }
        }
    }
}

class EditProfileViewModel: ObservableObject {
    @Published var name: String = ""
    @Published var email: String = ""
    private var originalName: String = ""
    private var originalEmail: String = ""
    
    var hasChanges: Bool {
        name != originalName || email != originalEmail
    }
    
    init() {
        // ì‹¤ì œ ì•±ì—ì„œëŠ” í˜„ì¬ ì‚¬ìš©ì ë°ì´í„°ë¥¼ ë¡œë“œ
        let currentUser = User(
            id: "1",
            name: "Test User",
            email: "test@example.com",
            preferences: User.UserPreferences(
                isDarkMode: false,
                notificationsEnabled: true,
                dailyGoal: 5,
                preferredDifficulty: .medium
            ),
            createdAt: Date(),
            lastActive: Date()
        )
        
        self.name = currentUser.name
        self.email = currentUser.email
        self.originalName = currentUser.name
        self.originalEmail = currentUser.email
    }
    
    func changePassword() {
        // ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ë¡œì§ êµ¬í˜„
    }
    
    func saveChanges() async {
        // í”„ë¡œí•„ ë³€ê²½ ì €ì¥ ë¡œì§ êµ¬í˜„
    }
}


## ./AISnapStudy/Views/Profile/StudyPreferencesView.swift


import SwiftUI

struct StudyPreferencesView: View {
    @StateObject private var viewModel = StudyPreferencesViewModel()
    
    var body: some View {
        Form {
            Section(header: Text("Daily Goals")) {
                Stepper("Questions per day: \(viewModel.dailyGoal)",
                        value: $viewModel.dailyGoal, in: 1...20)
            }
            
            Section(header: Text("Preferred Difficulty")) {
                Picker("Default Difficulty", selection: $viewModel.preferredDifficulty) {
                    ForEach(Difficulty.allCases, id: \.self) { difficulty in
                        Text(difficulty.displayName)
                            .tag(difficulty)
                    }
                }
                .pickerStyle(.segmented)
            }
            
            Section(header: Text("Study Reminders")) {
                Toggle("Daily Reminder", isOn: $viewModel.dailyReminder)
                if viewModel.dailyReminder {
                    DatePicker("Reminder Time",
                              selection: $viewModel.reminderTime,
                              displayedComponents: .hourAndMinute)
                }
            }
        }
        .navigationTitle("Study Preferences")
    }
}

class StudyPreferencesViewModel: ObservableObject {
    @Published var dailyGoal: Int = UserDefaults.standard.integer(forKey: "dailyGoal") {
        didSet {
            UserDefaults.standard.set(dailyGoal, forKey: "dailyGoal")
        }
    }
    
    @Published var preferredDifficulty: Difficulty = Difficulty(rawValue:
        UserDefaults.standard.string(forKey: "preferredDifficulty") ?? "medium"
    ) ?? .medium {
        didSet {
            UserDefaults.standard.set(preferredDifficulty.rawValue, forKey: "preferredDifficulty")
        }
    }
    
    @Published var dailyReminder: Bool = UserDefaults.standard.bool(forKey: "dailyReminder") {
        didSet {
            UserDefaults.standard.set(dailyReminder, forKey: "dailyReminder")
        }
    }
    
    @Published var reminderTime: Date = Date(timeIntervalSince1970:
        UserDefaults.standard.double(forKey: "reminderTime")
    ) {
        didSet {
            UserDefaults.standard.set(reminderTime.timeIntervalSince1970, forKey: "reminderTime")
        }
    }
}



## ./AISnapStudy/Views/Main/MainTabView.swift

import SwiftUI
import Combine
import CoreData

struct MainTabView: View {
    @Environment(\.managedObjectContext) private var context
    @StateObject private var homeViewModel: HomeViewModel
    @State private var selectedTab = 0
    @StateObject private var studyViewModel: StudyViewModel
    @StateObject private var statViewModel: StatViewModel
    
    init() {
        let homeVM = HomeViewModel.shared
        self._homeViewModel = StateObject(wrappedValue: homeVM)
        self._studyViewModel = StateObject(wrappedValue: StudyViewModel(
            homeViewModel: homeVM,
            context: CoreDataService.shared.viewContext
        ))
        self._statViewModel = StateObject(wrappedValue: StatViewModel(
            context: CoreDataService.shared.viewContext
        ))
    }
    
    var body: some View {
        TabView(selection: $selectedTab) {
            HomeView(viewModel: homeViewModel, selectedTab: $selectedTab)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(0)
            
            if let problemSet = homeViewModel.selectedProblemSet {
                StudyView(
                    questions: problemSet.questions,
                    studyViewModel: studyViewModel,
                    selectedTab: $selectedTab
                )
                .tabItem {
                    Label("Study", systemImage: "book.fill")
                }
                .tag(1)
            } else {
                Text("No Problem Set Selected")
                    .tabItem {
                        Label("Study", systemImage: "book.fill")
                    }
                    .tag(1)
            }
            
            HistoryView()
                .tabItem {
                    Label("History", systemImage: "clock.fill")
                }
                .tag(2)
            
            StatView(
                correctAnswers: homeViewModel.correctAnswers,
                totalQuestions: homeViewModel.totalQuestions,
                viewModel: statViewModel,
                selectedTab: $selectedTab
            )
            .tabItem {
                Label("Stats", systemImage: "chart.bar.fill")
            }
            .tag(3)
        }
        .onAppear {
            statViewModel.setHomeViewModel(homeViewModel)
        }
        .onChange(of: homeViewModel.selectedProblemSet) { _ in
            if selectedTab == 1 {
                if let problemSet = homeViewModel.selectedProblemSet {
                    studyViewModel.loadQuestions(problemSet.questions)
                }
            }
        }
        .environmentObject(homeViewModel)
    }
}


## ./AISnapStudy/Views/Main/StatView.swift

import SwiftUI
import Charts
import CoreData

struct StatView: View {
    @ObservedObject var viewModel: StatViewModel // Change to ObservedObject
    @Binding var selectedTab: Int
    let correctAnswers: Int
    let totalQuestions: Int
    
 
    @EnvironmentObject private var homeViewModel: HomeViewModel

    
    init(correctAnswers: Int,
         totalQuestions: Int,
         viewModel: StatViewModel, // Pass viewModel directly
         selectedTab: Binding<Int>) {
        self.correctAnswers = correctAnswers
        self.totalQuestions = totalQuestions
        self.viewModel = viewModel // Direct assignment without StateObject
        self._selectedTab = selectedTab
    }
    
    var body: some View {
            ScrollView {
                VStack(spacing: 20) {
                    Text("í•™ìŠµ í†µê³„")
                        .font(.title)
                        .padding(.top)
                    
                    // í˜„ì¬ ìŠ¤íŠ¸ë¦­
                    HStack {
                        VStack(alignment: .leading) {
                            Text("í˜„ì¬ ìŠ¤íŠ¸ë¦­")
                                .font(.headline)
                            Text("\(viewModel.streak)ì¼")
                                .font(.title)
                                .foregroundColor(.blue)
                        }
                        Spacer()
                        Image(systemName: "flame.fill")
                            .font(.system(size: 40))
                            .foregroundColor(.orange)
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(10)
                    
                    // í†µê³„ ê·¸ë¦¬ë“œ
                    LazyVGrid(columns: [
                        GridItem(.flexible()),
                        GridItem(.flexible())
                    ], spacing: 20) {
                        StatCard(title: "ì´ ì ìˆ˜", value: "\(viewModel.totalPoints)ì ", icon: "star.fill", color: .yellow)
                        StatCard(title: "ì™„ë£Œí•œ ë¬¸ì œ", value: "\(viewModel.completedQuestions)ê°œ", icon: "checkmark.circle.fill", color: .green)
                        StatCard(title: "ì •ë‹µë¥ ", value: String(format: "%.1f%%", viewModel.accuracyRate), icon: "percent", color: .blue)
                        StatCard(title: "ì •ë‹µ ìˆ˜", value: "\(viewModel.correctAnswers)ê°œ", icon: "target", color: .red)
                    }
                    .padding()
                    
                    // ë‹¤ì‹œ í’€ê¸° ë²„íŠ¼
                    Button(action: {
                        // ë¨¼ì € ìƒíƒœ ë¦¬ì…‹
                        viewModel.resetProgress()
                        
                        // Study Viewë¡œ ì „í™˜í•˜ê¸° ì§ì „ ìƒíƒœ í™•ì¸ì„ ìœ„í•´ viewModelì—ì„œ ë¡œê·¸ ì¶œë ¥
                        viewModel.logCurrentQuestionState()

                        // ë°”ë¡œ Study íƒ­ìœ¼ë¡œ ì´ë™
                        withAnimation {
                            selectedTab = 1
                        }
                    }) {
                        Text("ë‹¤ì‹œ í’€ê¸°")
                            .font(.headline)
                            .foregroundColor(.white)
                            .padding()
                            .frame(maxWidth: .infinity)
                            .background(Color.blue)
                            .cornerRadius(10)
                    }
                    .padding()
                }
            }
        }
    }


## ./AISnapStudy/Views/Main/ProfileView.swift


import SwiftUI

struct ProfileView: View {
    @State private var showingEditProfile = false
    @StateObject private var viewModel = ProfileViewModel()
    
    var body: some View {
        NavigationView {
            List {
                // Profile Section
                Section {
                    HStack {
                        Image(systemName: "person.circle.fill")
                            .resizable()
                            .frame(width: 60, height: 60)
                            .foregroundColor(.accentColor)
                        
                        VStack(alignment: .leading) {
                            Text(viewModel.user.name)
                                .font(.headline)
                            Text(viewModel.user.email)
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding(.vertical, 8)
                }
                
                // Settings Section
                Section("Settings") {
                    Toggle("Dark Mode", isOn: $viewModel.isDarkMode)
                    Toggle("Notifications", isOn: $viewModel.notificationsEnabled)
                    
                    NavigationLink("Study Preferences") {
                        StudyPreferencesView()
                    }
                }
                
                // App Info Section
                Section("App Info") {
                    HStack {
                        Text("Version")
                        Spacer()
                        Text(Bundle.main.appVersion)
                            .foregroundColor(.secondary)
                    }
                    
                    Button("Terms of Service") {
                        viewModel.showTerms()
                    }
                    
                    Button("Privacy Policy") {
                        viewModel.showPrivacyPolicy()
                    }
                }
                
                // Account Actions
                Section {
                    Button("Sign Out", role: .destructive) {
                        viewModel.signOut()
                    }
                }
            }
            .navigationTitle("Profile")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Edit") {
                        showingEditProfile = true
                    }
                }
            }
            .sheet(isPresented: $showingEditProfile) {
                EditProfileView()
            }
        }
    }
}


## ./AISnapStudy/Views/Main/HomeView.swift

// File: ./AISnapStudy/Views/Main/HomeView.swift

import SwiftUI
import Combine
import CoreData

struct HomeView: View {
    @ObservedObject var viewModel: HomeViewModel
    @Environment(\.managedObjectContext) private var context
    @Binding var selectedTab: Int
    @State private var showQuestionSettings = false
    @State private var selectedSubject: Subject = .math
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Create New Questions Button
                    MainActionButton(
                        title: "Create New Questions",
                        icon: "plus.circle.fill"
                    ) {
                        selectedSubject = .math // Default subject
                        showQuestionSettings = true
                    }
                    
                    // Review Questions Button
                    MainActionButton(
                        title: "Review Questions",
                        icon: "book.fill"
                    ) {
                        if let problemSet = viewModel.selectedProblemSet {
                            viewModel.setSelectedProblemSet(problemSet)
                            selectedTab = 1
                        }
                    }
                    .disabled(viewModel.selectedProblemSet == nil)
                    .opacity(viewModel.selectedProblemSet == nil ? 0.5 : 1)
                }
                .padding(.horizontal)
                .padding(.vertical, 32)
            }
            .navigationTitle("Home")
        }
        .sheet(isPresented: $showQuestionSettings) {
            QuestionSettingsView(
                subject: selectedSubject,
                homeViewModel: viewModel,
                selectedTab: $selectedTab  // selectedTab ë°”ì¸ë”© ì „ë‹¬
            )
        }
    }
}


## ./AISnapStudy/Views/Main/HistoryView.swift

import SwiftUI

struct HistoryView: View {
    @EnvironmentObject var homeViewModel: HomeViewModel
    @StateObject private var viewModel: HistoryViewModel
    @State private var searchText = ""
    
    init() {
        let vm = HistoryViewModel(homeViewModel: HomeViewModel.shared)
        self._viewModel = StateObject(wrappedValue: vm)
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                SearchBar(text: $searchText)
                    .padding(.horizontal)
                
                List {
                    // Saved Questions Section
                    Section(header: Text("Saved Questions")) {
                        NavigationLink(
                            destination: SavedQuestionsView(
                                questions: viewModel.savedQuestions,
                                homeViewModel: homeViewModel
                            )
                        ) {
                            HStack {
                                Image(systemName: "bookmark.fill")
                                    .foregroundColor(.blue)
                                Text("Saved Questions")
                                    .font(.headline)
                                Spacer()
                                Text("\(viewModel.savedQuestions.count)")
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    
                    // Subject folders
                    ForEach(Subject.allCases, id: \.self) { subject in
                        NavigationLink(
                            destination: ProblemSetsListView(
                                subject: subject,
                                problemSets: filteredAndSortedProblemSets(for: subject)
                            )
                        ) {
                            HStack {
                                Image(systemName: "folder.fill")
                                    .foregroundColor(.blue)
                                Text(subject.displayName)
                                    .font(.headline)
                                    .padding(.leading, 8)
                            }
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())
                .navigationTitle("History")
                .refreshable {
                    viewModel.refreshData()
                }
            }
        }
        .onAppear {
                    viewModel.setHomeViewModel(homeViewModel)
                }
    }
    
    var problemSets: [ProblemSet] {
        homeViewModel.problemSets
    }
    
    // Subjectë³„ë¡œ Problem Sets í•„í„°ë§ ë° ì •ë ¬í•˜ëŠ” ë©”ì„œë“œ
    private func filteredAndSortedProblemSets(for subject: Subject) -> [ProblemSet] {
        return viewModel.problemSets
            .filter { $0.subject == subject }
            .sorted(by: { $0.createdAt > $1.createdAt })
    }
}

struct SavedQuestionsView: View {
    let questions: [Question]
    let homeViewModel: HomeViewModel
    @State private var showStudyView = false
    
    var body: some View {
        List(questions) { question in
            SavedQuestionCard(question: question)
                .onTapGesture {
                    // Create a temporary ProblemSet for the saved question
                    let problemSet = ProblemSet(
                        id: UUID().uuidString,
                        title: "Saved Question",
                        subject: question.subject,
                        difficulty: question.difficulty,
                        questions: [question],
                        createdAt: Date(),
                        educationLevel: .elementary,
                        name: "Saved Question Practice"
                    )
                    homeViewModel.setSelectedProblemSet(problemSet)
                    showStudyView = true
                }
        }
        .navigationTitle("Saved Questions")
        .background(
            NavigationLink(
                isActive: $showStudyView,
                destination: {
                    if let studyViewModel = homeViewModel.studyViewModel {
                        StudyView(
                            questions: [questions[0]],
                            studyViewModel: studyViewModel,
                            selectedTab: .constant(1)
                        )
                    }
                },
                label: { EmptyView() }
            )
        )
    }
}

struct ProblemSetsListView: View {
    let subject: Subject
    let problemSets: [ProblemSet]
    @EnvironmentObject var homeViewModel: HomeViewModel
    @State private var isShowingStudyView = false
    
    var body: some View {
        List(problemSets) { problemSet in
            Button(action: {
                homeViewModel.setSelectedProblemSet(problemSet)
                isShowingStudyView = true
            }) {
                HistoryProblemSetCard(problemSet: problemSet)
            }
            .background(
                NavigationLink(
                    isActive: $isShowingStudyView,
                    destination: {
                        guard let studyViewModel = homeViewModel.studyViewModel else {
                            return AnyView(Text("Study ViewModel not available"))
                        }
                        return AnyView(
                            StudyView(
                                questions: problemSet.questions,
                                studyViewModel: studyViewModel,
                                selectedTab: .constant(1)
                            )
                        )
                    }
                ) { EmptyView() }
                .hidden()
            )
        }
        .navigationTitle("\(subject.displayName) Sets")
        .listStyle(InsetGroupedListStyle())
    }
}


## ./AISnapStudy/Views/Main/StudyView.swift

import SwiftUI
import CoreData

struct StudyView: View {
   @Environment(\.managedObjectContext) private var context
   @Binding var selectedTab: Int
   @ObservedObject var studyViewModel: StudyViewModel
   let questions: [Question]
   
   @State private var showExplanation: Bool = false
   @State private var isCorrect: Bool? = nil
   @State private var isSaved: Bool = false
   @State private var previewSelectedAnswer: String? = nil  // ì¶”ê°€
   @State private var previewIsCorrect: Bool? = nil        // ì¶”ê°€
   
   init(questions: [Question],
        studyViewModel: StudyViewModel,
        selectedTab: Binding<Int>) {
       self.questions = questions
       self._selectedTab = selectedTab
       self.studyViewModel = studyViewModel
   }
   
   var body: some View {
       VStack {
           // ì§ˆë¬¸ ìƒì„±ì¤‘ì¼ ë•Œì˜ ë·°
           if studyViewModel.isGeneratingQuestions {
               VStack(spacing: 16) {
                   ProgressView(value: Double(studyViewModel.generatedQuestionCount),
                              total: Double(studyViewModel.totalExpectedQuestions)) {
                       Text("Generating Questions...")
                           .font(.headline)
                   }
                   .progressViewStyle(.linear)
                   .padding()
                   
                   Text("\(studyViewModel.generatedQuestionCount) / \(studyViewModel.totalExpectedQuestions)")
                       .font(.subheadline)
                       .foregroundColor(.secondary)
                   
                   // ìƒì„±ëœ ì§ˆë¬¸ë“¤ ë¯¸ë¦¬ë³´ê¸°
                   if !studyViewModel.generatedQuestions.isEmpty {
                       ScrollView {
                           LazyVStack(spacing: 12) {
                               ForEach(studyViewModel.generatedQuestions) { question in
                                   QuestionPreviewCard(
                                       question: question,
                                       selectedAnswer: $previewSelectedAnswer,
                                       isCorrect: $previewIsCorrect,
                                       onAnswerSelected: { correct in
                                           print("Answer selected: \(correct)")
                                       }
                                   )
                                   .transition(.slide)
                               }
                           }
                           .padding()
                       }
                   }
               }
           }
           // ì¼ë°˜ í•™ìŠµ ë·°
           else {
               ProgressView(value: Double(min(studyViewModel.currentIndex + 1, studyViewModel.totalQuestions)),
                           total: Double(studyViewModel.totalQuestions))
                   .progressViewStyle(.linear)
                   .padding()
               
               Text("\(studyViewModel.currentIndex + 1) / \(studyViewModel.totalQuestions)")
                   .font(.subheadline)
                   .foregroundColor(.secondary)
               
               if !studyViewModel.hasQuestions {
                   Text("No questions available")
                       .font(.headline)
                       .foregroundColor(.gray)
               } else {
                   ScrollView {
                       VStack(alignment: .leading, spacing: 20) {
                           if let currentQuestion = studyViewModel.currentQuestion {
                               switch currentQuestion.type {
                               case .multipleChoice:
                                   MultipleChoiceView(
                                       question: currentQuestion,
                                       selectedAnswer: $studyViewModel.selectedAnswer,
                                       showExplanation: studyViewModel.showExplanation,
                                       isCorrect: isCorrect
                                   )
                                   
                               case .fillInBlanks:
                                   FillInBlanksView(
                                       question: currentQuestion,
                                       answer: $studyViewModel.selectedAnswer,
                                       showExplanation: studyViewModel.showExplanation,
                                       isCorrect: isCorrect
                                   )
                                   
                               case .trueFalse:
                                   TrueFalseView(
                                       question: currentQuestion,
                                       selectedAnswer: $studyViewModel.selectedAnswer,
                                       showExplanation: studyViewModel.showExplanation,
                                       isCorrect: isCorrect
                                   )
                               }
                               
                               if showExplanation && studyViewModel.showExplanation {
                                   ExplanationView(explanation: currentQuestion.explanation)
                               }
                           }
                       }
                       .padding()
                   }
                   
                   // Action Buttons
                   VStack {
                       Divider()
                       
                       HStack(spacing: 12) {
                           if studyViewModel.showExplanation {
                               UtilityButtons(
                                   showExplanation: $showExplanation,
                                   isSaved: $isSaved,
                                   studyViewModel: studyViewModel
                               )
                           }
                           
                           ActionButton(
                               viewModel: studyViewModel,
                               selectedTab: $selectedTab,
                               isCorrect: $isCorrect,
                               showExplanation: $showExplanation
                           )
                       }
                       .padding()
                       .background(Color(UIColor.systemBackground))
                   }
               }
           }
       }
       .onAppear {
           if let currentQuestion = studyViewModel.currentQuestion {
               isSaved = currentQuestion.isSaved
           }
       }
       .onChange(of: studyViewModel.currentQuestion) { newQuestion in
           if let question = newQuestion {
               isSaved = question.isSaved
           }
       }
   }
}

// ìƒˆë¡œ ì¶”ê°€ëœ ë¯¸ë¦¬ë³´ê¸° ì¹´ë“œ ë·°
struct QuestionPreviewCard: View {
  let question: Question
  @Binding var selectedAnswer: String?
  @Binding var isCorrect: Bool?
  var onAnswerSelected: (Bool) -> Void
  
  var body: some View {
      VStack(alignment: .leading, spacing: 16) {
          // ìƒë‹¨ ì •ë³´
          HStack {
              Text(question.type.rawValue.capitalized)
                  .font(.caption)
                  .padding(4)
                  .background(Color.blue.opacity(0.1))
                  .cornerRadius(4)
              
              Spacer()
              
              Text(question.difficulty.rawValue.capitalized)
                  .font(.caption)
                  .foregroundColor(.secondary)
          }
          
          // ì§ˆë¬¸
          Text(question.question)
              .font(.title3)
              .fontWeight(.semibold)
              .padding(.vertical, 4)
          
          // ë‹µë³€ ì˜µì…˜
          ForEach(question.options, id: \.self) { option in
              Button(action: {
                  selectedAnswer = option
                  let correct = checkAnswer(option)
                  isCorrect = correct
                  onAnswerSelected(correct)
              }) {
                  HStack {
                      Text(option)
                      Spacer()
                      if selectedAnswer == option {
                          Image(systemName: isCorrect == true ? "checkmark.circle.fill" : "xmark.circle.fill")
                              .foregroundColor(isCorrect == true ? .green : .red)
                      }
                  }
                  .padding()
                  .background(
                      selectedAnswer == option ?
                          (isCorrect == true ? Color.green.opacity(0.3) : Color.red.opacity(0.3)) :
                          Color.gray.opacity(0.1)
                  )
                  .cornerRadius(8)
              }
              .disabled(selectedAnswer != nil)
          }
      }
      .padding()
      .background(Color.white)
      .cornerRadius(12)
      .shadow(radius: 2)
  }
  
  private func checkAnswer(_ option: String) -> Bool {
      return option == question.correctAnswer
  }
}

// ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ë“¤ì€ ìœ ì§€
private struct ExplanationView: View {
   let explanation: String
   
   var body: some View {
       VStack(alignment: .leading, spacing: 12) {
           Text(explanation)
               .font(.body)
               .foregroundColor(.secondary)
               .padding()
               .background(Color.blue.opacity(0.1))
               .cornerRadius(10)
               .fixedSize(horizontal: false, vertical: true)
       }
       .transition(.move(edge: .top).combined(with: .opacity))
   }
}

private struct UtilityButtons: View {
   @Binding var showExplanation: Bool
   @Binding var isSaved: Bool
   @ObservedObject var studyViewModel: StudyViewModel
   
   var body: some View {
       Group {
           Button(action: {
               withAnimation {
                   showExplanation.toggle()
               }
           }) {
               Image(systemName: showExplanation ? "lightbulb.fill" : "lightbulb")
                   .foregroundColor(.yellow)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.yellow.opacity(0.2)))
           }
           
           Button(action: {
               if let currentQuestion = studyViewModel.currentQuestion {
                   Task {
                       await studyViewModel.toggleSaveQuestion(currentQuestion)
                       withAnimation {
                           isSaved.toggle()
                       }
                   }
               }
           }) {
               Image(systemName: isSaved ? "bookmark.fill" : "bookmark")
                   .foregroundColor(.blue)
                   .font(.system(size: 24))
                   .padding(8)
                   .background(Circle().fill(Color.blue.opacity(0.2)))
           }
       }
   }
}

private struct ActionButton: View {
   @ObservedObject var viewModel: StudyViewModel
   @Binding var selectedTab: Int
   @Binding var isCorrect: Bool?
   @Binding var showExplanation: Bool
   
   var body: some View {
       Button(action: {
           if viewModel.showExplanation {
               if viewModel.isLastQuestion {
                   viewModel.saveProgress()
                   selectedTab = 3
               } else {
                   viewModel.nextQuestion()
                   isCorrect = nil
                   showExplanation = false
               }
           } else {
               viewModel.submitAnswer()
               isCorrect = viewModel.selectedAnswer == viewModel.currentQuestion?.correctAnswer
           }
       }) {
           Text(viewModel.showExplanation ?
                (viewModel.isLastQuestion ? "Finish" : "Next Question") :
                   "Submit Answer")
               .font(.headline)
               .foregroundColor(.white)
               .frame(maxWidth: .infinity)
               .padding()
               .background(Color.accentColor)
               .cornerRadius(10)
       }
       .disabled(!viewModel.canSubmit)
   }
}


## ./AISnapStudy/Services/ImageService.swift

import UIKit
import Photos
import AVFoundation

public enum ImageSource {
   case camera
   case gallery
}

enum ImageServiceError: Error {
   case permissionDenied
   case unavailable
   case unknown(Error)
   case compressionFailed
}

public class ImageService {
    public static let shared = ImageService()
    
    private init() {}
    
    public struct VisionDetail {
        public static let maxDimension: CGFloat = 1024
        public static let maxFileSize = 1024 * 1024  // 100KB
        public static let compressionQuality: CGFloat = 0.9
    }
    
    func compressForAPI(_ image: UIImage) throws -> Data {
        // ì´ë¯¸ì§€ì˜ í¬ê¸°ë¥¼ ìµœëŒ€ ì¹˜ìˆ˜ì— ë§ê²Œ ì¡°ì •
        let resizedImage = resize(image, to: VisionDetail.maxDimension)
        
        // ì„¤ì •ëœ í’ˆì§ˆë¡œ ì••ì¶•
        var compressedData = resizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality)
        
        // í¬ê¸°ê°€ ìµœëŒ€ íŒŒì¼ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ëŠ” ê²½ìš°, í’ˆì§ˆì„ ë‚®ì¶°ì„œ ì¶”ê°€ ì••ì¶• ì‹œë„
        var compressionQuality = VisionDetail.compressionQuality
        while let data = compressedData, data.count > VisionDetail.maxFileSize, compressionQuality > 0.1 {
            compressionQuality -= 0.1
            compressedData = resizedImage.jpegData(compressionQuality: compressionQuality)
        }
        
        guard let finalData = compressedData, finalData.count <= VisionDetail.maxFileSize else {
            throw NSError(domain: "ImageCompression", code: 1, userInfo: [NSLocalizedDescriptionKey: "Unable to compress image to target size"])
        }
        
        print("Final compressed image size: \(finalData.count / 1024)KB with quality: \(compressionQuality)")
        return finalData
    }

    
    private func resize(_ image: UIImage, to maxDimension: CGFloat) -> UIImage {
        let aspectRatio = image.size.width / image.size.height
        let newSize: CGSize
        if image.size.width > image.size.height {
            newSize = CGSize(width: maxDimension, height: maxDimension / aspectRatio)
        } else {
            newSize = CGSize(width: maxDimension * aspectRatio, height: maxDimension)
        }
        
        UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
        image.draw(in: CGRect(origin: .zero, size: newSize))
        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resizedImage ?? image
    }
    
    public enum OptimizationType {
        case openAIVision
        case general(maxSizeKB: Int)
    }
    
    @MainActor
    public func requestPermission(for source: ImageSource) async throws -> Bool {
        switch source {
        case .gallery:
            let status = PHPhotoLibrary.authorizationStatus(for: .readWrite)
            switch status {
            case .authorized, .limited:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                        let isAuthorized = status == .authorized || status == .limited
                        print("Photo Library Authorization Status: \(status), Authorized: \(isAuthorized)")
                        continuation.resume(returning: isAuthorized)
                    }
                }
            case .denied, .restricted:
                print("Photo Library Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Photo Library Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "PhotoLibrary", code: -1))
            }
            
        case .camera:
            guard UIImagePickerController.isSourceTypeAvailable(.camera) else {
                print("Camera Not Available")
                throw ImageServiceError.unavailable
            }
            
            let status = AVCaptureDevice.authorizationStatus(for: .video)
            switch status {
            case .authorized:
                return true
            case .notDetermined:
                return await withCheckedContinuation { continuation in
                    AVCaptureDevice.requestAccess(for: .video) { granted in
                        print("Camera Authorization Status: \(granted)")
                        continuation.resume(returning: granted)
                    }
                }
            case .denied, .restricted:
                print("Camera Access Denied or Restricted")
                if let settingsUrl = URL(string: UIApplication.openSettingsURLString) {
                    await MainActor.run {
                        UIApplication.shared.open(settingsUrl)
                    }
                }
                throw ImageServiceError.permissionDenied
            @unknown default:
                print("Unknown Camera Authorization Status")
                throw ImageServiceError.unknown(NSError(domain: "Camera", code: -1))
            }
        }
    }
    
    public func optimizeForVision(_ image: UIImage) async throws -> (data: Data, tokens: Int) {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let originalSize = image.size
        let originalData = image.jpegData(compressionQuality: 1.0)?.count ?? 0
        
        // VisionDetailì˜ ì„¤ì • ê°’ì„ ì‚¬ìš©
        let targetSize = CGSize(width: VisionDetail.maxDimension, height: VisionDetail.maxDimension)
        let estimatedTokens = Int(VisionDetail.maxFileSize / 1024)  // ì˜ˆì¸¡ í† í° ìˆ˜ ê³„ì‚°
        
        let optimizedImage = try await optimizeImage(image, targetSize: targetSize)
        
        guard let optimizedData = optimizedImage.jpegData(compressionQuality: VisionDetail.compressionQuality) else {
            throw ImageServiceError.compressionFailed
        }
        
        let totalTime = CFAbsoluteTimeGetCurrent() - startTime
        printOptimizationMetrics(
            originalSize: originalSize,
            targetSize: targetSize,
            originalData: originalData,
            optimizedData: optimizedData.count,
            estimatedTokens: estimatedTokens,
            processingTime: totalTime
        )
        
        return (optimizedData, estimatedTokens)
    }
    
    public func compressImage(_ image: UIImage, optimization: OptimizationType) async throws -> Data {
        switch optimization {
        case .openAIVision:
            let result = try await optimizeForVision(image)
            return result.data
            
        case .general(let maxSizeKB):
            guard let originalImageData = image.jpegData(compressionQuality: 1.0) else {
                throw ImageServiceError.compressionFailed
            }
            
            var compression: CGFloat = 1.0
            var currentData = originalImageData
            
            while currentData.count > maxSizeKB * 1024 && compression > 0.1 {
                compression -= 0.1
                if let compressedData = image.jpegData(compressionQuality: compression) {
                    currentData = compressedData
                    print("Compression ratio \(compression): \(Double(currentData.count) / 1024.0)KB")
                }
            }
            
            if currentData.count > maxSizeKB * 1024 {
                let scale = sqrt(Double(maxSizeKB * 1024) / Double(currentData.count))
                let newSize = CGSize(
                    width: image.size.width * scale,
                    height: image.size.height * scale
                )
                
                print("Image resizing: \(newSize.width) x \(newSize.height)")
                
                UIGraphicsBeginImageContextWithOptions(newSize, false, image.scale)
                image.draw(in: CGRect(origin: .zero, size: newSize))
                if let resizedImage = UIGraphicsGetImageFromCurrentImageContext(),
                   let finalData = resizedImage.jpegData(compressionQuality: compression) {
                    UIGraphicsEndImageContext()
                    print("Final compressed image size: \(Double(finalData.count) / 1024.0)KB")
                    return finalData
                }
                UIGraphicsEndImageContext()
                throw ImageServiceError.compressionFailed
            }
            
            print("Final compressed image size: \(Double(currentData.count) / 1024.0)KB")
            return currentData
        }
    }
    
    private func optimizeImage(_ image: UIImage, targetSize: CGSize) async throws -> UIImage {
        return await withCheckedContinuation { continuation in
            let format = UIGraphicsImageRendererFormat()
            format.scale = 1.0
            
            let renderer = UIGraphicsImageRenderer(size: targetSize, format: format)
            let optimizedImage = renderer.image { context in
                image.draw(in: CGRect(origin: .zero, size: targetSize))
            }
            
            continuation.resume(returning: optimizedImage)
        }
    }
    
    private func printOptimizationMetrics(
        originalSize: CGSize,
        targetSize: CGSize,
        originalData: Int,
        optimizedData: Int,
        estimatedTokens: Int,
        processingTime: TimeInterval
    ) {
        print("""
        ğŸ“Š Image Optimization Results:
        â€¢ Original Size: \(Int(originalSize.width))x\(Int(originalSize.height))
        â€¢ Optimized Size: \(Int(targetSize.width))x\(Int(targetSize.height))
        â€¢ Original Data: \(ByteCountFormatter.string(fromByteCount: Int64(originalData), countStyle: .file))
        â€¢ Optimized Data: \(ByteCountFormatter.string(fromByteCount: Int64(optimizedData), countStyle: .file))
        â€¢ Estimated Tokens: \(estimatedTokens)
        â€¢ Processing Time: \(String(format: "%.3f", processingTime))s
        â€¢ Reduction: \(String(format: "%.1f", (1.0 - Double(optimizedData)/Double(originalData)) * 100))%
        """)
    }
}


## ./AISnapStudy/Services/StorageService.swift


import Foundation

public enum StorageError: Error {
    case saveFailed
    case loadFailed
    case deleteFailed
    case notFound
    case invalidData
}

public class StorageService {
    private let defaults = UserDefaults.standard
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()
    
    private let problemSetsKey = "problemSets"
    private let savedQuestionsKey = "savedQuestions"
    private let studySessionsKey = "studySessions"
    
    private let fileManager = FileManager.default
     
     private var documentDirectory: URL? {
         fileManager.urls(for: .documentDirectory, in: .userDomainMask).first
     }
     
     private func getDirectoryURL(for type: String) -> URL? {
         documentDirectory?.appendingPathComponent(type)
     }
     
     private func handleFileOperation<T>(_ operation: () throws -> T) throws -> T {
         do {
             return try operation()
         } catch let error as NSError {
             print("""
             âŒ File Operation Error:
             â€¢ Error Domain: \(error.domain)
             â€¢ Error Code: \(error.code)
             â€¢ Description: \(error.localizedDescription)
             """)
             
             // ì¬ì‹œë„ ë¡œì§
             let retryCount = 3
             for attempt in 1...retryCount {
                 print("ğŸ”„ Retrying operation (attempt \(attempt)/\(retryCount))")
                 do {
                     return try operation()
                 } catch {
                     if attempt == retryCount {
                         throw error
                     }
                     Thread.sleep(forTimeInterval: 0.5)
                 }
             }
             throw error
         }
     }
    
    // MARK: - Problem Sets
    public func saveProblemSet(_ problemSet: ProblemSet) throws {
        try handleFileOperation {
            var problemSets = try getProblemSets()
            problemSets.append(problemSet)
            
            let data = try encoder.encode(problemSets)
            defaults.set(data, forKey: problemSetsKey)
        }
    }
        
    
    public func getProblemSets() throws -> [ProblemSet] {
        guard let data = defaults.data(forKey: problemSetsKey) else {
            return []
        }
        
        do {
            return try decoder.decode([ProblemSet].self, from: data)
        } catch {
            throw StorageError.loadFailed
        }
    }
    
    // MARK: - Study Sessions
    public func saveStudySession(_ session: StudySession) throws {
        var sessions = try getStudySessions()
        sessions.append(session)
        
        do {
            let data = try encoder.encode(sessions)
            defaults.set(data, forKey: studySessionsKey)
        } catch {
            throw StorageError.saveFailed
        }
    }
    
    public func getStudySessions() throws -> [StudySession] {
        guard let data = defaults.data(forKey: studySessionsKey) else {
            return []
        }
        
        do {
            return try decoder.decode([StudySession].self, from: data)
        } catch {
            throw StorageError.loadFailed
        }
    }
    
    public func deleteStudySession(_ session: StudySession) throws {
        var sessions = try getStudySessions()
        
        guard let index = sessions.firstIndex(where: { $0.id == session.id }) else {
            throw StorageError.notFound
        }
        
        sessions.remove(at: index)
        
        do {
            let data = try encoder.encode(sessions)
            defaults.set(data, forKey: studySessionsKey)
        } catch {
            throw StorageError.deleteFailed
        }
    }
    
    // MARK: - Saved Questions
    public func saveQuestion(_ question: Question) throws {
        var savedQuestions = try getSavedQuestions()
        savedQuestions.append(question)
        
        do {
            let data = try encoder.encode(savedQuestions)
            defaults.set(data, forKey: savedQuestionsKey)
        } catch {
            throw StorageError.saveFailed
        }
    }
    
    public func getSavedQuestions() throws -> [Question] {
        guard let data = defaults.data(forKey: savedQuestionsKey) else {
            return []
        }
        
        do {
            return try decoder.decode([Question].self, from: data)
        } catch {
            throw StorageError.loadFailed
        }
    }
    

    public func saveQuestions(_ questions: [Question]) throws {
        do {
            let data = try encoder.encode(questions)
            defaults.set(data, forKey: savedQuestionsKey)
        } catch {
            throw StorageError.saveFailed
        }
    }
}


## ./AISnapStudy/Services/OpenAIService.swift

import Foundation
import UIKit

class OpenAIService {
    private let apiKey: String
    private let baseURL = "https://api.openai.com/v1/chat/completions"
    private let session: URLSession
    private let cache = NSCache<NSString, NSArray>()
    
    // MARK: - Models
    public struct QuestionInput {    // private -> public ìœ¼ë¡œ ë³€ê²½
        let content: Data
        let isImage: Bool
        let contentHash: String
        
        public init(content: Data, isImage: Bool) {  // public init ì¶”ê°€
            self.content = content
            self.isImage = isImage
            self.contentHash = content.hashValue.description
        }
    }
    
    public struct QuestionParameters {    // private -> public ìœ¼ë¡œ ë³€ê²½
        let subject: Subject
        let difficulty: Difficulty
        let educationLevel: EducationLevel
        let questionTypes: [QuestionType: Int]
        
        public init(    // public init ì¶”ê°€
            subject: Subject,
            difficulty: Difficulty,
            educationLevel: EducationLevel,
            questionTypes: [QuestionType: Int]
        ) {
            self.subject = subject
            self.difficulty = difficulty
            self.educationLevel = educationLevel
            self.questionTypes = questionTypes
        }
    }
    private func buildMessages(input: QuestionInput, prompts: (system: String, user: String)) -> [[String: Any]] {
        if input.isImage {
            do {
                guard let image = UIImage(data: input.content) else {
                    print("âŒ Failed to create UIImage from data")
                    throw NetworkError.invalidData
                }

                let compressedData = try ImageService.shared.compressForAPI(image)
                let base64ImageString = compressedData.base64EncodedString()
                
                print("ğŸ“¸ Image prepared: \(ByteCountFormatter.string(fromByteCount: Int64(compressedData.count), countStyle: .file))")
                
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": prompts.user
                        ],
                        [
                            "type": "image_url",
                            "image_url": [
                                "url": "data:image/jpeg;base64,\(base64ImageString)"
                            ]
                        ]
                    ]]
                ]
            } catch {
                print("âŒ Error preparing image: \(error)")
                return []
            }
        } else {
            if let textContent = String(data: input.content, encoding: .utf8) {
                return [
                    ["role": "system", "content": prompts.system],
                    ["role": "user", "content": [
                        [
                            "type": "text",
                            "text": "\(prompts.user)\n\nText data: \(textContent)"
                        ]
                    ]]
                ]
            }
            return []
        }
    }
    
    // StreamResponse êµ¬ì¡°ì²´ë„ í•„ìš”í•©ë‹ˆë‹¤
    private struct StreamResponse: Codable {
        struct Choice: Codable {
            struct Delta: Codable {
                let content: String?
            }
            let delta: Delta
        }
        let choices: [Choice]
    }

    // extractCompleteQuestion í•¨ìˆ˜ë„ ì¶”ê°€
    private func extractCompleteQuestion(from json: String) throws -> QuestionGenerationSchema.QuestionData? {
        guard let jsonData = json.data(using: .utf8) else {
            return nil
        }
        
        // JSONì´ ì™„ì „í•œ ê°ì²´ì¸ì§€ í™•ì¸
        guard json.contains("}") else {
            return nil
        }
        
        do {
            let decoder = JSONDecoder()
            let questionData = try decoder.decode(QuestionGenerationSchema.QuestionData.self, from: jsonData)
            return questionData
        } catch {
            // JSONì´ ì•„ì§ ì™„ì„±ë˜ì§€ ì•Šì•˜ê±°ë‚˜ íŒŒì‹±í•  ìˆ˜ ì—†ëŠ” ê²½ìš°
            return nil
        }
    }
    
    // ìŠ¤íŠ¸ë¦¬ë°ì„ ìœ„í•œ ìƒˆë¡œìš´ ë©”ì„œë“œ ì¶”ê°€
    public func streamQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) -> AsyncThrowingStream<Question, Error> {
        return AsyncThrowingStream { continuation in
            Task {
                do {
                    print("ğŸ”„ Starting question stream generation...")
                    let (schema, prompts) = try await preparePromptAndSchema(input: input, parameters: parameters)
                    
                    var request = URLRequest(url: URL(string: baseURL)!)
                    request.httpMethod = "POST"
                    request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
                    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                    
                    let requestBody: [String: Any] = [
                        "model": OpenAIModel.gpt4Vision,
                        "messages": buildMessages(input: input, prompts: prompts),
                        "stream": true,  // ìŠ¤íŠ¸ë¦¬ë° í™œì„±í™”
                        "max_tokens": OpenAIModel.maxTokens,
                        "temperature": 0.7,
                        "response_format": ["type": "json_object"]  // JSON ì‘ë‹µ í˜•ì‹ ì§€ì •
                    ]
                    
                    request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
                    
                    print("ğŸŒ Starting streaming request...")
                    let (result, response) = try await session.bytes(for: request)
                    
                    guard let httpResponse = response as? HTTPURLResponse else {
                        throw NetworkError.invalidResponse
                    }
                    
                    print("ğŸ“¡ Stream connected with status: \(httpResponse.statusCode)")
                    
                    var questionBuffer = ""
                    var questionCount = 0
                    
                    for try await line in result.lines {
                        if line.hasPrefix("data: "), let data = line.dropFirst(6).data(using: .utf8) {
                            if let streamResponse = try? JSONDecoder().decode(StreamResponse.self, from: data),
                               let content = streamResponse.choices.first?.delta.content {
                                questionBuffer += content
                                
                                // JSON ê°ì²´ê°€ ì™„ì„±ë˜ë©´ íŒŒì‹±
                                if let questionData = try? extractCompleteQuestion(from: questionBuffer) {
                                    questionCount += 1
                                    print("âœ… Streaming question \(questionCount): \(questionData.question)")
                                    
                                    let question = Question(
                                        id: UUID().uuidString,
                                        type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                                        subject: parameters.subject,
                                        difficulty: parameters.difficulty,
                                        question: questionData.question,
                                        options: questionData.options,
                                        correctAnswer: questionData.correctAnswer,
                                        explanation: questionData.explanation,
                                        hint: questionData.hint,
                                        isSaved: false,
                                        createdAt: Date()
                                    )
                                    
                                    continuation.yield(question)
                                    questionBuffer = ""
                                }
                            }
                        }
                    }
                    
                    print("âœ… Stream completed: Generated \(questionCount) questions")
                    continuation.finish()
                } catch {
                    print("âŒ Stream error: \(error)")
                    continuation.finish(throwing: error)
                }
            }
        }
    }
    
    // ë‚˜ë¨¸ì§€ private êµ¬ì¡°ì²´ë“¤ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
    private struct SubjectPrompt {
        let systemPrompt: String
        let userPromptTemplate: String
    }
    
    private enum OpenAIModel {
        static let gpt4Vision = "gpt-4o"
        static let maxTokens = 4000
    }
    
    // MARK: - Initialization
    init() throws {
        self.apiKey = try ConfigurationManager.shared.getValue(for: "OpenAIAPIKey")
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 60
        configuration.timeoutIntervalForResource = 300
        configuration.waitsForConnectivity = true
        configuration.tlsMinimumSupportedProtocolVersion = .TLSv12
        self.session = URLSession(configuration: configuration)
    }
    
    // MARK: - Main Question Generation Method
    func generateQuestions(
        from input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        guard NetworkMonitor.shared.isReachable else {
            throw NetworkError.noConnection
        }
        
        let cacheKey = "\(input.contentHash)_\(parameters.subject.rawValue)_\(parameters.difficulty.rawValue)"
        if let cachedQuestions = cache.object(forKey: cacheKey as NSString) as? [Question] {
            print("âœ… Retrieved questions from cache")
            return cachedQuestions
        }
        
        return try await withThrowingTaskGroup(of: Any.self) { group -> [Question] in
            var processedInput: Data?
            var processedTextInput: String?
            var preparedData: (schema: [String: Any], prompts: (system: String, user: String))?

            // ì´ë¯¸ì§€ ë˜ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ëŠ” íƒœìŠ¤í¬ ì¶”ê°€
            group.addTask(priority: .userInitiated) {
                if input.isImage {
                    processedInput = input.content
                } else {
                    processedTextInput = String(data: input.content, encoding: .utf8) ?? ""
                }
            }

            group.addTask(priority: .userInitiated) {
                return try await self.preparePromptAndSchema(input: input, parameters: parameters)
            }

            for try await result in group {
                if let schemaResult = result as? ([String: Any], (String, String)) {
                    preparedData = schemaResult
                }
            }

            guard let prepared = preparedData else {
                throw NetworkError.invalidData
            }

            let questions = try await self.performQuestionGeneration(
                input: processedInput,                     // ì´ë¯¸ì§€ ë°ì´í„° ì „ë‹¬
                textInput: processedTextInput,             // í…ìŠ¤íŠ¸ ë°ì´í„° ì „ë‹¬
                schema: prepared.schema,
                systemPrompt: prepared.prompts.system,
                userPrompt: prepared.prompts.user,
                parameters: parameters
            )

            self.cache.setObject(questions as NSArray, forKey: cacheKey as NSString)
            return questions
        }
    }
    
    // MARK: - Subject-Specific Prompts
    private func getSubjectPrompt(_ subject: Subject, isImageInput: Bool, educationLevel: EducationLevel, difficulty: Difficulty) -> SubjectPrompt {
        if isImageInput {
            return SubjectPrompt(
                systemPrompt: """
                   You are an \(subject.displayName) expert specializing in creating questions based on image content.
                   IMPORTANT: Generate questions in the SAME LANGUAGE as any text visible in the image.
                   If the image contains Korean text, questions must be in Korean.
                   """,
                userPromptTemplate: """
                   Please analyze the uploaded image and generate questions based on its content.
                   Maintain the same language as any text found in the image.
                   IMPORTANT: If you ask a question related to a specific part of the image, be sure to include a description of that part in your question. This ensures that users who did not upload the image can still understand and address the question
                   """
            )
        } else {
            return SubjectPrompt(
                systemPrompt: """
                   You are an \(subject.displayName) expert specializing in creating questions for \(educationLevel.displayName) school students.
                   IMPORTANT: Generate questions in the EXACT SAME LANGUAGE as the input text.
                   If the input is in Korean, questions MUST be in Korean.
                   
                   Questions should:
                   - be made understandable at the level of \(educationLevel.displayName) school students. 
                   - Preserve the input text's language
                   - Use clear, precise language 
                   - Include detailed explanations and hints
                   - Never reference any images when input is text
                   """,
                userPromptTemplate: """
                   Generate questions based on the following text. 
                   Maintain the exact same language as the input text.
                   The questions should be suitable for \(educationLevel.displayName) level students at a \(difficulty.displayName) difficulty level.
                   """
            )
        }
    }
    
    // MARK: - Schema and Prompt Preparation
    private func preparePromptAndSchema(
        input: QuestionInput,
        parameters: QuestionParameters
    ) async throws -> ([String: Any], (String, String)) {
        // Add validation for required question counts
        let requiredCounts = parameters.questionTypes
        let subjectPrompt = getSubjectPrompt(
            parameters.subject,
            isImageInput: input.isImage,
            educationLevel: parameters.educationLevel,
            difficulty: parameters.difficulty
        )
        let schema = try await generateSchema(for: parameters.questionTypes)
        
        let systemPrompt = """
            \(subjectPrompt.systemPrompt)
            Required question distribution:
                \(requiredCounts.map { "- \($0.key.rawValue): \($0.value) questions" }.joined(separator: "\n\t"))
            """
        
        let userPrompt = subjectPrompt.userPromptTemplate
            .replacingOccurrences(of: "{input_type}", with: input.isImage ? "image" : "text")
            .replacingOccurrences(of: "{education_level}", with: parameters.educationLevel.rawValue)
            .replacingOccurrences(of: "{difficulty}", with: parameters.difficulty.rawValue)
        
        return (schema, (systemPrompt, userPrompt))
    }
    
    // MARK: - Schema Generation
    private func generateSchema(for questionTypes: [QuestionType: Int]) async throws -> [String: Any] {
        let questionTypeEnums = questionTypes.keys.map { $0.rawValue }
        
        return [
            "type": "object",
            "additionalProperties": false,
            "properties": [
                "questions": [
                    "type": "array",
                    "items": [
                        "type": "object",
                        "additionalProperties": false,
                        "properties": [
                            "type": ["type": "string", "enum": questionTypeEnums],
                            "question": ["type": "string"],
                            "options": ["type": "array", "items": ["type": "string"]],
                            "correctAnswer": ["type": "string"],
                            "explanation": ["type": "string"],
                            "hint": ["type": "string"]
                        ],
                        "required": ["type", "question", "options", "correctAnswer", "explanation", "hint" ]
                    ]
                ]
            ],
            "required": ["questions"]
        ]
    }
    
    private func performQuestionGeneration(
        input: Data?,
        textInput: String?,
        schema: [String: Any],
        systemPrompt: String,
        userPrompt: String,
        parameters: QuestionParameters
    ) async throws -> [Question] {
        print("ğŸ¤– OpenAI Prompt Information:")
        print("\nSystem Prompt:\n-------------\n\(systemPrompt)")
        print("\nUser Prompt:\n-----------\n\(userPrompt)")

        // messages ë°°ì—´ì„ ë¯¸ë¦¬ ì„ ì–¸
        var messages: [[String: Any]]

        // êµ¬ì¡°í™”ëœ ë©”ì‹œì§€ ìƒì„±
        if let imageData = input {
            guard let image = UIImage(data: imageData) else {
                throw NetworkError.invalidData
            }

            let compressedImageData = try ImageService.shared.compressForAPI(image)
            let base64ImageString = compressedImageData.base64EncodedString()
            
            print("Compressed and Encoded Image (Base64) Size: \(base64ImageString.count) characters")

            // OpenAI ê³µì‹ ë©€í‹°ëª¨ë‹¬ í¬ë§· ì‚¬ìš©
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": userPrompt
                    ],
                    [
                        "type": "image_url",
                        "image_url": [
                            "url": "data:image/jpeg;base64,\(base64ImageString)"
                        ]
                    ]
                ]]
            ]
        } else if let textData = textInput {
            messages = [
                ["role": "system", "content": systemPrompt],
                ["role": "user", "content": [
                    [
                        "type": "text",
                        "text": "\(userPrompt)\n\nText data: \(textData)"
                    ]
                ]]
            ]
        } else {
            throw NetworkError.invalidData
        }

        let requestBody: [String: Any] = [
            "model": OpenAIModel.gpt4Vision,
            "max_tokens": OpenAIModel.maxTokens,
            "messages": messages,
            "response_format": [
                "type": "json_schema",
                "json_schema": [
                    "name": "question_generation",
                    "strict": true,
                    "schema": schema
                ]
            ]
        ]
        
        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("gzip, deflate, br", forHTTPHeaderField: "Accept-Encoding")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

        print("""
        ğŸŒ API Request:
        â€¢ URL: \(baseURL)
        â€¢ Method: POST
        â€¢ Content Type: \(request.value(forHTTPHeaderField: "Content-Type") ?? "none")
        """)

        let (data, response) = try await session.data(for: request)

        if let httpResponse = response as? HTTPURLResponse {
            print("""
            ğŸŒ API Response:
            â€¢ Status Code: \(httpResponse.statusCode)
            â€¢ Headers: \(httpResponse.allHeaderFields)
            """)
        }

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }

        guard httpResponse.statusCode == 200 else {
            if let errorResponse = try? JSONDecoder().decode(OpenAIErrorResponse.self, from: data) {
                throw NetworkError.apiError(errorResponse.error.message)
            }
            throw NetworkError.invalidResponse
        }

        let decodedResponse = try JSONDecoder().decode(OpenAIResponse.self, from: data)

        guard let content = decodedResponse.choices.first?.message.content,
              let jsonData = content.data(using: .utf8) else {
            throw NetworkError.invalidData
        }

        let questionSchema = try JSONDecoder().decode(QuestionGenerationSchema.self, from: jsonData)

        let questions = questionSchema.questions.map { questionData in
            Question(
                id: UUID().uuidString,
                type: QuestionType(rawValue: questionData.type) ?? .multipleChoice,
                subject: parameters.subject,
                difficulty: parameters.difficulty,
                question: questionData.question,
                options: questionData.options,
                correctAnswer: questionData.correctAnswer,
                explanation: questionData.explanation,
                hint: questionData.hint,
                isSaved: false,
                createdAt: Date()
            )
        }

        print("""
        âœ… Questions Generated:
        â€¢ Count: \(questions.count)
        â€¢ Types: \(Dictionary(grouping: questions, by: { $0.type }).map { "\($0.key): \($0.value.count)" })
        """)

        return questions
    }
    
}


## ./AISnapStudy/Services/NetworkMonitor.swift



import Network
import SwiftUI

class NetworkMonitor: ObservableObject {
    static let shared = NetworkMonitor()
    private let monitor = NWPathMonitor()
    private let monitorQueue = DispatchQueue(label: "NetworkMonitor", qos: .utility)
    
    @Published private(set) var status: NWPath.Status = .requiresConnection
    @Published private(set) var isReachable = false
    @Published private(set) var connectionType: NWInterface.InterfaceType?
    @Published private(set) var isExpensive = false
    @Published private(set) var isConstrained = false
    
    private init() {
        startMonitoring()
    }
    
    func startMonitoring() {
        monitor.pathUpdateHandler = { [weak self] path in
            DispatchQueue.main.async {
                self?.status = path.status
                self?.isReachable = path.status == .satisfied
                self?.connectionType = path.availableInterfaces.first?.type
                self?.isExpensive = path.isExpensive
                self?.isConstrained = path.isConstrained
                
                // ì—°ê²° ìƒíƒœ ë³€ê²½ ì‹œ ì¬ì‹œë„ ë¡œì§ êµ¬í˜„
                if path.status == .satisfied {
                    NotificationCenter.default.post(
                        name: Notification.Name("NetworkConnectionEstablished"),
                        object: nil
                    )
                }
            }
        }
        monitor.start(queue: monitorQueue)
    }
    
    // ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ì„ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜ ì¶”ê°€
    private func getInterfaceTypeString(_ type: NWInterface.InterfaceType?) -> String {
        guard let type = type else { return "unknown" }
        
        switch type {
        case .wifi:
            return "WiFi"
        case .cellular:
            return "Cellular"
        case .wiredEthernet:
            return "Ethernet"
        case .loopback:
            return "Loopback"
        case .other:
            return "Other"
        @unknown default:
            return "Unknown"
        }
    }
    
    func stopMonitoring() {
        monitor.cancel()
    }
    
    deinit {
        stopMonitoring()
    }
}


